/*
 Navicat Premium Data Transfer

 Source Server         : 124.220.96.197
 Source Server Type    : MySQL
 Source Server Version : 50725 (5.7.25)
 Source Host           : 124.220.96.197:3306
 Source Schema         : msblog

 Target Server Type    : MySQL
 Target Server Version : 50725 (5.7.25)
 File Encoding         : 65001

 Date: 23/04/2024 15:40:58
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for admin
-- ----------------------------
DROP TABLE IF EXISTS `admin`;
CREATE TABLE `admin`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `name` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '真实姓名',
  `username` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
  `email` varchar(25) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '用户邮箱',
  `password` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码',
  `phone` varchar(11) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '手机号',
  `sex` varchar(2) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '性别，1男0女',
  `id_number` varchar(18) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '身份证号',
  `image` varchar(120) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '头像',
  `role` json NOT NULL COMMENT '角色',
  `root` tinyint(1) NOT NULL DEFAULT 0 COMMENT '是否是超级管理员',
  `status` int(2) NULL DEFAULT 1 COMMENT '账号状态, 1正常 0锁定',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '最后修改时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人id',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '最后修改人id',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_username`(`username`) USING BTREE,
  UNIQUE INDEX `idx_phone`(`phone`) USING BTREE,
  UNIQUE INDEX `idx_email`(`email`) USING BTREE,
  UNIQUE INDEX `id_number`(`id_number`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 17 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '管理员表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of admin
-- ----------------------------
INSERT INTO `admin` VALUES (10, '管理员', 'Admin', 'admin@126.com', 'e10adc3949ba59abbe56e057f20f883e', '13219895921', '1', '540321197311181095', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/ed2d5702-1c8a-44dd-85e9-92f1050e7249.png', '[10]', 1, 1, '2024-03-04 19:25:31', '2024-04-23 13:16:32', 10, 10);
INSERT INTO `admin` VALUES (16, '普通管理员', 'Test', 'test@126.com', 'e10adc3949ba59abbe56e057f20f883e', '15101151118', '0', '350121195408312770', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/cb5d174c-5112-4c25-b7e4-08d4bb55053b.png', '[11, 14]', 0, 1, '2024-03-04 19:25:31', '2024-04-23 13:16:45', 10, 10);

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '博文ID',
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博文标题',
  `category_id` bigint(20) NOT NULL COMMENT '博文分类id',
  `tags_id` json NOT NULL COMMENT '博文标签id',
  `image` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图片路径',
  `summary` varchar(300) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '摘要',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博文内容',
  `views` bigint(20) NULL DEFAULT NULL COMMENT '浏览量',
  `status` int(2) NULL DEFAULT 1 COMMENT '博文状态 0:禁用，1:启用',
  `comment_count` bigint(20) NULL DEFAULT NULL COMMENT '评论总数',
  `favorite_count` bigint(20) NULL DEFAULT NULL COMMENT '收藏总数',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '最后修改时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人id',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '最后修改人id',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_title`(`title`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博文表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES (1, '大事件项目接口文档', 11, '[42, 53, 52, 39, 58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/cf74e66a-2656-418d-a90e-846c3785a808.jpeg', '大事件后台 API 项目', '# 大事件项目接口文档\n\n- [大事件后台 API 项目，API 接口文档请参考](https://www.showdoc.cc/escook?page_id=3707158761215217)\n- [推荐一款 VSCode 主题](https://marketplace.visualstudio.com/items?itemName=liulongbin1314.escook-theme&ssr=false#overview)\n\n## 1. 初始化\n\n### 1.1 创建项目\n\n1. 新建 `api_server` 文件夹作为项目根目录，并在项目根目录中运行如下的命令，初始化包管理配置文件：\n\n```bash\nnpm init -y\n```\n\n2. 运行如下的命令，安装特定版本的 `express`：\n\n```bash\nnpm i express@4.17.1\n```\n\n3. 在项目根目录中新建 `app.js` 作为整个项目的入口文件，并初始化如下的代码：\n\n```js\n// 导入 express 模块\nconst express = require(\'express\')\n// 创建 express 的服务器实例\nconst app = express()\n\n// write your code here...\n\n// 调用 app.listen 方法，指定端口号并启动web服务器\napp.listen(3007, function () {\n  console.log(\'api server running at http://127.0.0.1:3007\')\n})\n```\n\n### 1.2 配置 cors 跨域\n\n1. 运行如下的命令，安装 `cors` 中间件：\n\n```bash\nnpm i cors@2.8.5\n```\n\n2. 在 `app.js` 中导入并配置 `cors` 中间件：\n\n```js\n// 导入 cors 中间件\nconst cors = require(\'cors\')\n// 将 cors 注册为全局中间件\napp.use(cors())\n```\n\n### 1.3 配置解析表单数据的中间件\n\n1. 通过如下的代码，配置解析 `application/x-www-form-urlencoded` 格式的表单数据的中间件：\n\n```js\napp.use(express.urlencoded({ extended: false }))\n```\n\n### 1.4 初始化路由相关的文件夹\n\n1. 在项目根目录中，新建 `router` 文件夹，用来存放所有的`路由`模块\n   > 路由模块中，只存放客户端的请求与处理函数之间的映射关系\n2. 在项目根目录中，新建 `router_handler` 文件夹，用来存放所有的 `路由处理函数模块`\n   > 路由处理函数模块中，专门负责存放每个路由对应的处理函数\n\n### 1.5 初始化用户路由模块\n\n1. 在 `router` 文件夹中，新建 `user.js` 文件，作为用户的路由模块，并初始化代码如下：\n\n```js\nconst express = require(\'express\')\n// 创建路由对象\nconst router = express.Router()\n\n// 注册新用户\nrouter.post(\'/reguser\', (req, res) => {\n  res.send(\'reguser OK\')\n})\n\n// 登录\nrouter.post(\'/login\', (req, res) => {\n  res.send(\'login OK\')\n})\n\n// 将路由对象共享出去\nmodule.exports = router\n```\n\n2. 在 `app.js` 中，导入并使用 `用户路由模块` ：\n\n```js\n// 导入并注册用户路由模块\nconst userRouter = require(\'./router/user\')\napp.use(\'/api\', userRouter)\n```\n\n### 1.6 抽离用户路由模块中的处理函数\n\n> 目的：为了保证 `路由模块` 的纯粹性，所有的 `路由处理函数`，必须抽离到对应的 `路由处理函数模块` 中\n\n1. 在 `/router_handler/user.js` 中，使用 `exports` 对象，分别向外共享如下两个 `路由处理函数` ：\n\n```js\n/**\n * 在这里定义和用户相关的路由处理函数，供 /router/user.js 模块进行调用\n */\n\n// 注册用户的处理函数\nexports.regUser = (req, res) => {\n  res.send(\'reguser OK\')\n}\n\n// 登录的处理函数\nexports.login = (req, res) => {\n  res.send(\'login OK\')\n}\n```\n\n2. 将 `/router/user.js` 中的代码修改为如下结构：\n\n```js\nconst express = require(\'express\')\nconst router = express.Router()\n\n// 导入用户路由处理函数模块\nconst userHandler = require(\'../router_handler/user\')\n\n// 注册新用户\nrouter.post(\'/reguser\', userHandler.regUser)\n// 登录\nrouter.post(\'/login\', userHandler.login)\n\nmodule.exports = router\n```\n\n## 2. 登录注册\n\n### 2.1 新建 ev_users 表\n\n1. 在 `my_db_01` 数据库中，新建 `ev_users` 表如下：\n   ![ev_users表结构](https://qarabala.gitee.io/api_server/mds/images/1.jpeg)\n\n### 2.2 安装并配置 mysql 模块\n\n> 在 API 接口项目中，需要安装并配置 `mysql` 这个第三方模块，来连接和操作 MySQL 数据库\n\n1. 运行如下命令，安装 `mysql` 模块：\n\n```bash\nnpm i mysql@2.18.1\n```\n\n2. 在项目根目录中新建 `/db/index.js` 文件，在此自定义模块中创建数据库的连接对象：\n\n```js\n// 导入 mysql 模块\nconst mysql = require(\'mysql\')\n\n// 创建数据库连接对象\nconst db = mysql.createPool({\n  host: \'127.0.0.1\',\n  user: \'root\',\n  password: \'admin123\',\n  database: \'my_db_01\',\n})\n\n// 向外共享 db 数据库连接对象\nmodule.exports = db\n```\n\n### 2.3 注册\n\n#### 2.3.0 实现步骤\n\n1. 检测表单数据是否合法\n2. 检测用户名是否被占用\n3. 对密码进行加密处理\n4. 插入新用户\n\n#### 2.3.1 检测表单数据是否合法\n\n1. 判断用户名和密码是否为空\n\n```js\n// 接收表单数据\nconst userinfo = req.body\n// 判断数据是否合法\nif (!userinfo.username || !userinfo.password) {\n  return res.send({ status: 1, message: \'用户名或密码不能为空！\' })\n}\n```\n\n#### 2.3.2 检测用户名是否被占用\n\n1. 导入数据库操作模块：\n\n```js\nconst db = require(\'../db/index\')\n```\n\n2. 定义 SQL 语句：\n\n```js\nconst sql = `select * from ev_users where username=?`\n```\n\n3. 执行 SQL 语句并根据结果判断用户名是否被占用：\n\n```js\ndb.query(sql, [userinfo.username], function (err, results) {\n  // 执行 SQL 语句失败\n  if (err) {\n    return res.send({ status: 1, message: err.message })\n  }\n  // 用户名被占用\n  if (results.length > 0) {\n    return res.send({ status: 1, message: \'用户名被占用，请更换其他用户名！\' })\n  }\n  // TODO: 用户名可用，继续后续流程...\n})\n```\n\n#### 2.3.3 对密码进行加密处理\n\n> 为了保证密码的安全性，不建议在数据库以 `明文` 的形式保存用户密码，推荐对密码进行 `加密存储`\n\n---\n\n在当前项目中，使用 `bcryptjs` 对用户密码进行加密，优点：\n\n- 加密之后的密码，**无法被逆向破解**\n- 同一明文密码多次加密，得到的**加密结果各不相同**，保证了安全性\n\n---\n\n1. 运行如下命令，安装指定版本的 `bcryptjs` ：\n\n```bash\nnpm i bcryptjs@2.4.3\n```\n\n2. 在 `/router_handler/user.js` 中，导入 `bcryptjs` ：\n\n```js\nconst bcrypt = require(\'bcryptjs\')\n```\n\n3. 在注册用户的处理函数中，确认用户名可用之后，调用 `bcrypt.hashSync(明文密码, 随机盐的长度)` 方法，对用户的密码进行加密处理：\n\n```js\n// 对用户的密码,进行 bcrype 加密，返回值是加密之后的密码字符串\nuserinfo.password = bcrypt.hashSync(userinfo.password, 10)\n```\n\n#### 2.3.4 插入新用户\n\n1. 定义插入用户的 SQL 语句：\n\n```js\nconst sql = \'insert into ev_users set ?\'\n```\n\n2. 调用 `db.query()` 执行 SQL 语句，插入新用户：\n\n```js\ndb.query(\n  sql,\n  { username: userinfo.username, password: userinfo.password },\n  function (err, results) {\n    // 执行 SQL 语句失败\n    if (err) return res.send({ status: 1, message: err.message })\n    // SQL 语句执行成功，但影响行数不为 1\n    if (results.affectedRows !== 1) {\n      return res.send({ status: 1, message: \'注册用户失败，请稍后再试！\' })\n    }\n    // 注册成功\n    res.send({ status: 0, message: \'注册成功！\' })\n  }\n)\n```\n\n### 2.4 优化 res.send() 代码\n\n> 在处理函数中，需要多次调用 `res.send()` 向客户端响应 `处理失败` 的结果，为了简化代码，可以手动封装一个 res.cc() 函数\n\n1. 在 `app.js` 中，所有路由之前，声明一个全局中间件，为 res 对象挂载一个 `res.cc()` 函数 ：\n\n```js\n// 响应数据的中间件\napp.use(function (req, res, next) {\n  // status = 0 为成功； status = 1 为失败； 默认将 status 的值设置为 1，方便处理失败的情况\n  res.cc = function (err, status = 1) {\n    res.send({\n      // 状态\n      status,\n      // 状态描述，判断 err 是 错误对象 还是 字符串\n      message: err instanceof Error ? err.message : err,\n    })\n  }\n  next()\n})\n```\n\n### 2.5 优化表单数据验证\n\n> 表单验证的原则：前端验证为辅，后端验证为主，后端**永远不要相信**前端提交过来的**任何内容**\n\n在实际开发中，前后端都需要对表单的数据进行合法性的验证，而且，**后端做为数据合法性验证的最后一个关口**，在拦截非法数据方面，起到了至关重要的作用。\n\n单纯的使用 `if...else...` 的形式对数据合法性进行验证，效率低下、出错率高、维护性差。因此，推荐使用**第三方数据验证模块**，来降低出错率、提高验证的效率与可维护性，**让后端程序员把更多的精力放在核心业务逻辑的处理上**。\n\n1. 安装 `@hapi/joi` 包，为表单中携带的每个数据项，定义验证规则：\n\n```bash\nnpm install @hapi/joi@17.1.0\n```\n\n2. 安装 `@escook/express-joi` 中间件，来实现自动对表单数据进行验证的功能：\n\n```bash\nnpm i @escook/express-joi\n```\n\n3. 新建 `/schema/user.js` 用户信息验证规则模块，并初始化代码如下：\n\n```js\nconst joi = require(\'@hapi/joi\')\n\n/**\n * string() 值必须是字符串\n * alphanum() 值只能是包含 a-zA-Z0-9 的字符串\n * min(length) 最小长度\n * max(length) 最大长度\n * required() 值是必填项，不能为 undefined\n * pattern(正则表达式) 值必须符合正则表达式的规则\n */\n\n// 用户名的验证规则\nconst username = joi.string().alphanum().min(1).max(10).required()\n// 密码的验证规则\nconst password = joi\n  .string()\n  .pattern(/^[\\S]{6,12}$/)\n  .required()\n\n// 注册和登录表单的验证规则对象\nexports.reg_login_schema = {\n  // 表示需要对 req.body 中的数据进行验证\n  body: {\n    username,\n    password,\n  },\n}\n```\n\n4. 修改 `/router/user.js` 中的代码如下：\n\n```js\nconst express = require(\'express\')\nconst router = express.Router()\n\n// 导入用户路由处理函数模块\nconst userHandler = require(\'../router_handler/user\')\n\n// 1. 导入验证表单数据的中间件\nconst expressJoi = require(\'@escook/express-joi\')\n// 2. 导入需要的验证规则对象\nconst { reg_login_schema } = require(\'../schema/user\')\n\n// 注册新用户\n// 3. 在注册新用户的路由中，声明局部中间件，对当前请求中携带的数据进行验证\n// 3.1 数据验证通过后，会把这次请求流转给后面的路由处理函数\n// 3.2 数据验证失败后，终止后续代码的执行，并抛出一个全局的 Error 错误，进入全局错误级别中间件中进行处理\nrouter.post(\'/reguser\', expressJoi(reg_login_schema), userHandler.regUser)\n// 登录\nrouter.post(\'/login\', userHandler.login)\n\nmodule.exports = router\n```\n\n5. 在 `app.js` 的全局错误级别中间件中，捕获验证失败的错误，并把验证失败的结果响应给客户端：\n\n```js\nconst joi = require(\'@hapi/joi\')\n\n// 错误中间件\napp.use(function (err, req, res, next) {\n  // 数据验证失败\n  if (err instanceof joi.ValidationError) return res.cc(err)\n  // 未知错误\n  res.cc(err)\n})\n```\n\n### 2.6 登录\n\n#### 2.6.0 实现步骤\n\n1. 检测表单数据是否合法\n2. 根据用户名查询用户的数据\n3. 判断用户输入的密码是否正确\n4. 生成 JWT 的 Token 字符串\n\n#### 2.6.1 检测登录表单的数据是否合法\n\n1. 将 `/router/user.js` 中 `登录` 的路由代码修改如下：\n\n```js\n// 登录的路由\nrouter.post(\'/login\', expressJoi(reg_login_schema), userHandler.login)\n```\n\n#### 2.6.2 根据用户名查询用户的数据\n\n1. 接收表单数据：\n\n```js\nconst userinfo = req.body\n```\n\n2. 定义 SQL 语句：\n\n```js\nconst sql = `select * from ev_users where username=?`\n```\n\n3. 执行 SQL 语句，查询用户的数据：\n\n```js\ndb.query(sql, userinfo.username, function (err, results) {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n  // 执行 SQL 语句成功，但是查询到数据条数不等于 1\n  if (results.length !== 1) return res.cc(\'登录失败！\')\n  // TODO：判断用户输入的登录密码是否和数据库中的密码一致\n})\n```\n\n#### 2.6.3 判断用户输入的密码是否正确\n\n> 核心实现思路：调用 `bcrypt.compareSync(用户提交的密码, 数据库中的密码)` 方法比较密码是否一致\n\n> 返回值是布尔值（true 一致、false 不一致）\n\n具体的实现代码如下：\n\n```js\n// 拿着用户输入的密码,和数据库中存储的密码进行对比\nconst compareResult = bcrypt.compareSync(userinfo.password, results[0].password)\n\n// 如果对比的结果等于 false, 则证明用户输入的密码错误\nif (!compareResult) {\n  return res.cc(\'登录失败！\')\n}\n\n// TODO：登录成功，生成 Token 字符串\n```\n\n#### 2.6.4 生成 JWT 的 Token 字符串\n\n> 核心注意点：在生成 Token 字符串的时候，一定要剔除 **密码** 和 **头像** 的值\n\n1. 通过 ES6 的高级语法，快速剔除 `密码` 和 `头像` 的值：\n\n```js\n// 剔除完毕之后，user 中只保留了用户的 id, username, nickname, email 这四个属性的值\nconst user = { ...results[0], password: \'\', user_pic: \'\' }\n```\n\n2. 运行如下的命令，安装生成 Token 字符串的包：\n\n```bash\nnpm i jsonwebtoken@8.5.1\n```\n\n3. 在 `/router_handler/user.js` 模块的头部区域，导入 `jsonwebtoken` 包：\n\n```js\n// 用这个包来生成 Token 字符串\nconst jwt = require(\'jsonwebtoken\')\n```\n\n4. 创建 `config.js` 文件，并向外共享 **加密** 和 **还原** Token 的 `jwtSecretKey` 字符串：\n\n```js\nmodule.exports = {\n  jwtSecretKey: \'itheima No1. ^_^\',\n}\n```\n\n5. 将用户信息对象加密成 Token 字符串：\n\n```js\n// 导入配置文件\nconst config = require(\'../config\')\n\n// 生成 Token 字符串\nconst tokenStr = jwt.sign(user, config.jwtSecretKey, {\n  expiresIn: \'10h\', // token 有效期为 10 个小时\n})\n```\n\n6. 将生成的 Token 字符串响应给客户端：\n\n```js\nres.send({\n  status: 0,\n  message: \'登录成功！\',\n  // 为了方便客户端使用 Token，在服务器端直接拼接上 Bearer 的前缀\n  token: \'Bearer \' + tokenStr,\n})\n```\n\n### 2.7 配置解析 Token 的中间件\n\n1. 运行如下的命令，安装解析 Token 的中间件：\n\n```js\nnpm i express-jwt@5.3.3\n```\n\n2. 在 `app.js` 中注册路由之前，配置解析 Token 的中间件：\n\n```js\n// 导入配置文件\nconst config = require(\'./config\')\n\n// 解析 token 的中间件\nconst expressJWT = require(\'express-jwt\')\n\n// 使用 .unless({ path: [/^\\/api\\//] }) 指定哪些接口不需要进行 Token 的身份认证\napp.use(\n  expressJWT({ secret: config.jwtSecretKey }).unless({ path: [/^\\/api\\//] })\n)\n```\n\n3. 在 `app.js` 中的 `错误级别中间件` 里面，捕获并处理 Token 认证失败后的错误：\n\n```js\n// 错误中间件\napp.use(function (err, req, res, next) {\n  // 省略其它代码...\n\n  // 捕获身份认证失败的错误\n  if (err.name === \'UnauthorizedError\') return res.cc(\'身份认证失败！\')\n\n  // 未知错误...\n})\n```\n\n## 3. 个人中心\n\n### 3.1 获取用户的基本信息\n\n#### 3.1.0 实现步骤\n\n1. 初始化 **路由** 模块\n2. 初始化 **路由处理函数** 模块\n3. 获取用户的基本信息\n\n#### 3.1.1 初始化路由模块\n\n1. 创建 `/router/userinfo.js` 路由模块，并初始化如下的代码结构：\n\n```js\n// 导入 express\nconst express = require(\'express\')\n// 创建路由对象\nconst router = express.Router()\n\n// 获取用户的基本信息\nrouter.get(\'/userinfo\', (req, res) => {\n  res.send(\'ok\')\n})\n\n// 向外共享路由对象\nmodule.exports = router\n```\n\n2. 在 `app.js` 中导入并使用个人中心的路由模块：\n\n```js\n// 导入并使用用户信息路由模块\nconst userinfoRouter = require(\'./router/userinfo\')\n// 注意：以 /my 开头的接口，都是有权限的接口，需要进行 Token 身份认证\napp.use(\'/my\', userinfoRouter)\n```\n\n#### 3.1.2 初始化路由处理函数模块\n\n1. 创建 `/router_handler/userinfo.js` 路由处理函数模块，并初始化如下的代码结构：\n\n```js\n// 获取用户基本信息的处理函数\nexports.getUserInfo = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n2. 修改 `/router/userinfo.js` 中的代码如下：\n\n```js\nconst express = require(\'express\')\nconst router = express.Router()\n\n// 导入用户信息的处理函数模块\nconst userinfo_handler = require(\'../router_handler/userinfo\')\n\n// 获取用户的基本信息\nrouter.get(\'/userinfo\', userinfo_handler.getUserInfo)\n\nmodule.exports = router\n```\n\n#### 3.1.3 获取用户的基本信息\n\n1. 在 `/router_handler/userinfo.js` 头部导入数据库操作模块：\n\n```js\n// 导入数据库操作模块\nconst db = require(\'../db/index\')\n```\n\n2. 定义 SQL 语句：\n\n```js\n// 根据用户的 id，查询用户的基本信息\n// 注意：为了防止用户的密码泄露，需要排除 password 字段\nconst sql = `select id, username, nickname, email, user_pic from ev_users where id=?`\n```\n\n3. 调用 `db.query()` 执行 SQL 语句：\n\n```js\n// 注意：req 对象上的 user 属性，是 Token 解析成功，express-jwt 中间件帮我们挂载上去的\ndb.query(sql, req.user.id, (err, results) => {\n  // 1. 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 2. 执行 SQL 语句成功，但是查询到的数据条数不等于 1\n  if (results.length !== 1) return res.cc(\'获取用户信息失败！\')\n\n  // 3. 将用户信息响应给客户端\n  res.send({\n    status: 0,\n    message: \'获取用户基本信息成功！\',\n    data: results[0],\n  })\n})\n```\n\n### 3.2 更新用户的基本信息\n\n#### 3.2.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 实现更新用户基本信息的功能\n\n#### 3.2.1 定义路由和处理函数\n\n1. 在 `/router/userinfo.js` 模块中，新增 `更新用户基本信息` 的路由：\n\n```js\n// 更新用户的基本信息\nrouter.post(\'/userinfo\', userinfo_handler.updateUserInfo)\n```\n\n2. 在 `/router_handler/userinfo.js` 模块中，定义并向外共享 `更新用户基本信息` 的路由处理函数：\n\n```js\n// 更新用户基本信息的处理函数\nexports.updateUserInfo = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 3.2.2 验证表单数据\n\n1. 在 `/schema/user.js` 验证规则模块中，定义 `id`，`nickname`，`email` 的验证规则如下：\n\n```js\n// 定义 id, nickname, emial 的验证规则\nconst id = joi.number().integer().min(1).required()\nconst nickname = joi.string().required()\nconst email = joi.string().email().required()\n```\n\n2. 并使用 `exports` 向外共享如下的 `验证规则对象`：\n\n```js\n// 验证规则对象 - 更新用户基本信息\nexports.update_userinfo_schema = {\n  body: {\n    id,\n    nickname,\n    email,\n  },\n}\n```\n\n3. 在 `/router/userinfo.js` 模块中，导入验证数据合法性的中间件：\n\n```js\n// 导入验证数据合法性的中间件\nconst expressJoi = require(\'@escook/express-joi\')\n```\n\n4. 在 `/router/userinfo.js` 模块中，导入需要的验证规则对象：\n\n```js\n// 导入需要的验证规则对象\nconst { update_userinfo_schema } = require(\'../schema/user\')\n```\n\n5. 在 `/router/userinfo.js` 模块中，修改 `更新用户的基本信息` 的路由如下：\n\n```js\n// 更新用户的基本信息\nrouter.post(\'/userinfo\', expressJoi(update_userinfo_schema), userinfo_handler.updateUserInfo)\n```\n\n#### 3.2.3 实现更新用户基本信息的功能\n\n1. 定义待执行的 SQL 语句：\n\n```js\nconst sql = `update ev_users set ? where id=?`\n```\n\n2. 调用 `db.query()` 执行 SQL 语句并传参：\n\n```js\ndb.query(sql, [req.body, req.body.id], (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 执行 SQL 语句成功，但影响行数不为 1\n  if (results.affectedRows !== 1) return res.cc(\'修改用户基本信息失败！\')\n\n  // 修改用户信息成功\n  return res.cc(\'修改用户基本信息成功！\', 0)\n})\n```\n\n### 3.3 重置密码\n\n#### 3.3.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 实现重置密码的功能\n\n#### 3.3.1 定义路由和处理函数\n\n1. 在 `/router/userinfo.js` 模块中，新增 `重置密码` 的路由：\n\n```js\n// 重置密码的路由\nrouter.post(\'/updatepwd\', userinfo_handler.updatePassword)\n```\n\n2. 在 `/router_handler/userinfo.js` 模块中，定义并向外共享 `重置密码` 的路由处理函数：\n\n```js\n// 重置密码的处理函数\nexports.updatePassword = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 3.3.2 验证表单数据\n\n> 核心验证思路：旧密码与新密码，必须符合密码的验证规则，并且新密码不能与旧密码一致！\n\n1. 在 `/schema/user.js` 模块中，使用 `exports` 向外共享如下的 `验证规则对象`：\n\n```js\n// 验证规则对象 - 重置密码\nexports.update_password_schema = {\n  body: {\n    // 使用 password 这个规则，验证 req.body.oldPwd 的值\n    oldPwd: password,\n    // 使用 joi.not(joi.ref(\'oldPwd\')).concat(password) 规则，验证 req.body.newPwd 的值\n    // 解读：\n    // 1. joi.ref(\'oldPwd\') 表示 newPwd 的值必须和 oldPwd 的值保持一致\n    // 2. joi.not(joi.ref(\'oldPwd\')) 表示 newPwd 的值不能等于 oldPwd 的值\n    // 3. .concat() 用于合并 joi.not(joi.ref(\'oldPwd\')) 和 password 这两条验证规则\n    newPwd: joi.not(joi.ref(\'oldPwd\')).concat(password),\n  },\n}\n```\n\n2. 在 `/router/userinfo.js` 模块中，导入需要的验证规则对象：\n\n```js\n// 导入需要的验证规则对象\nconst { update_userinfo_schema, update_password_schema } = require(\'../schema/user\')\n```\n\n3. 并在 `重置密码的路由` 中，使用 `update_password_schema` 规则验证表单的数据，示例代码如下：\n\n```js\nrouter.post(\'/updatepwd\', expressJoi(update_password_schema), userinfo_handler.updatePassword)\n```\n\n#### 3.3.3 实现重置密码的功能\n\n1. 根据 `id` 查询用户是否存在：\n\n```js\n// 定义根据 id 查询用户数据的 SQL 语句\nconst sql = `select * from ev_users where id=?`\n\n// 执行 SQL 语句查询用户是否存在\ndb.query(sql, req.user.id, (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 检查指定 id 的用户是否存在\n  if (results.length !== 1) return res.cc(\'用户不存在！\')\n\n  // TODO：判断提交的旧密码是否正确\n})\n```\n\n2. 判断提交的 **旧密码** 是否正确：\n\n```js\n// 在头部区域导入 bcryptjs 后，\n// 即可使用 bcrypt.compareSync(提交的密码，数据库中的密码) 方法验证密码是否正确\n// compareSync() 函数的返回值为布尔值，true 表示密码正确，false 表示密码错误\nconst bcrypt = require(\'bcryptjs\')\n\n// 判断提交的旧密码是否正确\nconst compareResult = bcrypt.compareSync(req.body.oldPwd, results[0].password)\nif (!compareResult) return res.cc(\'原密码错误！\')\n```\n\n3. 对新密码进行 `bcrypt` 加密之后，更新到数据库中：\n\n```js\n// 定义更新用户密码的 SQL 语句\nconst sql = `update ev_users set password=? where id=?`\n\n// 对新密码进行 bcrypt 加密处理\nconst newPwd = bcrypt.hashSync(req.body.newPwd, 10)\n\n// 执行 SQL 语句，根据 id 更新用户的密码\ndb.query(sql, [newPwd, req.user.id], (err, results) => {\n  // SQL 语句执行失败\n  if (err) return res.cc(err)\n\n  // SQL 语句执行成功，但是影响行数不等于 1\n  if (results.affectedRows !== 1) return res.cc(\'更新密码失败！\')\n\n  // 更新密码成功\n  res.cc(\'更新密码成功！\', 0)\n})\n```\n\n### 3.4 更新用户头像\n\n#### 3.4.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 实现更新用户头像的功能\n\n#### 3.4.1 定义路由和处理函数\n\n1. 在 `/router/userinfo.js` 模块中，新增 `更新用户头像` 的路由：\n\n```js\n// 更新用户头像的路由\nrouter.post(\'/update/avatar\', userinfo_handler.updateAvatar)\n```\n\n2. 在 `/router_handler/userinfo.js` 模块中，定义并向外共享 `更新用户头像` 的路由处理函数：\n\n```js\n// 更新用户头像的处理函数\nexports.updateAvatar = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 3.4.2 验证表单数据\n\n1. 在 `/schema/user.js` 验证规则模块中，定义 `avatar` 的验证规则如下：\n\n```js\n// dataUri() 指的是如下格式的字符串数据：\n// data:image/png;base64,VE9PTUFOWVNFQ1JFVFM=\nconst avatar = joi.string().dataUri().required()\n```\n\n2. 并使用 `exports` 向外共享如下的 `验证规则对象`：\n\n```js\n// 验证规则对象 - 更新头像\nexports.update_avatar_schema = {\n  body: {\n    avatar,\n  },\n}\n```\n\n3. 在 `/router/userinfo.js` 模块中，导入需要的验证规则对象：\n\n```js\nconst { update_avatar_schema } = require(\'../schema/user\')\n```\n\n4. 在 `/router/userinfo.js` 模块中，修改 `更新用户头像` 的路由如下：\n\n```js\nrouter.post(\'/update/avatar\', expressJoi(update_avatar_schema), userinfo_handler.updateAvatar)\n```\n\n#### 3.4.3 实现更新用户头像的功能\n\n1. 定义更新用户头像的 SQL 语句：\n\n```js\nconst sql = \'update ev_users set user_pic=? where id=?\'\n```\n\n2. 调用 `db.query()` 执行 SQL 语句，更新对应用户的头像：\n\n```js\ndb.query(sql, [req.body.avatar, req.user.id], (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 执行 SQL 语句成功，但是影响行数不等于 1\n  if (results.affectedRows !== 1) return res.cc(\'更新头像失败！\')\n\n  // 更新用户头像成功\n  return res.cc(\'更新头像成功！\', 0)\n})\n```\n\n\n## 4. 文章分类管理\n\n### 4.1 新建 ev_article_cate 表\n\n#### 4.1.1 创建表结构\n\n![文章分类表结构](https://gitee.com/qarabala/api_server/raw/master/mds/images/2.jpeg)\n\n#### 4.1.2 新增两条初始数据\n\n![文章分类表结构](https://gitee.com/qarabala/api_server/raw/master/mds/images/3.jpeg)\n\n### 4.2 获取文章分类列表\n\n#### 4.2.0 实现步骤\n\n1. 初始化路由模块\n2. 初始化路由处理函数模块\n3. 获取文章分类列表数据\n\n#### 4.2.1 初始化路由模块\n\n1. 创建 `/router/artcate.js` 路由模块，并初始化如下的代码结构：\n\n```js\n// 导入 express\nconst express = require(\'express\')\n// 创建路由对象\nconst router = express.Router()\n\n// 获取文章分类的列表数据\nrouter.get(\'/cates\', (req, res) => {\n  res.send(\'ok\')\n})\n\n// 向外共享路由对象\nmodule.exports = router\n```\n\n2. 在 `app.js` 中导入并使用文章分类的路由模块：\n\n```js\n// 导入并使用文章分类路由模块\nconst artCateRouter = require(\'./router/artcate\')\n// 为文章分类的路由挂载统一的访问前缀 /my/article\napp.use(\'/my/article\', artCateRouter)\n```\n\n#### 4.2.2 初始化路由处理函数模块\n\n1. 创建 `/router_handler/artcate.js` 路由处理函数模块，并初始化如下的代码结构：\n\n```js\n// 获取文章分类列表数据的处理函数\nexports.getArticleCates = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n2. 修改 `/router/artcate.js` 中的代码如下：\n\n```js\nconst express = require(\'express\')\nconst router = express.Router()\n\n// 导入文章分类的路由处理函数模块\nconst artcate_handler = require(\'../router_handler/artcate\')\n\n// 获取文章分类的列表数据\nrouter.get(\'/cates\', artcate_handler.getArticleCates)\n\nmodule.exports = router\n```\n\n#### 4.2.3 获取文章分类列表数据\n\n1. 在 `/router_handler/artcate.js` 头部导入数据库操作模块：\n\n```js\n// 导入数据库操作模块\nconst db = require(\'../db/index\')\n```\n\n2. 定义 SQL 语句：\n\n```js\n// 根据分类的状态，获取所有未被删除的分类列表数据\n// is_delete 为 0 表示没有被 标记为删除 的数据\nconst sql = \'select * from ev_article_cate where is_delete=0 order by id asc\'\n```\n\n3. 调用 `db.query()` 执行 SQL 语句：\n\n```js\ndb.query(sql, (err, results) => {\n  // 1. 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 2. 执行 SQL 语句成功\n  res.send({\n    status: 0,\n    message: \'获取文章分类列表成功！\',\n    data: results,\n  })\n})\n```\n\n### 4.3 新增文章分类\n\n#### 4.3.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 查询 `分类名称` 与 `分类别名` 是否被占用\n4. 实现新增文章分类的功能\n\n#### 4.3.1 定义路由和处理函数\n\n1. 在 `/router/artcate.js` 模块中，添加 `新增文章分类` 的路由：\n\n```js\n// 新增文章分类的路由\nrouter.post(\'/addcates\', artcate_handler.addArticleCates)\n```\n\n2. 在 `/router_handler/artcate.js` 模块中，定义并向外共享 `新增文章分类` 的路由处理函数：\n\n```js\n// 新增文章分类的处理函数\nexports.addArticleCates = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 4.3.2 验证表单数据\n\n1. 创建 `/schema/artcate.js` 文章分类数据验证模块，并定义如下的验证规则：\n\n```js\n// 导入定义验证规则的模块\nconst joi = require(\'@hapi/joi\')\n\n// 定义 分类名称 和 分类别名 的校验规则\nconst name = joi.string().required()\nconst alias = joi.string().alphanum().required()\n\n// 校验规则对象 - 添加分类\nexports.add_cate_schema = {\n  body: {\n    name,\n    alias,\n  },\n}\n```\n\n2. 在 `/router/artcate.js` 模块中，使用 `add_cate_schema` 对数据进行验证：\n\n```js\n// 导入验证数据的中间件\nconst expressJoi = require(\'@escook/express-joi\')\n// 导入文章分类的验证模块\nconst { add_cate_schema } = require(\'../schema/artcate\')\n\n// 新增文章分类的路由\nrouter.post(\n  \'/addcates\',\n  expressJoi(add_cate_schema),\n  artcate_handler.addArticleCates\n)\n```\n\n#### 4.3.3 查询分类名称与别名是否被占用\n\n1. 定义查重的 SQL 语句：\n\n```js\n// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句\nconst sql = `select * from ev_article_cate where name=? or alias=?`\n```\n\n2. 调用 `db.query()` 执行查重的操作：\n\n```js\n// 执行查重操作\ndb.query(sql, [req.body.name, req.body.alias], (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 分类名称 和 分类别名 都被占用\n  if (results.length === 2)\n    return res.cc(\'分类名称与别名被占用，请更换后重试！\')\n  if (\n    results.length === 1 &&\n    results[0].name === req.body.name &&\n    results[0].alias === req.body.alias\n  )\n    return res.cc(\'分类名称与别名被占用，请更换后重试！\')\n  // 分类名称 或 分类别名 被占用\n  if (results.length === 1 && results[0].name === req.body.name)\n    return res.cc(\'分类名称被占用，请更换后重试！\')\n  if (results.length === 1 && results[0].alias === req.body.alias)\n    return res.cc(\'分类别名被占用，请更换后重试！\')\n\n  // TODO：新增文章分类\n})\n```\n\n#### 4.3.4 实现新增文章分类的功能\n\n1. 定义新增文章分类的 SQL 语句：\n\n```js\nconst sql = `insert into ev_article_cate set ?`\n```\n\n2. 调用 `db.query()` 执行新增文章分类的 SQL 语句：\n\n```js\ndb.query(sql, req.body, (err, results) => {\n  // SQL 语句执行失败\n  if (err) return res.cc(err)\n\n  // SQL 语句执行成功，但是影响行数不等于 1\n  if (results.affectedRows !== 1) return res.cc(\'新增文章分类失败！\')\n\n  // 新增文章分类成功\n  res.cc(\'新增文章分类成功！\', 0)\n})\n```\n\n### 4.4 根据 Id 删除文章分类\n\n#### 4.4.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 实现删除文章分类的功能\n\n#### 4.4.1 定义路由和处理函数\n\n1. 在 `/router/artcate.js` 模块中，添加 `删除文章分类` 的路由：\n\n```js\n// 删除文章分类的路由\nrouter.get(\'/deletecate/:id\', artcate_handler.deleteCateById)\n```\n\n2. 在 `/router_handler/artcate.js` 模块中，定义并向外共享 `删除文章分类` 的路由处理函数：\n\n```js\n// 删除文章分类的处理函数\nexports.deleteCateById = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 4.4.2 验证表单数据\n\n1. 在 `/schema/artcate.js` 验证规则模块中，定义 id 的验证规则如下：\n\n```js\n// 定义 分类Id 的校验规则\nconst id = joi.number().integer().min(1).required()\n```\n\n2. 并使用 `exports` 向外共享如下的 `验证规则对象`：\n\n```js\n// 校验规则对象 - 删除分类\nexports.delete_cate_schema = {\n  params: {\n    id,\n  },\n}\n```\n\n3. 在 `/router/artcate.js` 模块中，导入需要的验证规则对象，并在路由中使用：\n\n```js\n// 导入删除分类的验证规则对象\nconst { delete_cate_schema } = require(\'../schema/artcate\')\n\n// 删除文章分类的路由\nrouter.get(\n  \'/deletecate/:id\',\n  expressJoi(delete_cate_schema),\n  artcate_handler.deleteCateById\n)\n```\n\n#### 4.4.3 实现删除文章分类的功能\n\n1. 定义删除文章分类的 SQL 语句：\n\n```js\nconst sql = `update ev_article_cate set is_delete=1 where id=?`\n```\n\n2. 调用 `db.query()` 执行删除文章分类的 SQL 语句：\n\n```js\ndb.query(sql, req.params.id, (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // SQL 语句执行成功，但是影响行数不等于 1\n  if (results.affectedRows !== 1) return res.cc(\'删除文章分类失败！\')\n\n  // 删除文章分类成功\n  res.cc(\'删除文章分类成功！\', 0)\n})\n```\n\n### 4.5 根据 Id 获取文章分类数据\n\n#### 4.5.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 实现获取文章分类的功能\n\n#### 4.5.1 定义路由和处理函数\n\n1. 在 `/router/artcate.js` 模块中，添加 `根据 Id 获取文章分类` 的路由：\n\n```js\nrouter.get(\'/cates/:id\', artcate_handler.getArtCateById)\n```\n\n2. 在 `/router_handler/artcate.js` 模块中，定义并向外共享 `根据 Id 获取文章分类` 的路由处理函数：\n\n```js\n// 根据 Id 获取文章分类的处理函数\nexports.getArtCateById = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 4.5.2 验证表单数据\n\n1. 在 `/schema/artcate.js` 验证规则模块中，使用 `exports` 向外共享如下的 `验证规则对象`：\n\n```js\n// 校验规则对象 - 根据 Id 获取分类\nexports.get_cate_schema = {\n  params: {\n    id,\n  },\n}\n```\n\n2. 在 `/router/artcate.js` 模块中，导入需要的验证规则对象，并在路由中使用：\n\n```js\n// 导入根据 Id 获取分类的验证规则对象\nconst { get_cate_schema } = require(\'../schema/artcate\')\n\n// 根据 Id 获取文章分类的路由\nrouter.get(\n  \'/cates/:id\',\n  expressJoi(get_cate_schema),\n  artcate_handler.getArticleById\n)\n```\n\n#### 4.5.3 实现获取文章分类的功能\n\n1. 定义根据 Id 获取文章分类的 SQL 语句：\n\n```js\nconst sql = `select * from ev_article_cate where id=?`\n```\n\n2. 调用 `db.query()` 执行 SQL 语句：\n\n```js\ndb.query(sql, req.params.id, (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // SQL 语句执行成功，但是没有查询到任何数据\n  if (results.length !== 1) return res.cc(\'获取文章分类数据失败！\')\n\n  // 把数据响应给客户端\n  res.send({\n    status: 0,\n    message: \'获取文章分类数据成功！\',\n    data: results[0],\n  })\n})\n```\n\n### 4.6 根据 Id 更新文章分类数据\n\n#### 4.6.0 实现步骤\n\n1. 定义路由和处理函数\n2. 验证表单数据\n3. 查询 `分类名称` 与 `分类别名` 是否被占用\n4. 实现更新文章分类的功能\n\n#### 4.6.1 定义路由和处理函数\n\n1. 在 `/router/artcate.js` 模块中，添加 `更新文章分类` 的路由：\n\n```js\n// 更新文章分类的路由\nrouter.post(\'/updatecate\', artcate_handler.updateCateById)\n```\n\n2. 在 `/router_handler/artcate.js` 模块中，定义并向外共享 `更新文章分类` 的路由处理函数：\n\n```js\n// 更新文章分类的处理函数\nexports.updateCateById = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n#### 4.6.2 验证表单数据\n\n1. 在 `/schema/artcate.js` 验证规则模块中，使用 `exports` 向外共享如下的 `验证规则对象`：\n\n```js\n// 校验规则对象 - 更新分类\nexports.update_cate_schema = {\n  body: {\n    Id: id,\n    name,\n    alias,\n  },\n}\n```\n\n2. 在 `/router/artcate.js` 模块中，导入需要的验证规则对象，并在路由中使用：\n\n```js\n// 导入更新文章分类的验证规则对象\nconst { update_cate_schema } = require(\'../schema/artcate\')\n\n// 更新文章分类的路由\nrouter.post(\n  \'/updatecate\',\n  expressJoi(update_cate_schema),\n  artcate_handler.updateCateById\n)\n```\n\n#### 4.5.4 查询分类名称与别名是否被占用\n\n1. 定义查重的 SQL 语句：\n\n```js\n// 定义查询 分类名称 与 分类别名 是否被占用的 SQL 语句\nconst sql = `select * from ev_article_cate where Id<>? and (name=? or alias=?)`\n```\n\n2. 调用 `db.query()` 执行查重的操作：\n\n```js\n// 执行查重操作\ndb.query(sql, [req.body.Id, req.body.name, req.body.alias], (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 分类名称 和 分类别名 都被占用\n  if (results.length === 2)\n    return res.cc(\'分类名称与别名被占用，请更换后重试！\')\n  if (\n    results.length === 1 &&\n    results[0].name === req.body.name &&\n    results[0].alias === req.body.alias\n  )\n    return res.cc(\'分类名称与别名被占用，请更换后重试！\')\n  // 分类名称 或 分类别名 被占用\n  if (results.length === 1 && results[0].name === req.body.name)\n    return res.cc(\'分类名称被占用，请更换后重试！\')\n  if (results.length === 1 && results[0].alias === req.body.alias)\n    return res.cc(\'分类别名被占用，请更换后重试！\')\n\n  // TODO：更新文章分类\n})\n```\n\n#### 4.5.5 实现更新文章分类的功能\n\n1. 定义更新文章分类的 SQL 语句：\n\n```js\nconst sql = `update ev_article_cate set ? where Id=?`\n```\n\n2. 调用 `db.query()` 执行 SQL 语句：\n\n```js\ndb.query(sql, [req.body, req.body.Id], (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // SQL 语句执行成功，但是影响行数不等于 1\n  if (results.affectedRows !== 1) return res.cc(\'更新文章分类失败！\')\n\n  // 更新文章分类成功\n  res.cc(\'更新文章分类成功！\', 0)\n})\n```\n\n\n## 5. 文章管理\n\n### 5.1 新建 ev_articles 表\n\n![ev_articles表结构](https://gitee.com/qarabala/api_server/raw/master/mds/images/4.jpeg)\n\n### 5.2 发布新文章\n\n#### 5.2.0 实现步骤\n\n1. 初始化路由模块\n2. 初始化路由处理函数模块\n3. 使用 multer 解析表单数据\n4. 验证表单数据\n5. 实现发布文章的功能\n\n#### 5.2.1 初始化路由模块\n\n1. 创建 `/router/article.js` 路由模块，并初始化如下的代码结构：\n\n```js\n// 导入 express\nconst express = require(\'express\')\n// 创建路由对象\nconst router = express.Router()\n\n// 发布新文章\nrouter.post(\'/add\', (req, res) => {\n  res.send(\'ok\')\n})\n\n// 向外共享路由对象\nmodule.exports = router\n```\n\n2. 在 `app.js` 中导入并使用文章的路由模块：\n\n```js\n// 导入并使用文章路由模块\nconst articleRouter = require(\'./router/article\')\n// 为文章的路由挂载统一的访问前缀 /my/article\napp.use(\'/my/article\', articleRouter)\n```\n\n#### 5.2.2 初始化路由处理函数模块\n\n1. 创建 `/router_handler/article.js` 路由处理函数模块，并初始化如下的代码结构：\n\n```js\n// 发布新文章的处理函数\nexports.addArticle = (req, res) => {\n  res.send(\'ok\')\n}\n```\n\n2. 修改 `/router/article.js` 中的代码如下：\n\n```js\nconst express = require(\'express\')\nconst router = express.Router()\n\n// 导入文章的路由处理函数模块\nconst article_handler = require(\'../router_handler/article\')\n\n// 发布新文章\nrouter.post(\'/add\', article_handler.addArticle)\n\nmodule.exports = router\n```\n\n#### 5.2.3 使用 multer 解析表单数据\n\n> 注意：使用 `express.urlencoded()` 中间件无法解析 `multipart/form-data` 格式的请求体数据。\n\n> 当前项目，推荐使用 multer 来解析 `multipart/form-data` 格式的表单数据。https://www.npmjs.com/package/multer\n\n1. 运行如下的终端命令，在项目中安装 `multer`：\n\n```bash\nnpm i multer@1.4.2\n```\n\n2. 在 `/router/article.js` 模块中导入并配置 `multer`：\n\n```js\n// 导入解析 formdata 格式表单数据的包\nconst multer = require(\'multer\')\n// 导入处理路径的核心模块\nconst path = require(\'path\')\n\n// 创建 multer 的实例对象，通过 dest 属性指定文件的存放路径\nconst upload = multer({ dest: path.join(__dirname, \'../uploads\') })\n```\n\n3. 修改 `发布新文章` 的路由如下：\n\n```js\n// 发布新文章的路由\n// upload.single() 是一个局部生效的中间件，用来解析 FormData 格式的表单数据\n// 将文件类型的数据，解析并挂载到 req.file 属性中\n// 将文本类型的数据，解析并挂载到 req.body 属性中\nrouter.post(\'/add\', upload.single(\'cover_img\'), article_handler.addArticle)\n```\n\n4. 在 `/router_handler/article.js` 模块中的 `addArticle` 处理函数中，将 `multer` 解析出来的数据进行打印：\n\n```js\n// 发布新文章的处理函数\nexports.addArticle = (req, res) => {\n  console.log(req.body) // 文本类型的数据\n  console.log(\'--------分割线----------\')\n  console.log(req.file) // 文件类型的数据\n\n  res.send(\'ok\')\n})\n```\n\n#### 5.2.4 验证表单数据\n\n> 实现思路：通过 express-joi **自动验证** req.body 中的文本数据；通过 if 判断**手动验证** req.file 中的文件数据；\n\n1. 创建 `/schema/article.js` 验证规则模块，并初始化如下的代码结构：\n\n```js\n// 导入定义验证规则的模块\nconst joi = require(\'@hapi/joi\')\n\n// 定义 标题、分类Id、内容、发布状态 的验证规则\nconst title = joi.string().required()\nconst cate_id = joi.number().integer().min(1).required()\nconst content = joi.string().required().allow(\'\')\nconst state = joi.string().valid(\'已发布\', \'草稿\').required()\n\n// 验证规则对象 - 发布文章\nexports.add_article_schema = {\n  body: {\n    title,\n    cate_id,\n    content,\n    state,\n  },\n}\n```\n\n2. 在 `/router/article.js` 模块中，导入需要的验证规则对象，并在路由中使用：\n\n```js\n// 导入验证数据的中间件\nconst expressJoi = require(\'@escook/express-joi\')\n// 导入文章的验证模块\nconst { add_article_schema } = require(\'../schema/article\')\n\n// 发布新文章的路由\n// 注意：在当前的路由中，先后使用了两个中间件：\n//       先使用 multer 解析表单数据\n//       再使用 expressJoi 对解析的表单数据进行验证\nrouter.post(\n  \'/add\',\n  upload.single(\'cover_img\'),\n  expressJoi(add_article_schema),\n  article_handler.addArticle\n)\n```\n\n3. 在 `/router_handler/article.js` 模块中的 `addArticle` 处理函数中，通过 `if` 判断客户端是否提交了 `封面图片`：\n\n```js\n// 发布新文章的处理函数\nexports.addArticle = (req, res) => {\n    // 手动判断是否上传了文章封面\n  if (!req.file || req.file.fieldname !== \'cover_img\') return res.cc(\'文章封面是必选参数！\')\n\n  // TODO：表单数据合法，继续后面的处理流程...\n})\n```\n\n#### 5.2.5 实现发布文章的功能\n\n1. 整理要插入数据库的文章信息对象：\n\n```js\n// 导入处理路径的 path 核心模块\nconst path = require(\'path\')\n\nconst articleInfo = {\n  // 标题、内容、状态、所属的分类Id\n  ...req.body,\n  // 文章封面在服务器端的存放路径\n  cover_img: path.join(\'/uploads\', req.file.filename),\n  // 文章发布时间\n  pub_date: new Date(),\n  // 文章作者的Id\n  author_id: req.user.id,\n}\n```\n\n2. 定义发布文章的 SQL 语句：\n\n```js\nconst sql = `insert into ev_articles set ?`\n```\n\n3. 调用 `db.query()` 执行发布文章的 SQL 语句：\n\n```js\n// 导入数据库操作模块\nconst db = require(\'../db/index\')\n\n// 执行 SQL 语句\ndb.query(sql, articleInfo, (err, results) => {\n  // 执行 SQL 语句失败\n  if (err) return res.cc(err)\n\n  // 执行 SQL 语句成功，但是影响行数不等于 1\n  if (results.affectedRows !== 1) return res.cc(\'发布文章失败！\')\n\n  // 发布文章成功\n  res.cc(\'发布文章成功\', 0)\n})\n```\n\n4. 在 `app.js` 中，使用 `express.static()` 中间件，将 `uploads` 目录中的图片托管为静态资源：\n\n```js\n// 托管静态资源文件\napp.use(\'/uploads\', express.static(\'./uploads\'))\n```', NULL, 1, NULL, NULL, '2024-03-18 00:02:59', '2024-03-18 00:21:28', 10, 10);
INSERT INTO `articles` VALUES (2, 'TypeScript文档', 11, '[55, 58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/35d5a1d2-6ccc-4452-b747-ac0dadeeb67b.jpeg', 'TypeScript全套教程', '# TypeScript文档\n\n[TS 官方文档](https://www.typescriptlang.org/)\n\n# TypeScript\n\n- TypeScript 介绍\n- TypeScript 初体验\n- TypeScript 常用类型\n- TypeScript 高级类型\n- TypeScript 类型声明文件\n- 在 React 中使用 TypeScript\n\n## TypeScript 介绍\n\n- [TS 官方文档](https://www.typescriptlang.org/)\n- [TS 中文参考 - 不再维护](https://www.tslang.cn/)\n\n![TS Logo](https://gitee.com/qarabala/docsify/raw/typescript/typescript/typescript/images/TS_logo.png)\n\n1. TypeScript 是什么\n2. TypeScript 为什么要为 JS 添加类型支持?\n3. TypeScript 相比 JS 的优势\n\n### TypeScript 是什么\n\n- **`TypeScript` 简称：TS，是 JavaScript 的超集**，简单来说就是：JS 有的 TS 都有\n\n![TS是JS的超集](https://qarabala.gitee.io/docsify/typescript/images/TS%E6%98%AFJS%E7%9A%84%E8%B6%85%E9%9B%86.png)\n\n- TypeScript = `Type` + JavaScript（在 JS 基础之上，**为 JS 添加了类型支持**）\n- TypeScript 是*微软*开发的开源编程语言，可以在任何运行 JavaScript 的地方运行\n\n![TS 和 JS 的对比](https://qarabala.gitee.io/docsify/typescript/images/TSvsJS.png)\n\n### TypeScript 为什么要为 JS 添加类型支持?\n\n- 背景：JS 的类型系统存在“先天缺陷”，JS 代码中绝大部分错误都是类型错误（Uncaught TypeError） \n- 这些经常出现的错误，导致了在使用 JS 进行项目开发时，增加了找 Bug、改 Bug 的时间，严重影响开发效率\n\n为什么会这样？\n\n- 从编程语言的动静来区分，**TypeScript 属于静态类型的编程语言**，**JavaScript 属于动态类型的编程语言**\n  - 静态类型：**编译**期做类型检查\n  - 动态类型：**执行**期做类型检查\n- 代码编译和代码执行的顺序：1 编译 2 执行\n\n- 对于 JS 来说：需要等到代码真正去执行的时候才能发现错误（晚）\n- 对于 TS 来说：在代码编译的时候（代码执行前）就可以发现错误（早）\n\n并且，配合 VSCode 等开发工具，TS 可以提前到**在编写代码的同时就发现代码中的错误**，减少找 Bug、改 Bug 时间  \n\n对比：\n\n- 使用 JS：\n  1. 在 VSCode 里面写代码\n  2. 在浏览器中运行代码 --> 运行时，才会发现错误【晚】\n- 使用 TS：\n  1. 在 VSCode 里面写代码 --> 写代码的同时，就会发现错误【早】\n  2. 在浏览器中运行代码\n\n### TypeScript 相比 JS 的优势\n\n1. **更早（写代码的同时）发现错误**，减少找 Bug、改 Bug 时间，提升开发效率\n2. 程序中任何位置的代码都有**代码提示**，随时随地的安全感，增强了开发体验\n3. 强大的类型系统提升了代码的可维护性，使得**重构代码更加容易**\n4. 支持最新的 ECMAScript 语法，**优先体验最新的语法，让你走在前端技术的最前沿** \n5. TS 类型推断机制，不需要在代码中的每个地方都显示标注类型，让你在享受优势的同时，尽量降低了学习负担\n\n除此之外，Vue 3 源码使用 TS 重写、Angular 默认支持 TS、React 与 TS 完美配合，TypeScript 已成为大中型前端 项目的首选编程语言\n\n目前，前端最新的开发技术栈：\n\n1. React： TS + Hooks\n2. Vue： TS + Vue3\n\n  - 注意： Vue2 对 TS 的支持不好~ \n\n---\n\n## TypeScript 初体验\n\n1. 安装编译 TS 的工具包\n2. 编译并运行 TS 代码\n3. 简化运行 TS 的步骤\n\n### 安装编译 TS 的工具包\n\n- 问题：为什么要安装编译 TS 的工具包?\n- 回答：Node.js/浏览器，只认识 JS 代码，不认识 TS 代码。需要先将 TS 代码转化为 JS 代码，然后才能运行\n- 安装命令：`npm i -g typescript`\n  - typescript 包：用来编译 TS 代码的包，提供了 `tsc` 命令，实现了 TS -> JS 的转化\n  - *注意：Mac 电脑安装全局包时，需要添加 `sudo` 获取权限：`sudo npm i -g typescript`*  yarn 全局安装：`sudo yarn global add typescript`\n- 验证是否安装成功：tsc –v(查看 typescript 的版本)\n\n![TS 编译](https://qarabala.gitee.io/docsify/typescript/images/TS编译.png)\n\n###  编译并运行 TS 代码\n\n1. 创建 hello.ts 文件（注意：**TS 文件的后缀名为 `.ts`**）\n2. 将 TS 编译为 JS：在终端中输入命令，`tsc hello.ts`（此时，在同级目录中会出现一个同名的 JS 文件）\n3. 执行 JS 代码：在终端中输入命令，`node hello.js`\n\n1 创建 ts 文件  ===>  2 编译 TS  ===>  3 执行 JS  \n\n- 说明：所有合法的 JS 代码都是 TS 代码，有 JS 基础只需要学习 TS 的类型即可\n- 注意：由 TS 编译生成的 JS 文件，代码中就没有类型信息了\n\n### 简化运行 TS 的步骤\n\n- 问题描述：每次修改代码后，都要重复执行两个命令，才能运行 TS 代码，太繁琐\n- 简化方式：使用 `ts-node` 包，直接在 Node.js 中执行 TS 代码\n- 安装命令：`npm i -g ts-node`\n  - ts-node 包提供了 `ts-node` 命令\n  - 使用方式：`ts-node hello.ts` 相当于：1 tsc 命令  2 node（注意：ts-node 不会生成 js 文件）\n\n解释：ts-node 命令在内部偷偷的将 TS -> JS，然后，再运行 JS 代码\n\n\n# TypeScript 常用类型\n\n- TypeScript 是 JS 的超集，TS 提供了 JS 的所有功能，并且额外的增加了：**类型系统**\n  - 所有的 JS 代码都是 TS 代码\n  - **JS 有类型**（比如，number/string 等），但是 **JS 不会检查变量的类型是否发生变化**，而 TS 会检查\n- TypeScript 类型系统的主要优势：**可以显示标记出代码中的意外行为，从而降低了发生错误的可能性**\n\n1. 类型注解\n2. 常用基础类型\n\n## 类型注解\n\n示例代码:\n\n```ts\nlet age: number = 18\n```\n\n- 说明：代码中的 `: number` 就是**类型注解**\n- 作用：**为变量添加类型约束**。比如，上述代码中，约定变量 age 的类型为 number 类型\n- 解释：**约定了什么类型，就只能给变量赋值该类型的值，否则，就会报错**\n\n- 错误演示：\n\n```ts\n// 错误代码：\n// 错误原因：将 string 类型的值赋值给了 number 类型的变量，类型不一致\nlet age: number = \'18\'\n```\n\n## 常用基础类型\n\n可以将 TS 中的常用基础类型细分为两类：1 JS 已有类型 2 TS 新增类型\n\n1. JS 已有类型\n  - 原始类型：`number/string/boolean/null/undefined/symbol`\n  - 对象类型：`object`（包括，数组、对象、函数等对象）\n2. TS 新增类型\n  - 联合类型、自定义类型(类型别名)、接口、元组、字面量类型、枚举、void、any 等\n\n- 注意：\n  1. *原始类型*在 TS 和 JS 中写法一致\n  2. *对象类型*在 TS 中更加细化，每个具体的对象（比如，数组、对象、函数）都有自己的类型语法\n\n### 原始类型\n\n- 原始类型：number/string/boolean/null/undefined/symbol\n- 特点：简单，这些类型，完全按照 JS 中类型的名称来书写\n\n```ts\nlet age: number = 18\nlet myName: string = \'老师\'\nlet isLoading: boolean = false\n\n// 等等...\n```\n\n###  数组类型\n\n- 数组类型的两种写法：\n  - 推荐使用 `number[]` 写法\n\n```ts\n// 写法一：\nlet numbers: number[] = [1, 3, 5]\n// 写法二：\nlet strings: Array<string> = [\'a\', \'b\', \'c\']\n```\n\n### 联合类型\n\n需求：数组中既有 number 类型，又有 string 类型，这个数组的类型应该如何写?\n\n```ts\nlet arr: (number | string)[] = [1, \'a\', 3, \'b\']\n```\n\n- 解释：`|`（竖线）在 TS 中叫做**联合类型**，即：由两个或多个其他类型组成的类型，表示可以是这些类型中的任意一种\n- 注意：这是 TS 中联合类型的语法，只有一根竖线，不要与 JS 中的或（|| 或）混淆了\n\n### 类型别名\n\n- `类型别名（自定义类型）`：为任意类型起别名\n- 使用场景：当同一类型（复杂）被多次使用时，可以通过类型别名，**简化该类型的使用**\n\n```ts\ntype CustomArray = (number | string)[]\n\nlet arr1: CustomArray = [1, \'a\', 3, \'b\']\nlet arr2: CustomArray = [\'x\', \'y\', 6, 7]\n```\n\n- 解释:\n  1. 使用 `type` 关键字来创建自定义类型\n  2. 类型别名（比如，此处的 *CustomArray*）可以是任意合法的变量名称\n  3. 推荐使用大写字母开头\n  4. 创建类型别名后，直接使用该类型别名作为变量的类型注解即可\n\n### 函数类型\n\n- 函数的类型实际上指的是：`函数参数`和`返回值`的类型\n- 为函数指定类型的两种方式：\n  1. 单独指定参数、返回值的类型\n  2. 同时指定参数、返回值的类型\n\n1. 单独指定参数、返回值的类型：\n\n```ts\n// 函数声明\nfunction add(num1: number, num2: number): number {\n  return num1 + num2\n}\n\n// 箭头函数\nconst add = (num1: number, num2: number): number => {\n  return num1 + num2\n}\n```\n\n2. 同时指定参数、返回值的类型:\n\n```ts\ntype AddFn = (num1: number, num2: number) => number\n\nconst add: AddFn = (num1, num2) => {\n  return num1 + num2\n}\n```\n\n- 解释：当函数作为表达式时，可以通过类似箭头函数形式的语法来为函数添加类型\n- 注意：这种形式只适用于函数表达式\n\n#### void 类型\n\n- 如果函数没有返回值，那么，函数返回值类型为：`void`\n\n```ts\nfunction greet(name: string): void {\n  console.log(\'Hello\', name)\n}\n```\n\n- 注意：\n  - 如果一个函数没有返回值，此时，在 TS 的类型中，应该使用 `void` 类型\n\n```ts\n// 如果什么都不写，此时，add 函数的返回值类型为： void\nconst add = () => {}\n// 这种写法是明确指定函数返回值类型为 void，与上面不指定返回值类型相同\nconst add = (): void => {}\n\n// 但，如果指定 返回值类型为 undefined，此时，函数体中必须显示的 return undefined 才可以\nconst add = (): undefined => {\n  // 此处，返回的 undefined 是 JS 中的一个值\n  return undefined\n}\n```\n\n#### 函数可选参数\n\n- 使用函数实现某个功能时，参数可以传也可以不传。这种情况下，在给函数参数指定类型时，就用到**可选参数**了\n- 比如，数组的 slice 方法，可以 `slice()` 也可以 `slice(1)` 还可以 `slice(1, 3)`\n\n```ts\nfunction mySlice(start?: number, end?: number): void {\n  console.log(\'起始索引：\', start, \'结束索引：\', end)\n}\n```\n\n- 可选参数：在可传可不传的参数名称后面添加 `?`（问号）\n- 注意：**可选参数只能出现在参数列表的最后**，也就是说可选参数后面不能再出现必选参数\n\n### 对象类型\n\n- JS 中的对象是由属性和方法构成的，而 **TS 对象的类型就是在描述对象的结构**（有什么类型的属性和方法）\n- 对象类型的写法:\n\n```ts\n// 空对象\nlet person: {} = {}\n\n// 有属性的对象\nlet person: { name: string } = {\n  name: \'同学\'\n}\n\n// 既有属性又有方法的对象\n// 在一行代码中指定对象的多个属性类型时，使用 `;`（分号）来分隔\nlet person: { name: string; sayHi(): void } = {\n  name: \'jack\',\n  sayHi() {}\n}\n\n// 对象中如果有多个类型，可以换行写：\n// 通过换行来分隔多个属性类型，可以去掉 `;`\nlet person: {\n  name: string\n  sayHi(): void\n} = {\n  name: \'jack\',\n  sayHi() {}\n}\n```\n\n- 解释:\n  1. 使用 `{}` 来描述对象结构\n  2. 属性采用`属性名: 类型`的形式\n  3. 方法采用`方法名(): 返回值类型`的形式\n\n#### 使用类型别名\n\n- 注意：直接使用 `{}` 形式为对象添加类型，会降低代码的可读性（不好辨识类型和值）\n- 推荐：**使用类型别名为对象添加类型**\n\n```ts\n// 创建类型别名\ntype Person = {\n  name: string\n  sayHi(): void\n}\n\n// 使用类型别名作为对象的类型：\nlet person: Person = {\n  name: \'jack\',\n  sayHi() {}\n}\n```\n\n#### 带有参数的方法类型\n\n- 如果方法有参数，就在方法名后面的小括号中指定参数类型\n\n```ts\ntype Person = {\n  greet(name: string): void\n}\n\nlet person: Person = {\n  greet(name) {\n    console.log(name)\n  }\n}\n```\n\n#### 箭头函数形式的方法类型\n\n- 方法的类型也可以使用箭头函数形式\n\n```ts\ntype Person = {\n  greet: (name: string) => void\n}\n\nlet person: Person = {\n  greet(name) {\n    console.log(name)\n  }\n}\n```\n\n#### 对象可选属性\n\n- 对象的属性或方法，也可以是可选的，此时就用到**可选属性**了\n- 比如，我们在使用 `axios({ ... })` 时，如果发送 GET 请求，method 属性就可以省略\n- 可选属性的语法与函数可选参数的语法一致，都使用 `?` 来表示\n\n```ts\ntype Config = {\n  url: string\n  method?: string\n}\n\nfunction myAxios(config: Config) {\n  console.log(config)\n}\n```\n\n### 接口\n\n当一个对象类型被多次使用时，一般会使用接口（`interface`）来描述对象的类型，达到复用的目的\n\n- 解释：\n  1. 使用 `interface` 关键字来声明接口\n  2. 接口名称(比如，此处的 IPerson)，可以是任意合法的变量名称，推荐以 `I` 开头\n  3. 声明接口后，直接使用接口名称作为变量的类型\n  4. 因为每一行只有一个属性类型，因此，属性类型后没有 ;(分号)\n\n```ts\ninterface IPerson {\n  name: string\n  age: number\n  sayHi(): void\n}\n\nlet person: IPerson = {\n  name: \'jack\',\n  age: 19,\n  sayHi() {}\n}\n```\n\n#### interface vs type\n\n- interface（接口）和 type（类型别名）的对比：\n- 相同点：都可以给对象指定类型\n- 不同点:\n  - 接口，只能为对象指定类型\n  - 类型别名，不仅可以为对象指定类型，实际上可以为任意类型指定别名\n- 推荐：**能使用 type 就是用 type**\n\n```ts\ninterface IPerson {\n  name: string\n  age: number\n  sayHi(): void\n}\n\n// 为对象类型创建类型别名\ntype IPerson = {\n  name: string\n  age: number\n  sayHi(): void\n}\n\n// 为联合类型创建类型别名\ntype NumStr = number | string\n```\n\n#### 接口继承\n\n- 如果两个接口之间有相同的属性或方法，可以将**公共的属性或方法抽离出来，通过继承来实现复用**\n- 比如，这两个接口都有 x、y 两个属性，重复写两次，可以，但很繁琐\n\n```ts\ninterface Point2D { x: number; y: number }\ninterface Point3D { x: number; y: number; z: number }\n```\n\n- 更好的方式:\n\n```ts\ninterface Point2D { x: number; y: number }\n// 继承 Point2D\ninterface Point3D extends Point2D {\n  z: number\n}\n```\n\n- 解释：\n  1. 使用 `extends`(继承)关键字实现了接口 Point3D 继承 Point2D\n  2. 继承后，Point3D 就有了 Point2D 的所有属性和方法(此时，Point3D 同时有 x、y、z 三个属性)\n\n### 元组\n\n- 场景：在地图中，使用经纬度坐标来标记位置信息\n- 可以使用数组来记录坐标，那么，该数组中只有两个元素，并且这两个元素都是数值类型 number[]\n\n```ts\nlet position: number[] = [116.2317, 39.5427]\n```\n\n- 使用 number[] 的缺点：不严谨，因为该类型的数组中可以出现任意多个数字\n- 更好的方式：`元组 Tuple`\n- 元组类型是另一种类型的数组，它确切地知道包含多少个元素，**以及特定索引对应的类型**\n\n```ts\nlet position: [number, number] = [39.5427, 116.2317]\n```\n\n- 解释：\n  1. 元组类型可以确切地标记出有多少个元素，以及每个元素的类型\n  2. 该示例中，元素有两个元素，每个元素的类型都是 number\n\n---\n\n### 类型推论\n\n- 在 TS 中，某些没有明确指出类型的地方，**TS 的类型推论机制会帮助提供类型**\n- 换句话说：由于类型推论的存在，这些地方，类型注解可以省略不写\n- 发生类型推论的 2 种常见场景:\n  1. 声明变量并初始化时\n  2. 决定函数返回值时\n\n```ts\n// 变量 age 的类型被自动推断为：number\nlet age = 18\n\n// 函数返回值的类型被自动推断为：number\nfunction add(num1: number, num2: number) {\n  return num1 + num2\n}\n```\n\n- 推荐：**能省略类型注解的地方就省略**（~~偷懒~~，充分利用TS类型推论的能力，提升开发效率）\n- 技巧：如果不知道类型，可以通过鼠标放在变量名称上，利用 VSCode 的提示来查看类型\n- 推荐：在 VSCode 中写代码的时候，多看方法、属性的类型，养成写代码看类型的习惯\n\n```\nconsole.log()\ndocument.createElement()\n```\n\n\n\n### 字面量类型\n\n- 思考以下代码，两个变量的类型分别是什么?\n\n```ts\nlet str1 = \'Hello TS\'\nconst str2 = \'Hello TS\'\n```\n\n- 通过 TS 类型推论机制，可以得到答案：\n  1. 变量 str1 的类型为：string\n  2.  变量 str2 的类型为：\'Hello TS\'\n\n- 解释:\n1. str1 是一个变量(let)，它的值可以是任意字符串，所以类型为:string\n2. str2 是一个常量(const)，它的值不能变化只能是 \'Hello TS\'，所以，它的类型为:\'Hello TS\'\n\n- 注意：此处的 \'Hello TS\'，就是一个**字面量类型**，也就是说某个特定的字符串也可以作为 TS 中的类型\n- 任意的 JS 字面量（比如，对象、数字等）都可以作为类型使用\n  - 字面量：`{ name: \'jack\' }` `[]` `18` `20` `\'abc\'` `false` `function() {}`\n\n```jsx\nlet str1 = \'Hello TS\'\nconst str2 = \'Hello TS123\'\n\nstr1 = str2\n\n// str2 = str1 不行\n\n```\n\n\n\n#### 使用模式和场景\n\n- 使用模式：**字面量类型配合联合类型一起使用**\n- 使用场景：用来表示一组明确的可选值列表\n- 比如，在贪吃蛇游戏中，游戏的方向的可选值只能是上、下、左、右中的任意一个\n\n```ts\n// 使用自定义类型:\ntype Direction = \'up\' | \'down\' | \'left\' | \'right\'\n\nfunction changeDirection(direction: Direction) {\n  console.log(direction)\n}\n\n// 调用函数时，会有类型提示：\nchangeDirection(\'up\')\n```\n\n- 解释：参数 direction 的值只能是 up/down/left/right 中的任意一个\n- 优势：相比于 string 类型，使用字面量类型更加精确、严谨\n\n### 【了解】枚举\n\n- 枚举的功能类似于**字面量类型+联合类型组合**的功能，也可以表示一组明确的可选值\n- 枚举：定义一组命名常量。它描述一个值，该值可以是这些命名常量中的一个\n\n```ts\n// 创建枚举\nenum Direction { Up, Down, Left, Right }\n\n// 使用枚举类型\nfunction changeDirection(direction: Direction) {\n  console.log(direction)\n}\n\n// 调用函数时，需要应该传入：枚举 Direction 成员的任意一个\n// 类似于 JS 中的对象，直接通过 点（.）语法 访问枚举的成员\nchangeDirection(Direction.Up)\n```\n\n- 解释:\n  1. 使用 `enum` 关键字定义枚举\n  2. 约定枚举名称以大写字母开头\n  3. 枚举中的多个值之间通过 `,`（逗号）分隔\n  4. 定义好枚举后，直接使用枚举名称作为类型注解\n\n#### 数字枚举\n\n- 问题：我们把枚举成员作为了函数的实参，它的值是什么呢?\n- 解释：通过将鼠标移入 Direction.Up，可以看到枚举成员 Up 的值为 0\n- 注意：枚举成员是有值的，默认为：从 0 开始自增的数值\n- 我们把，枚举成员的值为数字的枚举，称为：`数字枚举`\n- 当然，也可以给枚举中的成员初始化值\n\n```ts\n// Down -> 11、Left -> 12、Right -> 13\nenum Direction { Up = 10, Down, Left, Right }\n\nenum Direction { Up = 2, Down = 4, Left = 8, Right = 16 }\n```\n\n#### 字符串枚举\n\n- 字符串枚举：枚举成员的值是字符串\n- 注意：字符串枚举没有自增长行为，因此，**字符串枚举的每个成员必须有初始值**\n\n```ts\nenum Direction {\n  Up = \'UP\',\n  Down = \'DOWN\',\n  Left = \'LEFT\',\n  Right = \'RIGHT\'\n}\n```\n\n#### 枚举实现原理\n\n- 枚举是 TS 为数不多的非 JavaScript 类型级扩展(不仅仅是类型)的特性之一\n- 因为：其他类型仅仅被当做类型，而枚举不仅用作类型，还提供值(枚举成员都是有值的)\n- 也就是说，其他的类型会在编译为 JS 代码时自动移除。但是，**枚举类型会被编译为 JS 代码**\n\n```ts\nenum Direction {\n  Up = \'UP\',\n  Down = \'DOWN\',\n  Left = \'LEFT\',\n  Right = \'RIGHT\'\n}\n\n// 会被编译为以下 JS 代码：\nvar Direction;\n\n(function (Direction) {\n  Direction[\'Up\'] = \'UP\'\n  Direction[\'Down\'] = \'DOWN\'\n  Direction[\'Left\'] = \'LEFT\'\n  Direction[\'Right\'] = \'RIGHT\'\n})(Direction || Direction = {})\n```\n\n- 说明：枚举与前面讲到的字面量类型+联合类型组合的功能类似，都用来表示一组明确的可选值列表\n- 一般情况下，**推荐使用字面量类型+联合类型组合的方式**，因为相比枚举，这种方式更加直观、简洁、高效\n\n### any 类型\n\n- **原则:不推荐使用 any**!这会让 TypeScript 变为 “AnyScript”(失去 TS 类型保护的优势)\n- 因为当值的类型为 any 时，可以对该值进行任意操作，并且不会有代码提示\n\n```ts\nlet obj: any = { x: 0 }\n\nobj.bar = 100\nobj()\nconst n: number = obj\n```\n\n- 解释:以上操作都不会有任何类型错误提示，即使可能存在错误\n- 尽可能的避免使用 any 类型，除非临时使用 any 来“避免”书写很长、很复杂的类型\n- 其他隐式具有 any 类型的情况\n  1. 声明变量不提供类型也不提供默认值\n  2. 函数参数不加类型\n- 注意：因为不推荐使用 any，所以，这两种情况下都应该提供类型\n\n在项目开发中，尽量少用any类型\n\n---\n\n### 类型断言\n\n有时候你会比 TS 更加明确一个值的类型，此时，可以使用类型断言来指定更具体的类型。 比如，\n\n```ts\nconst aLink = document.getElementById(\'link\')\n```\n\n- 注意：该方法返回值的类型是 HTMLElement，该类型只包含所有标签公共的属性或方法，不包含 a 标签特有的 href 等属性\n- 因此，这个**类型太宽泛(不具体)**，无法操作 href 等 a 标签特有的属性或方法\n- 解决方式：这种情况下就需要**使用类型断言指定更加具体的类型**\n- 使用类型断言：\n\n```ts\nconst aLink = document.getElementById(\'link\') as HTMLAnchorElement\n```\n\n- 解释:\n  1. 使用 `as` 关键字实现类型断言\n  2. 关键字 as 后面的类型是一个更加具体的类型（HTMLAnchorElement 是 HTMLElement 的子类型）\n  3. 通过类型断言，aLink 的类型变得更加具体，这样就可以访问 a 标签特有的属性或方法了\n\n- 另一种语法，使用 `<>` 语法，这种语法形式不常用知道即可:\n\n```ts\n// 该语法，知道即可：在react的jsx中使用会报错\nconst aLink = <HTMLAnchorElement>document.getElementById(\'link\')\n```\n\n*技巧：在浏览器控制台，通过 `__proto__` 获取 DOM 元素的类型*\n\n### typeof\n\n- 众所周知，JS 中提供了 typeof 操作符，用来在 JS 中获取数据的类型\n\n```js\nconsole.log(typeof \'Hello world\') // ?\n```\n\n- 实际上，TS 也提供了 typeof 操作符：可以在*类型上下文*中引用变量或属性的类型（类型查询）\n- 使用场景:根据已有变量的值，获取该值的类型，来简化类型书写\n\n```ts\nlet p = { x: 1, y: 2 }\nfunction formatPoint(point: { x: number; y: number }) {}\nformatPoint(p)\n\nfunction formatPoint(point: typeof p) {}\n```\n\n- 解释:\n  1. 使用 `typeof` 操作符来获取变量 p 的类型，结果与第一种（对象字面量形式的类型）相同\n  2. typeof 出现在**类型注解的位置（参数名称的冒号后面）所处的环境就在类型上下文**(区别于 JS 代码)\n  3. 注意：typeof 只能用来查询变量或属性的类型，无法查询其他形式的类型（比如，函数调用的类型）\n\n\n# TypeScript 高级类型\n\nTS 中的高级类型有很多，重点学习以下高级类型：\n\n1. 泛型 和 keyof\n2. 索引签名类型 和 索引查询类型\n3. 映射类型\n\n## 泛型\n\n- **泛型是可以在保证类型安全前提下，让函数等与多种类型一起工作，从而实现复用**，常用于：函数、接口、class 中\n- 需求：创建一个 id 函数，传入什么数据就返回该数据本身(也就是说，参数和返回值类型相同)\n\n```ts\nfunction id(value: number): number { return value }\n```\n\n- 比如，id(10) 调用以上函数就会直接返回 10 本身。但是，该函数只接收数值类型，无法用于其他类型\n- 为了能让函数能够接受任意类型，可以将参数类型修改为 any。但是，这样就失去了 TS 的类型保护，类型不安全\n\n```ts\nfunction id(value: any): any { return value }\n```\n\n- **泛型在保证类型安全(不丢失类型信息)的同时，可以让函数等与多种不同的类型一起工作，灵活可复用**\n- 实际上，在 C# 和 Java 等编程语言中，泛型都是用来实现可复用组件功能的主要工具之一\n\n### 创建泛型函数\n\n```ts\nfunction id<Type>(value: Type): Type { return value }\n\nfunction id<T>(value: T): T { return value }\n```\n\n- 解释:\n  1. 语法：在函数名称的后面添加 `<>`(尖括号)，**尖括号中添加类型变量**，比如此处的 Type\n  2. **类型变量 Type，是一种特殊类型的变量，它处理类型而不是值**\n  3. **该类型变量相当于一个类型容器**，能够捕获用户提供的类型(具体是什么类型由用户调用该函数时指定)\n  4. 因为 Type 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型\n  5. 类型变量 Type，可以是任意合法的变量名称\n\n### 调用泛型函数\n\n```ts\nconst num = id<number>(10)\nconst str = id<string>(\'a\')\n```\n\n- 解释：\n  1. 语法：在函数名称的后面添加 `<>`(尖括号)，**尖括号中指定具体的类型**，比如，此处的 number\n  2. 当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 Type 捕获到\n  3. 此时，Type 的类型就是 number，所以，函数 id 参数和返回值的类型也都是 number\n\n- 同样，如果传入类型 string，函数 id 参数和返回值的类型就都是 string\n- 这样，通过泛型就做到了让 id 函数与多种不同的类型一起工作，**实现了复用的同时保证了类型安全**\n\n### 简化泛型函数调用\n\n```ts\n// 省略 <number> 调用函数\nlet num = id(10)\nlet str = id(\'a\')\n```\n\n- 解释:\n  1. 在调用泛型函数时，**可以省略 `<类型>` 来简化泛型函数的调用**\n  2. 此时，TS 内部会采用一种叫做**类型参数推断**的机制，来根据传入的实参自动推断出类型变量 Type 的类型\n  3. 比如，传入实参 10，TS 会自动推断出变量 num 的类型 number，并作为 Type 的类型\n\n- 推荐：使用这种简化的方式调用泛型函数，使代码更短，更易于阅读\n- 说明：**当编译器无法推断类型或者推断的类型不准确时，就需要显式地传入类型参数**\n\n### 泛型约束\n\n- 默认情况下，泛型函数的类型变量 Type 可以代表多个类型，这导致无法访问任何属性\n- 比如，id(\'a\') 调用函数时获取参数的长度：\n\n```ts\nfunction id<Type>(value: Type): Type {\n  console.log(value.length)\n  return value\n}\n\nid(\'a\')\n```\n\n- 解释：Type 可以代表任意类型，无法保证一定存在 length 属性，比如 number 类型就没有 length\n- 此时，就需要**为泛型添加约束来`收缩类型`(缩窄类型取值范围)**\n- 添加泛型约束收缩类型，主要有以下两种方式：1 指定更加具体的类型  2 添加约束\n\n#### 指定更加具体的类型\n\n比如，将类型修改为 `Type[]`(Type 类型的数组)，因为只要是数组就一定存在 length 属性，因此就可以访问了\n\n```ts\nfunction id<Type>(value: Type[]): Type[] {\n  console.log(value.length)\n  return value\n}\n```\n\n#### 添加约束\n\n```ts\n// 创建一个接口\ninterface ILength { length: number }\n\n// Type extends ILength 添加泛型约束\n// 解释：表示传入的 类型 必须满足 ILength 接口的要求才行，也就是得有一个 number 类型的 length 属性\nfunction id<Type extends ILength>(value: Type): Type {\n  console.log(value.length)\n  return value\n}\n```\n\n- 解释:\n  1. 创建描述约束的接口 ILength，该接口要求提供 length 属性\n  2. 通过 `extends` 关键字使用该接口，为泛型(类型变量)添加约束\n  3. 该约束表示：**传入的类型必须具有 length 属性**\n- 注意:传入的实参(比如，数组)只要有 length 属性即可（类型兼容性)\n\n### 多个类型变量\n\n泛型的类型变量可以有多个，并且**类型变量之间还可以约束**(比如，第二个类型变量受第一个类型变量约束)\n比如，创建一个函数来获取对象中属性的值：\n\n```ts\nfunction getProp<Type, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key]\n}\nlet person = { name: \'jack\', age: 18 }\ngetProp(person, \'name\')\n```\n\n- 解释:\n  1. 添加了第二个类型变量 Key，两个类型变量之间使用 `,` 逗号分隔。\n  2. **keyof 关键字接收一个对象类型，生成其键名称(可能是字符串或数字)的联合类型**。\n  3. 本示例中 `keyof Type` 实际上获取的是 person 对象所有键的联合类型，也就是：`\'name\' | \'age\'`\n  4. 类型变量 Key 受 Type 约束，可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性\n\n```ts\n// Type extends object 表示： Type 应该是一个对象类型，如果不是 对象 类型，就会报错\n// 如果要用到 对象 类型，应该用 object ，而不是 Object\nfunction getProperty<Type extends object, Key extends keyof Type>(obj: Type, key: Key) {\n  return obj[key]\n}\n```\n\n---\n\n### 泛型接口\n\n泛型接口：接口也可以配合泛型来使用，以增加其灵活性，增强其复用性\n\n```ts\ninterface IdFunc<Type> {\n  id: (value: Type) => Type\n  ids: () => Type[]\n}\n\nlet obj: IdFunc<number> = {\n  id(value) { return value },\n  ids() { return [1, 3, 5] }\n}\n```\n\n- 解释:\n  1. 在接口名称的后面添加 `<类型变量>`，那么，这个接口就变成了泛型接口。\n  2. 接口的类型变量，对接口中所有其他成员可见，也就是**接口中所有成员都可以使用类型变量**。\n  3. 使用泛型接口时，**需要显式指定具体的类型**(比如，此处的 IdFunc<nunber>)。\n  4. 此时，id 方法的参数和返回值类型都是 number;ids 方法的返回值类型是 number[]。\n\n#### JS 中的泛型接口\n\n实际上，JS 中的数组在 TS 中就是一个泛型接口。\n\n```ts\nconst strs = [\'a\', \'b\', \'c\']\n// 鼠标放在 forEach 上查看类型\nstrs.forEach\n\nconst nums = [1, 3, 5]\n// 鼠标放在 forEach 上查看类型\nnums.forEach\n```\n\n![image-20210917002203414](images/image-20210917002203414.png)\n\n- 解释:当我们在使用数组时，TS 会根据数组的不同类型，来自动将类型变量设置为相应的类型\n- 技巧:可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看具体的类型信息\n\n### 泛型工具类型\n\n- 泛型工具类型:TS 内置了一些常用的工具类型，来简化 TS 中的一些常见操作\n- 说明:它们都是基于泛型实现的(泛型适用于多种类型，更加通用)，并且是内置的，可以直接在代码中使用。 这些工具类型有很多，主要学习以下几个:\n\n1. `Partial<Type>`\n2. `Readonly<Type>`\n3. `Pick<Type, Keys>`\n4. `Omit<Type>`\n\n#### Partial\n\n- Partial<Type> 用来构造(创建)一个类型，将 Type 的所有属性设置为可选。\n\n```ts\ntype Props =  {\n  id: string\n  children: number[]\n}\n\ntype PartialProps = Partial<Props>\n```\n\n- 解释:构造出来的新类型 PartialProps 结构和 Props 相同，但所有属性都变为可选的。\n\n#### Readonly\n\n- Readonly<Type> 用来构造一个类型，将 Type 的所有属性都设置为 readonly(只读)。\n\n```ts\ntype Props =  {\n  id: string\n  children: number[]\n}\n\ntype ReadonlyProps = Readonly<Props>\n```\n\n- 解释:构造出来的新类型 ReadonlyProps 结构和 Props 相同，但所有属性都变为只读的。\n\n```ts\nlet props: ReadonlyProps = { id: \'1\', children: [] }\n// 错误演示\nprops.id = \'2\'\n```\n\n- 当我们想重新给 id 属性赋值时，就会报错:无法分配到 \"id\" ，因为它是只读属性。\n\n#### Pick\n\n- Pick<Type, Keys> 从 Type 中选择一组属性来构造新类型。\n\n```ts\ninterface Props {\n  id: string\n  title: string\n  children: number[]\n}\ntype PickProps = Pick<Props, \'id\' | \'title\'>\n```\n\n- 解释:\n  1. Pick 工具类型有两个类型变量:1 表示选择谁的属性 2 表示选择哪几个属性。 2. 其中第二个类型变量，如果只选择一个则只传入该属性名即可。\n  2. 第二个类型变量传入的属性只能是第一个类型变量中存在的属性。\n  3. 构造出来的新类型 PickProps，只有 id 和 title 两个属性类型。\n\n#### Omit\n\nOmit<K,T>类型让我们可以从另一个对象类型中剔除某些属性，并创建一个新的对象类型：\n\nK：是对象类型名称，T：是剔除K类型中的属性名称\n\n![image-20210917003456128](images/image-20210917003456128.png)\n\n\n\n\n\n\n\n\n\n## 索引签名类型\n\n绝大多数情况下，我们都可以在使用对象前就确定对象的结构，并为对象添加准确的类型。\n使用场景:**当无法确定对象中有哪些属性**(或者说对象中可以出现任意多个属性)，此时，就用到**索引签名类型**了。\n\n```ts\ninterface AnyObject {\n  [key: string]: number\n}\nlet obj: AnyObject = {\n  a: 1,\n  b: 2,\n}\n```\n\n- 解释:\n  1. 使用 `[key: string]` 来约束该接口中允许出现的属性名称。表示只要是 string 类型的属性名称，都可以出现在对象中。\n  2. 这样，对象 obj 中就可以出现任意多个属性(比如，a、b 等)。\n  3. `key 只是一个占位符`，可以换成任意合法的变量名称。\n  4. 隐藏的前置知识:`JS 中对象({})的键是 string 类型的`。\n\n### 数组索引类型签名\n\n- 在 JS 中数组是一类特殊的对象，特殊在数组的键(索引)是数值类型\n- 并且，数组也可以出现任意多个元素。所以，在数组对应的泛型接口中，也用到了索引签名类型。\n\n```ts\ninterface MyArray<T> {\n  [n: number]: T\n}\nlet arr: MyArray<number> = [1, 3, 5]\n```\n\n- 解释:\n    1. MyArray 接口模拟原生的数组接口，并使用 `[n: number]` 来作为索引签名类型。\n  2. 该索引签名类型表示:只要是 number 类型的键(索引)都可以出现在数组中，或者说数组中可以有任意多个元素。\n  3. 同时也符合数组索引是 number 类型这一前提。\n\n## 映射类型\n\n- 映射类型:**基于旧类型创建新类型(对象类型**)，减少重复、提升开发效率。\n比如，类型 PropKeys 有 x/y/z，另一个类型 Type1 中也有 x/y/z，并且 Type1 中 x/y/z 的类型相同:\n\n```ts\ntype PropKeys = \'x\' | \'y\' | \'z\'\ntype Type1 = { x: number; y: number; z: number }\n```\n\n- 这样书写没错，但 x/y/z 重复书写了两次。像这种情况，就可以使用映射类型来进行简化。\n\n```ts\ntype PropKeys = \'x\' | \'y\' | \'z\'\ntype Type2 = { [Key in PropKeys]: number }\n```\n\n- 解释:\n  1. 映射类型是基于索引签名类型的，所以，该语法类似于索引签名类型，也使用了 []。\n  2. `Key in PropKeys` 表示 Key 可以是 PropKeys 联合类型中的任意一个，类似于 forin(let k in obj)。\n  3. 使用映射类型创建的新对象类型 Type2 和类型 Type1 结构完全相同。\n  4. 注意:**映射类型只能在类型别名中使用，不能在接口中使用**。\n\n### 根据对象创建\n\n映射类型除了根据联合类型创建新类型外，还可以根据对象类型来创建:\n\n```ts\ntype Props = { a: number; b: string; c: boolean }\ntype Type3 = { [key in keyof Props]: number }\n```\n\n- 解释:\n  1. 首先，先执行 `keyof Props` 获取到对象类型 Props 中所有键的联合类型即，\'a\' | \'b\' | \'c\'。\n  2. 然后，`Key in ...` 就表示 Key 可以是 Props 中所有的键名称中的任意一个。\n\n### 内置映射类型实现分析\n\n- 实际上，前面讲到的**泛型工具类型**(比如，Partial<Type>)都是基于映射类型实现的。 \n- 比如，Partial<Type> 的实现:\n\n```ts\ntype Partial<T> = {\n  [P in keyof T]?: T[P]\n}\n\ntype Props = { a: number; b: string; c: boolean }\ntype PartialProps = Partial<Props>\n```\n\n- 解释:\n  1. `keyof T` 即 keyof Props 表示获取 Props 的所有键，也就是:\'a\' | \'b\' | \'c\'。\n  2. 在 [] 后面添加 `?`(问号)，表示将这些属性变为`可选`的，以此来实现 Partial 的功能。\n  3. 冒号后面的 `T[P] 表示获取 T 中每个键对应的类型`。比如，如果是 \'a\' 则类型是 number;如果是 \'b\' 则类型是 string。\n  4. 最终，新类型 PartialProps 和旧类型 Props 结构完全相同，只是让所有类型都变为可选了。\n\n### 索引访问类型\n\n- 刚刚用到的 `T[P]` 语法，在 TS 中叫做`索引访问类型`\n- 作用:**用来查询属性的类型**。\n\n```ts\ntype Props = { a: number; b: string; c: boolean }\ntype TypeA = Props[\'a\']\n```\n\n- 解释:`Props[\'a\']` 表示查询类型 Props 中属性 \'a\' 对应的类型 number。所以，TypeA 的类型为 number\n- 注意:**[] 中的属性必须存在于被查询类型中**，否则就会报错。\n\n#### 同时查询多个索引的类型\n\n- 索引查询类型的其他使用方式:同时查询多个索引的类型\n\n```ts\ntype Props = { a: number; b: string; c: boolean }\n\ntype TypeA = Props[\'a\' | \'b\'] // string | number\n```\n\n- 解释:使用字符串字面量的联合类型，获取属性 a 和 b 对应的类型，结果为: string | number。\n\n```ts\ntype TypeA = Props[keyof Props] // string | number | boolean\n```\n\n- 解释:使用 keyof 操作符获取 Props 中所有键对应的类型，结果为: string | number | boolean。 \n\n\n\n# 在 React 项目中使用 TS\n\n1. 创建新项目\n2. 在现有项目中添加 TS\n\n## 创建新项目\n\n- 命令：`npx create-react-app my-app --template typescript`\n- 说明：在命令行中，添加 `--template typescript` 表示创建支持 TS 的项目\n\n- 项目目录的变化：\n  1. 在项目根目录中多了一个文件：`tsconfig.json`\n     - TS 的配置文件\n  2. 在 src 目录中，文件的后缀有变化，由原来的 .js 变为 `.ts` 或 `.tsx`\n     - `.ts` ts 文件的后缀名\n     - `.tsx` 是在 TS 中使用 React 组件时，需要使用该后缀\n  3. 在 src 目录中，多了 `react-app-env.d.ts` 文件\n     - `.d.ts` 类型声明文件，用来指定类型\n\n## tsconfig的介绍\n\n+ tsconfig.json是typescript项目的配置文件，用于配置typescript\n+ tsconfig.json配置文件可以通过 `tsc --init` 生成\n\n- 说明：所有的配置项都可以通过鼠标移入的方式，来查看配置项的解释说明。\n- [tsconfig 文档链接](https://www.typescriptlang.org/tsconfig)\n\n```json\n{\n  // 编译选项\n  \"compilerOptions\": {\n    // 生成代码的语言版本：将我们写的 TS 代码编译成哪个版本的 JS 代码\n    // 命令行： tsc --target es5 11-测试TS配置文件.ts\n    \"target\": \"es5\",\n    // 指定要包含在编译中的 library\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    // 允许 ts 编译器编译 js 文件\n    \"allowJs\": true,\n    // 跳过类型声明文件的类型检查\n    \"skipLibCheck\": true,\n    // es 模块 互操作，屏蔽 ESModule 和 CommonJS 之间的差异\n    \"esModuleInterop\": true,\n    // 允许通过 import x from \'y\' 即使模块没有显式指定 default 导出\n    \"allowSyntheticDefaultImports\": true,\n    // 开启严格模式\n    \"strict\": true,\n    // 对文件名称强制区分大小写\n    \"forceConsistentCasingInFileNames\": true,\n    // 为 switch 语句启用错误报告\n    \"noFallthroughCasesInSwitch\": true,\n    // 生成代码的模块化标准\n    \"module\": \"esnext\",\n    // 模块解析（查找）策略\n    \"moduleResolution\": \"node\",\n    // 允许导入扩展名为.json的模块\n    \"resolveJsonModule\": true,\n    // 是否将没有 import/export 的文件视为旧（全局而非模块化）脚本文件\n    \"isolatedModules\": true,\n    // 编译时不生成任何文件（只进行类型检查）\n    \"noEmit\": true,\n    // 指定将 JSX 编译成什么形式\n    \"jsx\": \"react-jsx\"\n  },\n  // 指定允许 ts 处理的目录\n  \"include\": [\"src\"]\n}\n```\n\n# typescript声明文件\n\n今天几乎所有的 JavaScript 应用都会引入许多第三方库来完成任务需求。\n\n这些第三方库不管是否是用 TS 编写的，最终都要编译成 JS 代码，才能发布给开发者使用。\n\n我们知道是 TS 提供了类型，才有了代码提示和类型保护等机制。 \n\n但在项目开发中使用第三方库时，你会发现它们几乎都有相应的 TS 类型，这些类型是怎么来的呢? `类型声明文件`\n\n- **类型声明文件：用来为已存在的 JS 库提供类型信息**\n\n这样在 TS 项目中使用这些库时，就像用 TS 一样，都会有代码提示、类型保护等机制了。\n\n1. TS 的两种文件类型\n2. 类型声明文件的使用说明\n\n## TS 中的两种文件类型\n\n- TS 中有两种文件类型：1 `.ts` 文件 2 `.d.ts` 文件\n- .ts 文件:\n  1. `既包含类型信息又可执行代码`\n  2. 可以被编译为 .js 文件，然后，执行代码\n  3. 用途：编写程序代码的地方\n- .d.ts 文件:\n  1. `只包含类型信息`的类型声明文件\n  2. **不会生成 .js 文件，仅用于提供类型信息,在.d.ts文件中不允许出现可执行的代码，只用于提供类型**\n  3. 用途：为 JS 提供类型信息\n\n- 总结：.ts 是 `implementation`(代码实现文件)；**.d.ts 是 declaration(类型声明文件)**\n- 如果要为 JS 库提供类型信息，要使用 `.d.ts` 文件\n\n## 类型声明文件的使用说明\n\n- 在使用 TS 开发项目时，类型声明文件的使用包括以下两种方式: \n  1. 使用已有的类型声明文件\n  2. 创建自己的类型声明文件\n\n使用已有的类型声明文件\n\n1. 内置类型声明文件\n2. 第三方库的类型声明文件\n3. 自己提供的\n\n## 内置类型声明文件\n\n- TS 为 JS 运行时可用的所有标准化内置 API 都提供了声明文件\n- 比如，在使用数组时，数组所有方法都会有相应的代码提示以及类型信息:\n\n```ts\nconst strs = [\'a\', \'b\', \'c\']\n// 鼠标放在 forEach 上查看类型\nstrs.forEach\n```\n\n- 实际上这都是 TS 提供的内置类型声明文件\n- 可以通过 Ctrl + 鼠标左键(Mac：Command + 鼠标左键)来查看内置类型声明文件内容\n- 比如，查看 forEach 方法的类型声明，在 VSCode 中会自动跳转到 `lib.es5.d.ts` 类型声明文件中\n- 当然，像 window、document 等 BOM、DOM API 也都有相应的类型声明(`lib.dom.d.ts`)\n\n## 第三方库的类型声明文件 \n\n- 目前，几乎所有常用的第三方库都有相应的类型声明文件\n- 第三方库的类型声明文件有两种存在形式:1 库自带类型声明文件 2 由 DefinitelyTyped 提供。 \n\n1. 库自带类型声明文件：比如，axios\n\n  - 查看 `node_modules/axios` 目录\n\n解释：这种情况下，正常导入该库，**TS 就会自动加载库自己的类型声明文件**，以提供该库的类型声明。\n\n2. 由 DefinitelyTyped 提供\n\n- DefinitelyTyped 是一个 github 仓库，用来提供高质量 TypeScript 类型声明\n- [DefinitelyTyped 链接](https://github.com/DefinitelyTyped/DefinitelyTyped/)\n- 可以通过 npm/yarn 来下载该仓库提供的 TS 类型声明包，这些包的名称格式为:`@types/*`\n- 比如，@types/react、@types/lodash 等\n- 说明：在实际项目开发时，如果你使用的第三方库没有自带的声明文件，VSCode 会给出明确的提示\n\n```ts\nimport _ from \'lodash\'\n\n// 在 VSCode 中，查看 \'lodash\' 前面的提示\n```\n\n- 解释：当安装 `@types/*` 类型声明包后，**TS 也会自动加载该类声明包**，以提供该库的类型声明\n- 补充：TS 官方文档提供了一个页面，可以来查询 @types/* 库\n- [@types/* 库](https://www.typescriptlang.org/dt)\n\n## 创建自己的类型声明文件\n\n1. 项目内共享类型\n2. 为已有 JS 文件提供类型声明\n\n### 项目内共享类型\n\n- 如果多个 .ts 文件中都用到同一个类型，此时可以创建 .d.ts 文件提供该类型，实现类型共享。\n- 操作步骤:\n  1. 创建 index.d.ts 类型声明文件。\n  2. 创建需要共享的类型，并使用 export 导出(TS 中的类型也可以使用 import/export 实现模块化功能)。\n  3. 在需要使用共享类型的 .ts 文件中，通过 import 导入即可(.d.ts 后缀导入时，直接省略)。\n\n### 为已有 JS 文件提供类型声明\n\n1. 在将 JS 项目迁移到 TS 项目时，为了让已有的 .js 文件有类型声明。 \n2. 成为库作者，创建库给其他人使用。\n\n- 注意:类型声明文件的编写与模块化方式相关，不同的模块化方式有不同的写法。但由于历史原因，JS 模块化的发展 经历过多种变化(AMD、CommonJS、UMD、ESModule 等)，而 TS 支持各种模块化形式的类型声明。这就导致 ，类型声明文件相关内容又多又杂。\n- 演示:基于最新的 ESModule(import/export)来为已有 .js 文件，创建类型声明文件。 \n\n### 类型声明文件的使用说明\n\n- 说明:TS 项目中也可以使用 .js 文件。\n- 说明:在导入 .js 文件时，TS 会自动加载与 .js 同名的 .d.ts 文件，以提供类型声明。\n- declare 关键字:用于类型声明，为其他地方(比如，.js 文件)已存在的变量声明类型，而不是创建一个新的变量。\n  1. 对于 type、interface 等这些明确就是 TS 类型的(只能在 TS 中使用的)，可以省略 declare 关键字。\n  2. 对于 let、function 等具有双重含义(在 JS、TS 中都能用)，应该使用 declare 关键字，明确指定此处用于类型声明。\n\n\n\n```jsx\nlet count = 10\nlet songName = \'痴心绝对\'\nlet position = {\n  x: 0,\n  y: 0\n}\n\nfunction add(x, y) {\n  return x + y\n}\n\nfunction changeDirection(direction) {\n  console.log(direction)\n}\n\nconst fomartPoint = point => {\n  console.log(\'当前坐标：\', point)\n}\n\nexport { count, songName, position, add, changeDirection, fomartPoint }\n\n```\n\n定义类型声明文件\n\n```jsx\ndeclare let count:number\n\ndeclare let songName: string\n\ninterface Position {\n  x: number,\n  y: number\n}\n\ndeclare let position: Position\n\ndeclare function add (x :number, y: number) : number\n\ntype Direction = \'left\' | \'right\' | \'top\' | \'bottom\'\n\ndeclare function changeDirection (direction: Direction): void\n\ntype FomartPoint = (point: Position) => void\n\ndeclare const fomartPoint: FomartPoint\n\nexport {\n  count, songName, position, add, changeDirection, FomartPoint, fomartPoint\n}\n```\n\n\n\n# 在现有项目中添加 TS\n\n- [CRA 添加 ts 文档](https://create-react-app.dev/docs/adding-typescript)\n- 如果要在现有的 JS 项目中，添加 TS，需要以下操作：\n\n1. 安装包：`yarn add typescript @types/node @types/react @types/react-dom @types/jest`\n2. 把 `jsconfig.json`改成 path.tsconfig.json\n4. 将原来通过 React 脚手架创建的 TS 项目中的 tsconfig.json 中的配置，拷贝到咱们自己的项目中\n5. 创建 `path.tsconfig.json` 文件，将原来 `jsconfig.json` 文件中的内容拿过来\n\n```json\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@scss/*\": [\"src/assets/styles/*\"]\n    }\n  }\n}\n\n```\n\n5. 在 `tsconfig.json` 中，添加以下配置：\n\n```json\n{\n  // 添加这一句\n  \"extends\": \"./path.tsconfig.json\",\n\n  \"compilerOptions\": {\n    ...\n  }\n}\n```\n\n6. 将通过 React 脚手架创建的 TS 项目中的 `src/react-app-env.d.ts` 拷贝到咱们自己项目的 src 目录下\n7. 重启项目\n\n## 说明\n\n1. 项目中使用 TS 时，既可以包含 js 文件，又可以包含 ts 文件\n  - `.js`、`.jsx`（使用 JS 时，React 组件对应的文件后缀）\n  - `.ts`、`.tsx`（使用 TS 时，React 组件对应的文件后缀）、`.d.ts`\n2. 在已有项目中，添加 TS 时的推荐模式\n  - 新的功能用 TS\n  - 已实现的功能，可以继续保持 JS 文件，慢慢修改为 TS 即可\n3. React 组件对应的文件后缀，修改为：`.tsx`\n4. 工具函数对应的文件后缀，修改为：`.ts` 或者为其添加类型声明文件 `.d.ts`\n\n\n\n# 项目改造\n\n## 改造建议\n\n1. 项目中使用 TS 时，既可以包含 js 文件，又可以包含 ts 文件\n\n  - `.js`、`.jsx`（使用 JS 时，React 组件对应的文件后缀）\n  - `.ts`、`.tsx`（使用 TS 时，React 组件对应的文件后缀）、`.d.ts`\n\n2. 在已有项目中，添加 TS 时的推荐模式\n\n  - 新的功能用 TS\n  - 已实现的功能，可以继续保持 JS 文件，慢慢修改为 TS 即可\n\n3. React 组件对应的文件后缀，修改为：`.tsx`\n4. 工具函数对应的文件后缀，修改为：`.ts` 或者为其添加类型声明文件 `.d.ts`\n\n## 修改入口文件\n\n### index.ts\n\n- 直接将文件后缀修改为 index.tsx 即可\n- 需要重启项目\n\n## 修改App.js\n\n+ 讲App.js 改成app.tsx即可\n+ 需要安装react-router-dom的类型\n\n```tsx\nyarn add @types/react-router-dom\n```\n\n+ 重启\n\n# utils工具函数改造\n\n## history.js\n\n不需要改造，直接把js改成ts即可\n\n## storage.js\n\n+ 讲js改成ts\n+ 修改getTokenInfo\n\n```jsx\n/**\n * 从本地缓存中获取 Token 信息\n * JSON.parse() 要求参数必须是字符串\n * localStorage.getItem() 返回值可能是字符串，也可能是null，所以会报错\n */\nexport const getTokenInfo = () => {\n  return JSON.parse(localStorage.getItem(TOKEN_KEY) || \'{}\')\n}\n```\n\n### 非空断言\n\n[Non-null assertion operator](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator)\n\n- TS 中提供一个运算符：`!` `非空断言`\n  - 如果一个值，它的类型可能是 null 或 undefined，但是，我们在使用时又很确定它的值一定不是 null 或 unde，此时，就可以通过 `非空断言` 来告诉 TS 听哥的，哥很确定它的不是 null 或 undefined\n- 注意：**这个操作是风险的**，非空断言，仅仅是让 TS 中的类型检查不再校验 null 或 undefined，但是，如果它的值真的是 null 或 undefined，代码会在运行时报错！！！\n\n### 整体修改\n\n```jsx\n// 用户 Token 的本地缓存键名\nconst TOKEN_KEY = \'geek-itcast-21\'\nconst CHANNEL_KEY = \'geek-itcast-21-channels\'\ntype Token = {\n  token: string\n  refresh_token: string\n}\ntype Channels = {\n  id: number\n  name: string\n}[]\n/**\n * 从本地缓存中获取 Token 信息\n * JSON.parse() 要求参数必须是字符串\n * localStorage.getItem() 返回值可能是字符串，也可能是null，所以会报错\n */\nexport const getTokenInfo = (): Token => {\n  return JSON.parse(localStorage.getItem(TOKEN_KEY)!) || {}\n}\n\n/**\n * 将 Token 信息存入缓存\n * @param {Object} tokenInfo 从后端获取到的 Token 信息\n */\nexport const setTokenInfo = (tokenInfo: Token): void => {\n  localStorage.setItem(TOKEN_KEY, JSON.stringify(tokenInfo))\n}\n\n/**\n * 删除本地缓存中的 Token 信息\n */\nexport const removeTokenInfo = () => {\n  localStorage.removeItem(TOKEN_KEY)\n}\n\n/**\n * 判断本地缓存中是否存在 Token 信息\n */\nexport const hasToken = (): boolean => {\n  return !!getTokenInfo().token\n}\n\n/**\n * 保存频道数据到本地\n * @param {*} channels\n */\nexport const setLocalChannels = (channels: Channels): void => {\n  localStorage.setItem(CHANNEL_KEY, JSON.stringify(channels))\n}\n\n/**\n * 获取本地的频道数据，，，，，，，如果没有数据，不要默认为空数组\n * @returns\n */\nexport const getLocalChannels = (): Channels => {\n  return JSON.parse(localStorage.getItem(CHANNEL_KEY)!)\n}\n\n/**\n * 删除本地的频道数据\n */\nexport const removeLocalChannels = (): void => {\n  localStorage.removeItem(CHANNEL_KEY)\n}\n\n```\n\n## request.js改造\n\n讲js改成ts即可\n\n```tsx\nasync (err: AxiosError<{ message: string }>) => {\n    // 如果因为网络原因，response没有，给提示消息\n    if (!err.response) {\n      Toast.info(\'网络繁忙，请稍后重试\')\n      return Promise.reject(err)\n    }\n\n```\n\n\n\n# 通用组件改造\n\n## Icon组件修改\n\n```jsx\nimport React from \'react\'\nimport classNames from \'classnames\'\n\ntype Props = {\n  type: string\n  className?: string\n  onClick?: () => void\n}\nfunction Icon({ type, className, ...rest }: Props) {\n  return (\n    <svg {...rest} className={classNames(\'icon\', className)} aria-hidden=\"true\">\n      <use xlinkHref={`#${type}`}></use>\n    </svg>\n  )\n}\n\nexport default Icon\n\n```\n\n## typescript中ref的使用\n\n```jsx\nconst imgRef = useRef<HTMLImageElement>(null)\n\nconst current = imgRef.current!\n```\n\n## Img懒加载组件修改\n\n```jsx\nimport classnames from \'classnames\'\nimport { useEffect, useRef, useState } from \'react\'\nimport Icon from \'../Icon\'\nimport styles from \'./index.module.scss\'\ntype Props = {\n  src: string\n  className?: string\n  alt?: string\n}\nconst Image = ({ className, src, alt }: Props) => {\n  const imgRef = useRef<HTMLImageElement>(null)\n  // 控制是否在加载\n  const [loading, setLoading] = useState(true)\n  // 控制是否加载失败\n  const [error, setError] = useState(false)\n\n  // 加载成功\n  const onLoad = () => {\n    setError(false)\n    setLoading(false)\n  }\n  const onError = () => {\n    setLoading(false)\n    setError(true)\n  }\n  useEffect(() => {\n    // 监听图片\n    const observer = new IntersectionObserver(([{ isIntersecting }]) => {\n      if (isIntersecting) {\n        // 图片在可视区\n        const current = imgRef.current!\n        current.src = current.dataset.src!\n        // 取消监听\n        observer.unobserve(current)\n      }\n    })\n    observer.observe(imgRef.current!)\n  }, [])\n  return (\n    <div className={classnames(styles.root, className)}>\n      {/* 加载中 */}\n      {loading && (\n        <div className=\"image-icon\">\n          <Icon type=\"iconphoto\" />\n        </div>\n      )}\n\n      {/* 加载出错时显示的内容 */}\n      {error && (\n        <div className=\"image-icon\">\n          <Icon type=\"iconphoto-fail\" />\n        </div>\n      )}\n\n      <img\n        alt={alt}\n        ref={imgRef}\n        data-src={src}\n        onLoad={onLoad}\n        onError={onError}\n      />\n    </div>\n  )\n}\n\nexport default Image\n\n```\n\n## Input组件修改\n\n+ 基本改造\n\n```jsx\nimport React, { useEffect, useRef } from \'react\'\nimport styles from \'./index.module.scss\'\nimport classNames from \'classnames\'\ninterface Props {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n}\nexport default function Input({\n  extra,\n  onExtraClick,\n  className,\n  autoFocus,\n  ...rest\n}: Props) {\n  // focus\n  const inputRef = useRef<HTMLInputElement>(null)\n  useEffect(() => {\n    if (autoFocus) {\n      inputRef.current?.focus()\n    }\n  }, [autoFocus])\n  return (\n    <div className={styles.root}>\n      <input\n        ref={inputRef}\n        className={classNames(\'input\', className)}\n        {...rest}\n      />\n      {extra ? (\n        <div className=\"extra\" onClick={onExtraClick}>\n          {extra}\n        </div>\n      ) : null}\n    </div>\n  )\n}\n\n```\n\n+ 剩余参数的支持\n\n> InputHTMLAttributes中包含了Input框所有能够支持的属性\n\n```jsx\ninterface Props extends InputHTMLAttributes<HTMLInputElement> {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n}\n```\n\n+ 使用type替代interface\n\n```jsx\ntype Props = {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n  type?: \'input\' | \'password\'\n} & InputHTMLAttributes<HTMLInputElement>\n```\n\nTS 中的 &（交叉类型）\n\nhttps://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types\n\n- 交叉类型：`&`\n  - 作用：可以理解为取多个类型的并集\n- 联想到了，另一个类型：`|` 联合类型\n\n```ts\n// | 在 TS 中表示： number 和 string 两者中出现哪一个都行\ntype NumStr = number | string\n\ntype InputProps = {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  dom?: React.RefObject<HTMLInputElement>\n}\n\n// & 在 TS 中表示： 最终的类型两者都有\ntype Props = InputProps & InputHTMLAttributes<HTMLInputElement>\n```\n\n交叉类型需要注意的地方：同名的属性容易冲突\n\n使用omit优化\n\n```tsx\ntype Props = Omit<\n  InputHTMLAttributes<HTMLInputElement>,\n  \'type\' | \'autoFocus\'\n> & {\n  extra?: string\n  onExtraClick?: () => void\n  className?: string\n  autoFocus?: boolean\n  type?: \'text\' | \'password\'\n}\n```\n\n## Textarea组件改造\n\n```jsx\nimport classNames from \'classnames\'\nimport { TextareaHTMLAttributes } from \'hoist-non-react-statics/node_modules/@types/react\'\nimport React, { useEffect, useRef, useState } from \'react\'\nimport styles from \'./index.module.scss\'\ntype Props = Omit<\n  TextareaHTMLAttributes<HTMLTextAreaElement>,\n  \'maxLength\' | \'value\' | \'onChange\'\n> & {\n  maxLength?: number\n  className?: string\n  value: string\n  onChange: (e: React.ChangeEvent<HTMLTextAreaElement>) => void\n}\nexport default function Textarea({\n  maxLength = 100,\n  className,\n  value,\n  onChange,\n  ...rest\n}: Props) {\n  const [content, setContent] = useState(value || \'\')\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setContent(e.target.value)\n\n    onChange && onChange(e)\n  }\n  const textRef = useRef<HTMLTextAreaElement>(null)\n  useEffect(() => {\n    textRef.current!.focus()\n    textRef.current!.setSelectionRange(-1, -1)\n  }, [])\n  return (\n    <div className={styles.root}>\n      {/* 文本输入框 */}\n      <textarea\n        {...rest}\n        className={classNames(\'textarea\', className)}\n        maxLength={maxLength}\n        value={value}\n        onChange={handleChange}\n        ref={textRef}\n      />\n\n      {/* 当前字数/最大允许字数 */}\n      <div className=\"count\">\n        {content.length}/{maxLength}\n      </div>\n    </div>\n  )\n}\n\n```\n\n## NavBar组件改造\n\n```jsx\nimport Icon from \'@/components/Icon\'\nimport styles from \'./index.module.scss\'\nimport { useHistory } from \'react-router\'\nimport classNames from \'classnames\'\nimport { ReactNode } from \'react\'\n// import { withRouter } from \'react-router-dom\'\n// 1. withRouter的使用\n// history match location: 这个组件必须是通过路由配置的  <Route></Route>\n// 自己渲染的组件，无法获取到路由信息  <NavBar></NavBar>\n\n// 2. 路由提供了几个和路由相关的hook\n// useHistory  useLocation  useParams\ntype Props = {\n  children: string | ReactNode\n  extra?: string\n  onLeftClick?: () => void\n  className?: string\n}\nfunction NavBar({ children, extra, onLeftClick, className }: Props) {\n  const history = useHistory()\n  const back = () => {\n    console.log(\'123\')\n    // 跳回上一页\n    if (onLeftClick) {\n      onLeftClick()\n    } else {\n      history.go(-1)\n    }\n  }\n  return (\n    <div className={classNames(styles.root, className)}>\n      {/* 后退按钮 */}\n      <div className=\"left\">\n        <Icon type=\"iconfanhui\" onClick={back} />\n      </div>\n      {/* 居中标题 */}\n      <div className=\"title\">{children}</div>\n\n      {/* 右侧内容 */}\n      <div className=\"right\">{extra}</div>\n    </div>\n  )\n}\n\nexport default NavBar\n\n```\n\n## AuthRoute组件改造\n\nhttps://stackoverflow.com/questions/53104165/implement-react-router-privateroute-in-typescript-project/53111155#\n\n```jsx\nimport { hasToken } from \'@/utils/storage\'\nimport { Route, Redirect, useLocation, RouteProps } from \'react-router-dom\'\ninterface PrivateRouteProps extends RouteProps {\n  component: React.ComponentType<any>\n}\nexport default function AuthRoute(props: PrivateRouteProps) {\n  const { component: Component, ...rest } = props\n  const location = useLocation()\n  // console.log(location)\n  return (\n    <Route\n      {...rest}\n      render={() => {\n        if (hasToken()) {\n          return <Component></Component>\n        } else {\n          return (\n            <Redirect\n              to={{\n                pathname: \'/login\',\n                state: {\n                  // 从哪儿来的\n                  from: location.pathname,\n                },\n              }}\n            ></Redirect>\n          )\n        }\n      }}\n    ></Route>\n  )\n}\n\n```\n\n# 页面改造\n\n## Layout组件\n\n直接把js改成tsx\n\n# Login组件\n\n### location的处理\n\n![image-20210917205318957](images/image-20210917205318957.png)\n\n+ 关于useLocation的使用\n\n```jsx\ntype LocationState = {\n  from: string\n}\n\nconst location = useLocation<LocationState>()\n```\n\nhttps://stackoverflow.com/questions/61668623/react-typescript-correct-type-for-uselocation-from-react-router-dom\n\n### redux-action修改\n\n+ 修改action/login.js\n\n```jsx\nimport request from \'@/utils/request\'\nimport { setTokenInfo, removeTokenInfo } from \'@/utils/storage\'\nimport { Dispatch } from \'redux\'\ntype Token = {\n  token: string\n  refresh_token: string\n}\nexport const sendCode = (mobile: string) => {\n  return async () => {\n    // 发送请求\n    await request({\n      url: \'/sms/codes/\' + mobile,\n      method: \'get\',\n    })\n  }\n}\n\nexport const saveToken = (payload: Token) => {\n  return {\n    type: \'login/token\',\n    payload,\n  }\n}\n\n/**\n * 登录功能\n * @param {*} data\n * @returns\n */\n\nexport const login = (data: { mobile: string; code: string }) => {\n  return async (dispatch: Dispatch) => {\n    const res = await request({\n      method: \'post\',\n      url: \'/authorizations\',\n      data,\n    })\n    // 保存token到redux中\n    dispatch(saveToken(res.data))\n    // 保存到本地\n    setTokenInfo(res.data)\n  }\n}\n\n/**\n * 退出\n * @returns\n */\nexport const logout = () => {\n  return (dispatch: Dispatch) => {\n    removeTokenInfo()\n    dispatch({\n      type: \'login/logout\',\n    })\n  }\n}\n\n```\n\n+ Dispatch的分析\n\n索引签名\n\n- [索引签名](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)\n- 语法：`[key: string]: any`\n- 应用场景：我要使用一个对象类型，但是，我不确定对象中有什么属性，此时，就可以使用索引签名类型了\n\n```ts\n// 可以将这个内容分为两部分，\n//  冒号前面 `[extraProps: string]` 表示对象中的属性类型 - 键\n//  冒号后面 `any` 表示属性值的类型 - 值\n\n// [extraProps: string] 表示：\n//  extraProps 是一个任意合法属性名称，比如，可以叫：k 或 key\n//  : string 表示对象属性的类型是 字符串 类型\n\n// 注意：一个对象，它的属性类型可以是： string | number | symbol\ninterface AnyAction {\n  [extraProps: string]: any\n}\n\nexport interface AnyAction extends Action {\n  // Allows any extra properties to be defined in an action.\n  [extraProps: string]: any\n}\n```\n\n\n\n### redux-reducer修改\n\n```jsx\ntype Token = {\n  token: string\n  refresh_token: string\n}\ntype ActionType = {\n  type: \'login/token\' | \'login/logout\'\n  payload: Token\n}\nconst initValue: Token = {\n  token: \'\',\n  refresh_token: \'\',\n}\nexport default function reducer(state = initValue, action: ActionType) {\n  const { type, payload } = action\n  if (type === \'login/token\') {\n    return payload\n  }\n  if (type === \'login/logout\') {\n    return {}\n  }\n  return state\n}\n```\n\n### 类型提取\n\n+ types.d.ts\n\n```jsx\n/**\n * token的类型\n */\nexport type Token = {\n  token: string\n  refresh_token: string\n}\n\n```\n\n\n\n\n\n# Profile组件改造\n\n## 修改redux-reducer\n\n```jsx\ntype User = {\n  id: string\n  name: string\n  photo: string\n  art_count: number\n  follow_count: number\n  fans_count: number\n  like_count: number\n}\n\ntype Profile = {\n  id: string\n  photo: string\n  name: string\n  mobile: string\n  gender: number\n  birthday: string\n}\n\ntype InitType = {\n  user: User\n  profile: Profile\n}\n\ntype ProfileAction =\n  | {\n      type: \'profile/user\'\n      payload: User\n    }\n  | {\n      type: \'profile/profile\'\n      payload: Profile\n    }\n\nconst initValue: InitType = {\n  user: {},\n  profile: {},\n} as InitType\n\n/**\n * 处理个人信息的reducer\n * @param {*} state\n * @param {*} action\n * @returns\n */\nexport default function reducer(state = initValue, action: ProfileAction) {\n  // const { type, payload } = action\n  if (action.type === \'profile/user\') {\n    return {\n      ...state,\n      user: action.payload,\n    }\n  }\n  if (action.type === \'profile/profile\') {\n    return {\n      ...state,\n      profile: action.payload,\n    }\n  }\n  return state\n}\n\n```\n\n\n\n## 修改redux-action的修改\n\n```jsx\nimport http from \'@/utils/request\'\nimport { User, Profile, ProfileAction } from \'../reducers/profile\'\nimport { Dispatch } from \'redux\'\n/**\n * 保存用户信息\n * @param {*} payload\n * @returns\n */\n// actionCreator: 创建action  必须要符合 ProfileAction类型\nexport const saveUser = (payload: User): ProfileAction => {\n  return {\n    type: \'profile/user\',\n    payload: payload,\n  }\n}\n\n/**\n * 获取用户信息\n * @returns Promise\n */\nexport const getUser = () => {\n  return async (dispatch: Dispatch) => {\n    const res = await http.get(\'/user\')\n    dispatch(saveUser(res.data))\n  }\n}\n\nexport const saveProfile = (payload: Profile): ProfileAction => {\n  return {\n    type: \'profile/profile\',\n    payload,\n  }\n}\n\nexport const getProfile = () => {\n  return async (dispatch: Dispatch) => {\n    const res = await http.get(\'/user/profile\')\n    dispatch(saveProfile(res.data))\n  }\n}\n\n// 返回一个全部属性变成可选的类型\ntype PartialProfile = Partial<Profile>\n// 修改用户的信息\n// dispatch: Dispatch类型，，，参数必须符合Action类型 {type: T}\nexport const updateProfile = (data: PartialProfile) => {\n  return async (dispatch: any) => {\n    await http.patch(\'/user/profile\', data)\n    dispatch(getProfile())\n  }\n}\n\nexport const updatePhoto = (fd: FormData) => {\n  return async (dispatch: any) => {\n    await http.patch(\'/user/photo\', fd)\n    dispatch(getProfile())\n  }\n}\n\n```\n\n\n\n## 泛型工具类型 - ReturnType\n\nhttps://stackoverflow.com/questions/57472105/react-redux-useselector-typescript-type-for-state/57472389\n\n- 泛型：\n\n```ts\nfunction id<Type>(value: Type): Type {\n  return value\n}\n\n// 尖括号中出现的是 类型\nid<number>(1)\nid<string>(1)\n```\n\n- ReturnType\n  - 作用：**用来获取函数返回值的类型**\n\n```ts\nconst fn = () => 10\n\n// typeof fn 的结果： () => number\n// R1 => number\ntype R1 = ReturnType<typeof fn>\n// type R1 = ReturnType<() => number>\n```\n\n## 获取redux状态的类型\n\nhttps://redux.js.org/usage/usage-with-typescript\n\n+ 讲store/index.js修改为store/index.ts\n\n```jsx\n// 参数1：reducer\n// 参数2：指定store的初始值\n// 参数3：指定中间件\nconst store = createStore(\n  reducer,\n  {\n    login: getTokenInfo(),\n  },\n  composeWithDevTools(applyMiddleware(thunk))\n)\n\nexport type RootState = ReturnType<typeof store.getState>\n```\n\n## useSelector 的类型\n\n```ts\n// 在 TS 中 useSelector 是一个泛型函数，并且它有两个泛型变量，分别是：\n// 1 整个Redux应用的状态类型\n// 2 当前要获取的状态类型\n// 因此，在使用的时候，需要传入两个 泛型变量：\n// 比如，以下代码中，\n// 第一个传入了 AppState 也就是整个 Redux 应用的状态类型\n// 第二个传入了 AppState[\'profile\'] 也就是当前要获取的 profile 状态的类型\n\nconst user = useSelector<RootState, RootState[\'profile\'][\'user\']>(\n  (state) => state.profile.user\n)\n\n\n// 泛型参数1：指定state的类型\n// 泛型参数2：指定返回值的类型\nconst user = useSelector((state: RootState) => state.profile.user)\n```\n\n\n\n## TS 中的索引查询类型\n\n- 语法：`对象类型[键]`\n- 作用：查询 对象类型 中某个属性对应的类型\n\n```ts\ntype A = {\n  name: string\n}\n\n// NameType => string\ntype NameTyep = A[\'name\']\n```\n\n\n\n# Home组件的修改\n\n## 修改home组件-reducer\n\n```jsx\nimport {\n  SAVE_ALL_CHANNELS,\n  SAVE_ARTICLE_LIST,\n  SAVE_CHANNELS,\n  SAVE_MORE_ARTICLE_LIST,\n} from \'../action_types/home\'\n\ntype Channel = {\n  id: number\n  name: string\n}\n\ntype MoreAction = {\n  visible: boolean\n  articleId: string\n  channelId: string\n}\n\ntype Ariticle = {\n  art_id: string\n  title: string\n  aut_id: string\n  aut_name: string\n  comm_count: string\n  pubdate: string\n  cover: {\n    type: string\n    images: string[]\n  }\n}\n\ntype Articles = {\n  [index: number]: {\n    timestamp: string\n    list: Ariticle[]\n  }\n}\ntype HomeType = {\n  userChannels: Channel[]\n  allChannels: Channel[]\n  moreAction: MoreAction\n  articles: Articles\n}\n\nconst initValue: HomeType = {\n  userChannels: [],\n  allChannels: [],\n  // 存储所有的文章列表\n  articles: {},\n  moreAction: {\n    visible: false,\n    articleId: \'\',\n    channelId: \'\',\n  },\n} as HomeType\nexport default function reducer(state = initValue, action) {}\n```\n\n## 修改home组件-reducer的修改-完成\n\n```jsx\nimport {\n  SAVE_ALL_CHANNELS,\n  SAVE_ARTICLE_LIST,\n  SAVE_CHANNELS,\n  SAVE_MORE_ARTICLE_LIST,\n} from \'../action_types/home\'\n\ntype Channel = {\n  id: number\n  name: string\n}\n\ntype MoreAction = {\n  visible: boolean\n  articleId: string\n  channelId: number\n}\n\ntype Ariticle = {\n  art_id: string\n  title: string\n  aut_id: string\n  aut_name: string\n  comm_count: string\n  pubdate: string\n  cover: {\n    type: string\n    images: string[]\n  }\n}\n\ntype Articles = {\n  [index: number]: {\n    timestamp: string\n    list: Ariticle[]\n  }\n}\ntype HomeType = {\n  userChannels: Channel[]\n  allChannels: Channel[]\n  moreAction: MoreAction\n  articles: Articles\n}\n\nconst initValue: HomeType = {\n  userChannels: [],\n  allChannels: [],\n  // 存储所有的文章列表\n  articles: {},\n  moreAction: {\n    visible: false,\n    articleId: \'\',\n    channelId: -1,\n  },\n} as HomeType\n\ntype ActionType =\n  | {\n      type: \'home/saveChannels\'\n      payload: Channel[]\n    }\n  | {\n      type: \'home/saveAllChannels\'\n      payload: Channel[]\n    }\n  | {\n      type: \'home/saveArticleList\'\n      payload: {\n        channelId: number\n        timestamp: string\n        list: Ariticle[]\n      }\n    }\n  | {\n      type: \'home/saveMoreArticleList\'\n      payload: {\n        channelId: number\n        timestamp: string\n        list: Ariticle[]\n      }\n    }\n  | {\n      type: \'home/setMoreAction\'\n      payload: MoreAction\n    }\nexport default function reducer(state = initValue, action: ActionType) {\n  // const { type, payload } = action\n  switch (action.type) {\n    case \'home/saveChannels\':\n      return {\n        ...state,\n        userChannels: action.payload,\n      }\n    case \'home/saveAllChannels\':\n      return {\n        ...state,\n        allChannels: action.payload,\n      }\n    case \'home/saveArticleList\':\n      const { list, timestamp, channelId } = action.payload\n\n      return {\n        ...state,\n        articles: {\n          ...state.articles,\n          [channelId]: {\n            timestamp: timestamp,\n            // 如果是loadMore，追加数据，否则，覆盖数据\n            list: list,\n          },\n        },\n      }\n    case \'home/saveMoreArticleList\':\n      // const oldList = state.articles[action.payload.channelId].list\n      return {\n        ...state,\n        articles: {\n          ...state.articles,\n          [action.payload.channelId]: {\n            timestamp: action.payload.timestamp,\n            list: [\n              ...state.articles[action.payload.channelId].list,\n              ...action.payload.list,\n            ],\n          },\n        },\n      }\n    case \'home/setMoreAction\': {\n      return {\n        ...state,\n        moreAction: action.payload,\n      }\n    }\n    default:\n      return state\n  }\n}\n\n```\n\n## 解决问题：request中dispatch的问题\n\n原因： saveToken没有指定返回值类型，\n\n```jsx\n\n// actionCreator\nexport const saveToken = (payload: Token) => {\n  return {\n    type: \'login/token\',\n    payload,\n  }\n}\n```\n\n把type推断为string类型   string类型无法常量类型赋值，所以报错了\n\n解决方案：\n\n```js\n// actionCreator\nexport const saveToken = (payload: Token) => {\n  return {\n    type: \'login/token\' as const,\n    payload,\n  }\n}\n```\n\n方案2：\n\n```jsx\n// actionCreator\nexport const saveToken = (payload: Token): LoginAction => {\n  return {\n    type: \'login/token\',\n    payload,\n  }\n}\n\n```\n\n## 解决问题：logout的错误\n\n原因：store.dispatch的参数必须是一个对象，且要有type属性\n\n```jsx\n/**\n * 退出\n * @returns\n */\nexport const logout = (payload: Token) => {\n  return {\n    type: \'login/logout\' as const,\n    payload,\n  }\n}\n\n\n// 移除本地的token\nremoveTokenInfo()\nstore.dispatch(\n  logout({\n    token: \'\',\n    refresh_token: \'\',\n  })\n)\n```\n\n## RootThunkAction的使用\n\nhttps://redux.js.org/usage/usage-with-typescript#type-checking-redux-thunks\n\n场景：\n\n 我们如果需要使用redux-thunk的action，需要指定两个参数的类型，dispatch和getState的类型。\n\nredux-thunk中间件帮助我们提供了一个thunkAction的类型。\n\n```jsx\n// 获取RootState的类型‘\n// typeof: 获取store.getState的类型\n// ReturnType 获取返回值的类型\nexport type RootState = ReturnType<typeof store.getState>\n\n// R：thunk的action的返回类型  void Promise<void>\n// S: 需要指定个getState的返回类型  RootState\n// E: extra: 额外的参数 any\n// A: 需要指定Action的类型 Action AnyAction [extraProps: string]: any\n// ThunkAction<R, S, E, A>\nexport type RootThunkAction = ThunkAction<\n  Promise<void>,\n  RootState,\n  unknown,\n  AnyAction\n>\n\n```\n\n\n\n以后，只要是redux-thunk的action的类型，我们只需要指定返回类型为RootThunkAction类型即可，不需要指定dispatch和getState的类型\n\n```jsx\n/**\n * 获取用户的频道\n * @returns\n */\nexport const getUserChannels = (): RootThunkAction => {\n  return async (dispatch) => {\n    // 1. 判断用户是否登录\n    if (hasToken()) {\n      const res = await request.get(\'/user/channels\')\n      dispatch(saveUserChannels(res.data.channels))\n    } else {\n      // 2. 没有token,从本地获取频道数据\n      const channels = getLocalChannels()\n      if (channels) {\n        // 没有token，但本地有channels数据\n        dispatch(saveUserChannels(channels))\n      } else {\n        // 没有token, 且本地没有channels数据\n        const res = await request.get(\'/user/channels\')\n        dispatch(saveUserChannels(res.data.channels))\n        // 保存到本地\n        setLocalChannels(res.data.channels)\n      }\n    }\n  }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', NULL, 1, NULL, NULL, '2024-03-18 00:21:18', '2024-03-18 00:21:18', 10, 10);
INSERT INTO `articles` VALUES (3, '极客园PC', 11, '[39, 45, 52, 53, 58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/7b0285e8-49d5-4e9f-af5d-b8fdcf882edc.jpeg', '极客园PC API', '# 极客园PC\n\n## 项目介绍\n\n### 资料\n\n- 短信接收&M端演示：http://geek.itheima.net/\n- PC 端接口文档：http://geek.itheima.net/api-pc.html\n\n### 项目介绍\n\n>「极客园」对标`CSDN`、`博客园`等竞品，致力成为更加贴近年轻 IT 从业者（学员）的科技资讯类应用  \n> 产品关键词：IT、极客、活力、科技、技术分享、前沿动态、内容社交  \n> 用户特点：年轻有活力，对IT领域前言科技信息充满探索欲和学习热情\n\n- 极客园 PC 端项目：个人自媒体管理端\n- 项目演示\n- 项目功能，包括\n  - 登录\n  - 首页\n  - 内容（文章）管理\n    - 文章列表\n    - 发布文章\n    - 修改文章\n- 技术栈：\n  - `react` v17.0.2 / `react-dom` v17.0.2\n  - ajax请求库：`axios`\n  - 路由：`react-router-dom` 以及 `history`\n  - 富文本编辑器：`react-quill`\n  - CSS 预编译器：`sass`\n  - UI 组件库：`antd` v4\n  - 项目搭建：React 官方脚手架 `create-react-app`\n\n## 项目搭建\n\n### 创建项目\n\n1. 使用 React CLI 搭建项目：`npx create-react-app geek-pc-21`\n2. 进入项目根目录：`cd geek-pc-21`\n3. 启动项目：`yarn start`\n4. 调整项目目录结构：\n\n```tree\n/src\n  /assets         项目资源文件，比如，图片 等\n  /components     通用组件\n  /pages          页面\n  /utils          工具，比如，token、axios 的封装等、\n  /api            封装接口\n  \n  App.js          根组件\n  index.css       全局样式\n  index.js        项目入口\n```\n\n### 使用git管理项目\n\nhttps://gitee.com/hucongcong/geek-pc-hz21/tree/master\n\n### 配置基础路由\n\n+ 安装路由：`yarn add react-router-dom`\n\n+ 在 pages 目录中创建两个页面：Login、Layout\n\n`src/pages/Layout/index.js`\n\n```jsx\nimport { Component } from \'react\'\n\nclass Layout extends Component {\n  render() {\n    return <div className=\"layout\">首页布局</div>\n  }\n}\n\nexport default Layout\n\n```\n\n`src/pages/Login/index.js`\n\n```jsx\nimport { Component } from \'react\'\n\nclass Login extends Component {\n  render() {\n    return <div className=\"login\">登录页</div>\n  }\n}\n\nexport default Login\n\n```\n\n+ 在 App 组件中，导入路由组件以及两个页面组件，配置路由规则\n\n```js\n// 导入路由\nimport {\n  BrowserRouter as Router,\n  Route,\n  Switch,\n  Redirect,\n} from \'react-router-dom\'\n\n// 导入页面组件\nimport Login from \'./pages/Login\'\nimport Layout from \'./pages/Layout\'\n\n// 配置路由规则\nfunction App() {\n  return (\n    <Router>\n      <div className=\"App\">\n        {/* 路由规则 */}\n        <Switch>\n          <Redirect exact from=\"/\" to=\"/home\"></Redirect>\n          <Route path=\"/home\" component={Layout}></Route>\n          <Route path=\"/login\" component={Login}></Route>\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default App\n```\n\n+ 点击http://localhost:3000/login测试\n\n### 组件库 - antd\n\n[Ant Design](https://ant.design/index-cn)\n\n[antd PC 端组件库文档](https://ant.design/docs/react/introduce-cn)\n\n> `antd` 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。\n>\n> **开箱即用**\n\n1. 安装：`yarn add antd`\n2. 使用：\n\n```js\n// 1 在 index.js 中导入 antd 的样式文件\nimport \'antd/dist/antd.css\'\n\n// 2 在 Login 页面组件中，使用 antd 的 Button 组件\nimport { Button } from \'antd\'\n\nconst Login = () => (\n  <div>\n    <Button type=\"primary\">Button</Button>\n  </div>\n)\n```\n\n\n## 项目功能 - 登录  \n\n功能如下：\n\n1. 搭建登录页面结构\n2. 登录表单校验\n3. 登录逻辑\n4. 封装处理 token、axios 的工具函数\n5. 登录访问控制\n\n![image-20210824155646620](https://gitee.com/qarabala/jikeyuanpc-docs/raw/master/mds/https://gitee.com/qarabala/jikeyuanpc-docs/raw/master/mds/images/image-20210824155646620.png)\n\n### 创建git分支\n\n### 基本结构\n\n+ Card组件的使用\n\n```jsx\nimport { Card } from \'antd\'\n\nclass Login extends Component {\n  render() {\n    return (\n      <div className=\"login\">\n        <Card className=\"login-container\">\n          <p>Card content</p>\n          <p>Card content</p>\n          <p>Card content</p>\n        </Card>\n      </div>\n    )\n  }\n}\n\n```\n\n+ 准备样式`src/pages/Login/index.css`\n\n```css\n.login {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  background-image: url(../../assets/login.png);\n}\n\n.login-container {\n  width: 440px;\n  height: 360px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n}\n\n```\n\n+ 准备logo\n\n```diff\n+ import logo from \'../../assets/logo.png\'\nclass Login extends Component {\n  render() {\n    return (\n      <div className=\"login\">\n        <Card className=\"login-container\">\n+          <img className=\"login-logo\" src={logo} alt=\"\" />\n        </Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 准备logo的样式\n\n```css\n.login-logo {\n  width: 200px;\n  height: 60px;\n  display: block;\n  margin: 0 auto 20px;\n}\n```\n\n### 绝对路径的使用\n\n+ 官网文档：<https://facebook.github.io/create-react-app/docs/importing-a-component#absolute-imports>\n+ 在根目录新建`jsconfig.json`文件\n+ 配置以下内容\n\n```js\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \"src\"\n  },\n  \"include\": [\"src\"]\n}\n```\n\n+ 使用绝对路径\n\n```js\nimport logo from \'assets/logo.png\'\n\n相当于\n\'src/assets/logo.png\'\n```\n\n+ `重启项目`\n\n### sass的使用\n\n在react脚手架中已经有了sass的配置，因此只需要安装sass的依赖包，就可以直接使用sass了\n\n+ 安装sass依赖包\n\n```js\nyarn add sass -D\n```\n\n+ 把`index.css`改成`index.scss`\n+ 导入`index.scss`文件\n\n**注意：如果使用了scss，scss中使用图片的绝对路径的时候需要加上~**\n\n```css\nbackground-image: url(~assets/login.png);\n```\n\n### 登录表单的使用\n\n> 根据antd的表单组件进行修改https://ant.design/components/form-cn/#API\n\n```jsx\nclass Login extends Component {\n  render() {\n    return (\n      <div className=\"login\">\n        <Card className=\"login-container\">\n          <img className=\"login-logo\" src={logo} alt=\"\" />\n          {/* 表单 */}\n          <Form name=\"basic\">\n            <Form.Item name=\"username\">\n              <Input placeholder=\"请输入手机号\" />\n            </Form.Item>\n\n            <Form.Item name=\"password\">\n              <Input placeholder=\"请输入验证码\" />\n            </Form.Item>\n\n            <Form.Item name=\"remember\" valuePropName=\"checked\">\n              <Checkbox>我已阅读并同意[用户协议]和[隐私条款]</Checkbox>\n            </Form.Item>\n\n            <Form.Item>\n              <Button type=\"primary\" htmlType=\"submit\" block>\n                登录\n              </Button>\n            </Form.Item>\n          </Form>\n        </Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 调整表单控件的大小\n\n```jsx\n<Form name=\"basic\" size=\"large\">\n```\n\n+ 设置选中后的样式\n\n```css\n.ant-checkbox-wrapper-checked span {\n  color: #1890ff;\n}\n\n```\n\n### 登录表单校验\n\n```js\n<Form.Item\n  name=\"username\"\n  rules={[\n    {\n      pattern: /^1[3-9]\\d{9}$/,\n      message: \'手机号码格式不对\',\n    },\n    { required: true, message: \'请输入手机号\' },\n  ]}\n>\n  <Input placeholder=\"请输入手机号\" />\n</Form.Item>\n\n<Form.Item\n  name=\"password\"\n  rules={[\n    {\n      pattern: /^\\d{6}$/,\n      message: \'验证码格式不对\',\n    },\n    { required: true, message: \'请输入验证码\' },\n  ]}\n>\n  <Input placeholder=\"请输入验证码\" />\n</Form.Item>\n\n<Form.Item\n  name=\"remember\"\n  valuePropName=\"checked\"\n  rules={[{ required: true, message: \'请阅读协议\' }]}\n>\n  <Checkbox>我已阅读并同意[用户协议]和[隐私条款]</Checkbox>\n</Form.Item>\n\n```\n\n### 收集表单数据\n\n+ 给表单注册事件\n\n```jsx\n<Form\n  size=\"large\"\n  validateTrigger={[\'onChange\', \'onBlur\']}\n  onFinish={this.onFinish}\n>\n```\n\n+ 提供事件处理函数\n\n```jsx\nonFinish = (values) => {\n  console.log(values)\n}\n```\n\n+ 修改name属性\n\n```diff\n<Form.Item\n+  name=\"mobile\"\n  rules={[\n    {\n      pattern: /^1[3-9]\\d{9}$/,\n      message: \'手机号码格式不对\',\n    },\n    { required: true, message: \'请输入手机号\' },\n  ]}\n>\n  <Input placeholder=\"请输入手机号\" />\n</Form.Item>\n\n<Form.Item\n+  name=\"code\"\n  rules={[\n    {\n      pattern: /^\\d{6}$/,\n      message: \'验证码格式不对\',\n    },\n    { required: true, message: \'请输入验证码\' },\n  ]}\n>\n  <Input placeholder=\"请输入验证码\" />\n</Form.Item>\n\n<Form.Item\n+  name=\"agree\"\n  valuePropName=\"checked\"\n  rules={[{ required: true, message: \'请阅读协议\' }]}\n>\n  <Checkbox>我已阅读并同意[用户协议]和[隐私条款]</Checkbox>\n</Form.Item>\n```\n\n### 设置 默认值\n\n```jsx\n<Form\n  name=\"basic\"\n  size=\"large\"\n  onFinish={this.login}\n  initialValues={{\n    agree: true,\n    mobile: \'13811111111\',\n    code: \'246810\',\n  }}\n>\n```\n\n### 封装axios 的工具函数\n\n+ 安装axios\n\n```jsx\nyarn add axios\n```\n\n+ 新建文件`utils/request.js`\n\n```jsx\nimport axios from \'axios\'\n\nconst instance = axios.create({\n  baseURL: \'http://geek.itheima.net/\',\n  timeout: 5000,\n})\n\n// 请求拦截器\ninstance.interceptors.request.use(\n  function (config) {\n    return config\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n\n// 响应拦截器\ninstance.interceptors.response.use(\n  function (response) {\n    return response.data\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n\nexport default instance\n\n```\n\n+ 测试\n\n### api封装\n\n+ 新建文件 `src/api/user.js`\n\n```js\nimport request from \'utils/request\'\n\n/**\n * 登录请求，用于用户登录\n * @param {string} mobile 手机号\n * @param {string} code 验证码\n * @returns Promise\n */\nexport const login = (mobile, code) => {\n  return request({\n    method: \'POST\',\n    url: \'/authorizations\',\n    data: {\n      mobile,\n      code,\n    },\n  })\n}\n```\n\n+ 发送请求进行登录\n\n```jsx\nsubmit = async (values) => {\n  const { mobile, code } = values\n  try {\n    const res = await login(mobile, code)\n    // 存储token\n    localStorage.setItem(\'itcast_geek_pc\', res.data.token)\n    // 跳转到首页\n    this.props.history.push(\'/home\')\n    alert(\'登录成功\')\n  } catch (err) {\n    alert(err.response.data.message)\n  }\n}\n```\n\n### 消息提示组件的使用\n\n```jsx\n// 表单提交\nsubmit = async values => {\n    this.setState({\n        loading: true\n    })\n\n    const { mobile, code } = values\n    try {\n        const { data } = await login(mobile, code)\n        message.success(\'登录成功\', 1, () => {\n            // 存储token\n            localStorage.setItem(\'itcast_geek_pc\', data.token)\n            // 跳转到首页\n            this.props.history.push(\'/home\')\n        })\n    } catch (err) {\n        message.warning(err.response.data.message, 1, () => {\n            this.setState({\n                loading: false\n            })\n        })\n    }\n}\n```\n\n\n## react样式冲突 \n\n### 组件样式覆盖问题\n\n+ 在Layout组件的`index.scss`中添加样式\n\n```css\n.navBar {\n  background-color: pink;\n}\n```\n\n+ 在`Home`组件中的样式也跟着发生了改变，说明组件中的样式是相互影响的。\n+ 原因：在配置路由时，Layout和 Home 组件都被导入到项目中，那么组件的样式也就被导入到项目中了。如果组件之间样式名称相同，那么一个组件中的样式就会在另一个组件中也生效，从而造成组件之间样式相互覆盖的问题。\n+ 结论：默认，只要导入了组件，不管组件有没有显示在页面中，组件的样式就会生效。\n+ 解决方案\n  + 手动处理 （起不同的类名）\n  + `CSS IN JS` ： 以js的方式来处理css   \n  + css不是一门编程语言，css没有所有的局部作用域全局作用域这样的区分。。。css只有全局作用域\n\n###  CSS IN JS\n\n+ CSS IN JS：是使用 JavaScript 编写 CSS 的统称，用来解决 CSS 样式冲突、覆盖等问题\n+ [CSS IN JS](<https://github.com/MicheleBertoli/css-in-js>) 的具体实现有 50 多种，比如：CSS Modules、[styled-components](<https://www.styled-components.com/>) 等\n\n+ 推荐使用：[CSS Modules](<https://github.com/css-modules/css-modules>) （React脚手架已集成，可直接使用）\n\n### CSS Modules 的说明 \n\n+ CSS Modules 通过对 CSS 类名重命名，保证每个类名的唯一性，从而避免样式冲突的问题 \n+ 换句话说：所有类名都具有“局部作用域”，只在当前组件内部生效\n+ 在 React 脚手架中：文件名、类名、hash（随机）三部分，只需要指定类名即可  BEM\n+ `xxxx.module.css`\n\n```js\n/* 自动生成的类名，我们只需要提供 classname 即可 */\n[filename]_[classname]_[hash]\n```\n\n```css\n// 类名\n.error {}  .red{}\n// 生成的类名为：\n.NavHeader_error__ax7yz   .NavHead_red_abcdc\n```\n\n### 在项目中使用css Modules\n\n+ 创建名为 `[name].module.css` 的样式文件（React脚手架中的约定，与普通 CSS 作区分）\n\n```js\n// 在 CityList 组件中创建的样式文件名称：\nindex.module.css\n```\n\n+ 组件中导入该样式文件（注意语法）\n\n```js\n// 在 CityList 组件中导入样式文件：\nimport styles from \'./index.module.css\'\n```\n\n+ 通过 styles 对象访问对象中的样式名来设置样式\n\n```js\n<div className={styles.test}></div>\n```\n\n### css module的注意点\n\n+ 类名最好使用驼峰命名，因为最终类名会生成`styles`的一个属性\n\n```js\n.tabBar {}\n\nstyles.tabBar\n```\n\n+ 如果没有使用驼峰命名，对于不合法的命名，需要使用[]语法 \n\n```js\n.tab-bar {}\n\nstyles[\'tab-bar\']\n```\n\n+ 如果是全局的类名，应该使用`:global(.类名)`的方式，不然会把全局类名给修改掉 \n\n```js\n:global(.icon-map) {   }\n\n这样css modules就不会修改掉类名了\n```\n\n### css module配合sass\n\n+ css moudule也可以配合sass来使用，创建名为`[name].module.scss`\n\n```css\n.father {\n  .son {\n    font-size: 30px;\n  }\n\n  :global {\n    .son2 {\n      font-size: 20px;\n    }\n  }\n}\n```\n\n+ 使用css modules解决Login组件样式冲突问题\n\n\n\n### css modules的使用步骤\n\n1. 把`index.scss`改成`index.module.scss`\n\n```scss\n.list {\n  background-color: pink;\n  color: red;\n    :global {\n        xxxx\n    }\n}\n\n```\n\n2. 导入样式的时候进行修改\n\n```diff\n- import \'./index.scss\'\n\n+ import styles from \'./index.module.scss\'\n```\n\n\n\n3. 使用的时候需要修改\n\n```diff\n- <div className=\"list\">文章列表组件</div>\n\n+ <div className={styles.list}>文章列表组件</div>\n```\n\n\n\n## 项目功能 - 首页\n\n![image-20210825144229158](https://gitee.com/qarabala/jikeyuanpc-docs/raw/master/mds/images/image-20210825144229158.png)\n\n### 搭建布局组件结构\n\n+ 准备基本结构\n\n```jsx\n<div className=\"layout\">\n  <Layout>\n    <Header className=\"header\">\n      <div className=\"logo\" />\n    </Header>\n    <Layout>\n      <Sider width={200} className=\"site-layout-background\">\n        <Menu\n          mode=\"inline\"\n          defaultSelectedKeys={[\'1\']}\n          defaultOpenKeys={[\'sub1\']}\n          style={{ height: \'100%\', borderRight: 0 }}\n        >\n          <Menu.Item key=\"1\">option1</Menu.Item>\n          <Menu.Item key=\"2\">option2</Menu.Item>\n          <Menu.Item key=\"3\">option3</Menu.Item>\n        </Menu>\n      </Sider>\n      <Layout style={{ padding: \'0 24px 24px\' }}>\n        <Content\n          className=\"site-layout-background\"\n          style={{\n            padding: 24,\n            margin: 0,\n            minHeight: 280,\n          }}\n        >\n          Content\n        </Content>\n      </Layout>\n    </Layout>\n  </Layout>\n</div>\n```\n\n+ 提供样式文件`index.scss`\n\n```scss\n.layout {\n  .logo {\n    float: left;\n    width: 120px;\n    height: 31px;\n    margin: 16px 24px 16px 0;\n    background: rgba(255, 255, 255, 0.3);\n  }\n\n  .ant-row-rtl .logo {\n    float: right;\n    margin: 16px 0 16px 24px;\n  }\n\n  .site-layout-background {\n    background: #fff;\n  }\n}\n\n```\n\n### 头部结构与样式\n\n+ 头部结构\n\n```jsx\n<Header className=\"header\">\n  <div className=\"logo\" />\n  <div className=\"profile\">\n    <span>黑马先锋</span>\n    <span>\n      <LogoutOutlined></LogoutOutlined>\n      {\'  \'}退出\n    </span>\n  </div>\n</Header>\n```\n\n+ 头部样式\n\n```css\n.layout {\n  .profile {\n    position: absolute;\n    right: 20px;\n    color: #fff;\n    font-weight: 700;\n    span + span {\n      margin-left: 20px;\n      cursor: pointer;\n    }\n  }\n}\n\n```\n\n### 左侧菜单\n\n+ 导入图标\n\n```jsx\nimport {\n  LogoutOutlined,\n  HomeOutlined,\n  DiffOutlined,\n  EditOutlined,\n} from \'@ant-design/icons\'\n```\n\n+ 展示图标\n\n```jsx\n<Menu.Item key=\"1\" icon={<HomeOutlined />}>\n  数据概览\n</Menu.Item>\n<Menu.Item key=\"2\" icon={<DiffOutlined />}>\n  内容管理\n</Menu.Item>\n<Menu.Item key=\"3\" icon={<EditOutlined />}>\n  发布文章\n</Menu.Item>\n```\n\n### 整体样式处理\n\n+ 样式\n\n```scss\n.layout {\n  height: 100vh;\n  .ant-layout {\n    height: 100%;\n  }\n}\n```\n\n+ 内容样式修改\n\n```jsx\n<Layout style={{ padding: \'24px\' }}>\n```\n\n### 嵌套路由的配置\n\n+ 新增组件 `Home/index.js`  `ArticleList/index.js`   `ArticlePublish/index.js`\n\n```jsx\nimport React, { Component } from \'react\'\n\nexport default class Home extends Component {\n  render() {\n    return <div className=\"home\">Home首页</div>\n  }\n}\n\n```\n\n+ 增加配置  layout/index.js组件中\n\n```jsx\n\nimport Home from \'../Home\'\nimport ArticleList from \'../ArticleList\'\nimport ArticlePublish from \'../ArticlePublish\'\n\n<Route exact path=\"/home\" component={Home}></Route>\n<Route path=\"/home/list\" component={ArticleList}></Route>\n<Route path=\"/home/publish\" component={ArticlePublish}></Route>\n```\n\n### 退出功能\n\n+ 结构\n\n```jsx\nimport { Layout, Menu, Popconfirm } from \'antd\'\n\n<Popconfirm\n  title=\"你确定要退出本系统么？\"\n  okText=\"确定\"\n  cancelText=\"取消\"\n  onConfirm={this.onConfirm}\n>\n  <span>\n    <LogoutOutlined></LogoutOutlined>\n    {\'  \'}退出\n  </span>\n</Popconfirm>\n```\n\n+ 功能\n\n```jsx\nonConfirm = () => {\n  // 点击了确定\n  localStorage.removeItem(\'itcast_geek_pc\')\n  // 跳转到登录页\n  this.props.history.push(\'/login\')\n  // 提示消息\n  message.success(\'退出成功\')\n}\n```\n\n### 本地存储操作的封装\n\n+ 封装token操作 `utils/storage.js`\n\n```jsx\nconst TOKEN_KEY = \'itcast-geek-token\'\n\nconst setToken = (token) => {\n  localStorage.setItem(TOKEN_KEY, token)\n}\n\nconst removeToken = () => {\n  localStorage.removeItem(TOKEN_KEY)\n}\n\nconst getToken = () => {\n  return localStorage.getItem(TOKEN_KEY)\n}\n\nexport { setToken, getToken, removeToken }\n\n```\n\n+ 修改登录代码\n\n```jsx\nsubmit = async (values) => {\n  const { mobile, code } = values\n  try {\n    const res = await login(mobile, code)\n    // 存储token\n    // localStorage.setItem(\'itcast_geek_pc\', res.data.token)\n    setToken(res.data.token)\n    // 跳转到首页\n    this.props.history.push(\'/home\')\n    message.success(\'登录成功\', 1)\n  } catch (err) {\n    message.warning(err.response.data.message, 1)\n  }\n}\n```\n\n+ 修改退出功能\n\n```jsx\nonConfirm = () => {\n  // 点击了确定\n  // localStorage.removeItem(\'itcast_geek_pc\')\n  removeToken()\n  // 跳转到登录页\n  this.props.history.push(\'/login\')\n  // 提示消息\n  message.success(\'退出成功\')\n}\n```\n\n### 登录访问控制 - 鉴权\n\n对于极客园 PC 端项目来说，\n\n- 有的页面*不需要登录*就可以访问，比如，登录页\n- 有的页面*需要登录*后才能访问，比如，项目后台首页、内容管理等（除了登录页面，其他页面需要登录才能访问）\n\n因此，就需要对项目进行登录访问控制，让需要登录才能访问的页面，必须在登录后才能访问。\n在没有登录时，直接跳转到登录页面，让用户进行登录。\n\n- 如何实现登录访问控制呢？\n  - 分析：不管哪个页面都是通过**路由**来访问的，因此，需要从路由角度来进行控制\n  - 思路：创建 `AuthRoute` 组件，判断是否登录，1 登录直接显示要访问的页面 2 没有登录跳转到登录页面\n\n**难点：react中没有导航守卫，需要自己封装**\n\n#### 分析 AuthRoute 鉴权路由组件\n\n+ 场景：限制某个页面只能在登录的情况下访问。\n+ 说明：在 React 路由中并没有直接提供该组件，需要手动封装，来实现登录访问控制（类似于 Vue 路由的导航守卫）。\n+ 如何封装？参考 react-router-dom 文档中提供的鉴权示例 。\n+ 如何使用？使用 AuthRoute 组件代替默认的 Route 组件，来配置路由规则。\n+ AuthRoute 组件实际上就是对原来的 Route 组件做了一次包装，来实现了一些额外的功能。\n+ `<Route  path component render>`   render 方法，指定该路由要渲染的组件内容（类似于 component 属性）。\n+ Redirect 组件：重定向组件，通过 to 属性，指定要跳转到的路由信息。\n+ state 属性：表示给路由附加一些额外信息，此处，用于指定登录成功后要进入的页面地址。\n\n```js\n// 使用方式：\n<AuthRoute path=\"/rent/add\" component={Rent} />\n```\n\n#### 实现自己的AuthRoute组件\n\n+ 新增hasToken方法\n\n```jsx\nconst hasToken = () => !!getToken()\n\nexport { setToken, getToken, removeToken, hasToken }\n```\n\n+ 权限判断\n\n```js\nimport React from \"react\"\nimport { Route, Redirect } from \"react-router-dom\"\nimport { hasToken } from \'utils/storage\'\nfunction AuthRouter({ component: Component, ...rest }) {\n  return (\n    <Route\n      {...rest}\n      render={(props) => {\n        // console.log(\"props\", props)\n        if (hasToken()) {\n          return <Component {...props}></Component>\n        } else {\n          return (\n            <Redirect\n              to={{ pathname: \"/login\", state: { from: props.location } }}\n            ></Redirect>\n          )\n        }\n      }}\n    ></Route>\n  )\n}\n\nexport default AuthRouter\n\n```\n\n+ 使用AuthRoute\n\n```jsx\n{/* 路由规则 */}\n<Switch>\n  <Redirect exact from=\"/\" to=\"/home\"></Redirect>\n  <AuthRoute path=\"/home\" component={Layout}></AuthRoute>\n  <Route path=\"/login\" component={Login}></Route>\n</Switch>\n```\n\n+ 登录成功处理\n\n```jsx\nsubmit = async (values) => {\n  const { mobile, code } = values\n  console.log(this.props)\n  try {\n    const res = await login(mobile, code)\n    // 存储token\n    // localStorage.setItem(\'itcast_geek_pc\', res.data.token)\n    setToken(res.data.token)\n    // 跳转到首页\n    const { state } = this.props.location\n    if (state) {\n      this.props.history.push(state.from.pathname)\n    } else {\n      this.props.history.push(\'/home\')\n    }\n    message.success(\'登录成功\', 1)\n  } catch (err) {\n    message.warning(err.response.data.message, 1)\n  }\n}\n```\n\n#### route组件的作用\n\n```jsx\n<Route path=\"/home\" component={Home}></Route>\n<Route path=\"/login\" component={Login}></Route>\n```\n\nRoute组件会根据当前地址中的地址 和 Route的path进行匹配，，，如果路径一直，那么这个对应的组件就会被渲染出来\n\nRoute没有判断用户是否登录的能力，只会根据path判断是否要渲染对应的组件。\n\n**需求：让Route组件能够有逻辑，能够判断用户是否登录，，，，需要通过Route组件的render属性**\n\n\n\n### 获取个人信息\n\n+ 拦截器添加token\n\n```jsx\n// 请求拦截器\ninstance.interceptors.request.use(\n  function (config) {\n    const token = getToken()\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`\n    }\n    return config\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n```\n\n+ 封装接口，获取用户信息\n\n```jsx\n/**\n * 获取用户信息\n * @returns Promise\n */\nexport const getUserInfo = () => {\n  return request({\n    url: \'/user/profile\',\n    method: \'get\',\n  })\n}\n\n```\n\n+ 发送请求进行登录\n\n```jsx\nstate = {\n  profile: {},\n}\n\nasync componentDidMount() {\n  const res = await getUserProfile()\n  console.log(res)\n  this.setState({\n    profile: res.data,\n  })\n}\n```\n\n+ 渲染\n\n```jsx\n<div className=\"profile\">\n  <span>{this.state.profile.name}</span>\n  <Popconfirm\n    title=\"你确定要退出本系统么？\"\n    okText=\"确定\"\n    cancelText=\"取消\"\n    onConfirm={this.onConfirm}\n  >\n    <span>\n      <LogoutOutlined></LogoutOutlined>\n      {\'  \'}退出\n    </span>\n  </Popconfirm>\n</div>\n```\n\n### 处理token过期\n\n> 使用响应拦截器拦截未登录的用户\n>\n> 难点：react-router-dom 如何在非组件中实现路由跳转\n\n+ 响应拦截器处理\n\n```jsx\n// 响应拦截器\ninstance.interceptors.response.use(\n  function (response) {\n    return response.data\n  },\n  function (error) {\n    console.log(error.response)\n    if (error.response.status === 401) {\n      // token过期\n      removeToken()\n      window.location.href = \'/login\'\n    }\n    return Promise.reject(error)\n  }\n)\n```\n\n缺点：window.localtion会导致页面刷新\n\n+ history处理 `utils/history.js`\n\n```\nimport { createHashHistory } from \'history\'\n\nconst history = createHashHistory()\n\nexport default history\n\n```\n\n+ App.js修改\n\n```jsx\nimport history from \'utils/history\'\n\n<Router history={history}>\n</Router>\n```\n\n\n\n+ 修改响应拦截器\n\n```jsx\nimport history from \'./history\'\n// 响应拦截器\ninstance.interceptors.response.use(\n  function (response) {\n    return response.data\n  },\n  function (error) {\n    console.log(error.response)\n    if (error.response.status === 401) {\n      // token过期\n      removeToken()\n      // 跳转到登录页\n      history.push(\'/login\')\n      message.warning(\'用户信息已过期\')\n    }\n    return Promise.reject(error)\n  }\n)\n```\n\n### 左侧菜单与高亮\n\n```jsx\n<Menu\n  theme=\"dark\"\n  mode=\"inline\"\n  defaultSelectedKeys={[this.props.location.pathname]}\n  style={{ height: \'100%\', borderRight: 0 }}\n>\n  <Menu.Item key=\"/home\" icon={<HomeOutlined />}>\n    <Link to=\"/home\">首页</Link>\n  </Menu.Item>\n  <Menu.Item key=\"/home/list\" icon={<DiffOutlined />}>\n    <Link to=\"/home/list\">内容管理</Link>\n  </Menu.Item>\n  <Menu.Item key=\"/home/publish\" icon={<EditOutlined />}>\n    <Link to=\"/home/publish\">发布文章</Link>\n  </Menu.Item>\n</Menu>\n```\n\n\n## 文章列表功能\n\n\n### card组件与面包屑导航\n\n+ card组件，文档：https://ant.design/components/card-cn/\n\n```jsx\nimport { Card } from \'antd\'\nexport default class ArticleList extends Component {\n  render() {\n    return (\n      <div className=\"articleList\">\n        <Card title=\"面包屑导航\">我是内容</Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 面包屑导航的使用\n\n```jsx\nimport React, { Component } from \'react\'\nimport { Card, Breadcrumb } from \'antd\'\nimport { Link } from \'react-router-dom\'\n\nrender() {\n    return (\n      <div className=\"articleList\">\n        <Card\n          title={\n            <Breadcrumb separator=\"/\">\n              <Breadcrumb.Item>\n                <Link to=\"/home\">首页</Link>\n              </Breadcrumb.Item>\n              <Breadcrumb.Item>文章列表</Breadcrumb.Item>\n            </Breadcrumb>\n          }\n        >\n          我是内容\n        </Card>\n      </div>\n    )\n  }\n```\n\n### 搜索表单基本结构\n\n+ 复制表单的基本结构到组件中\n+ 修改表单结构\n\n```jsx\n<Card\n  title={\n    <Breadcrumb separator=\"/\">\n      <Breadcrumb.Item>\n        <Link to=\"/home\">首页</Link>\n      </Breadcrumb.Item>\n      <Breadcrumb.Item>文章列表</Breadcrumb.Item>\n    </Breadcrumb>\n  }\n>\n  <Form>\n    <Form.Item label=\"状态\" name=\"username\">\n      <Input />\n    </Form.Item>\n\n    <Form.Item label=\"频道\" name=\"password\">\n      <Input.Password />\n    </Form.Item>\n\n    <Form.Item label=\"日期\" name=\"password\">\n      <Input.Password />\n    </Form.Item>\n\n    <Form.Item>\n      <Button type=\"primary\" htmlType=\"submit\">\n        筛选\n      </Button>\n    </Form.Item>\n  </Form>\n</Card>\n```\n\n+ 状态的基本结构\n\n```jsx\n<Form initialValues={{ status: null }}>\n  <Form.Item label=\"状态\" name=\"status\">\n    <Radio.Group>\n      <Radio value={null}>全部</Radio>\n      <Radio value={0}>草稿</Radio>\n      <Radio value={1}>待审核</Radio>\n      <Radio value={2}>审核通过</Radio>\n      <Radio value={3}>审核失败</Radio>\n    </Radio.Group>\n  </Form.Item>\n```\n\n+ 下拉框结构\n\n```jsx\n<Form.Item label=\"频道\" name=\"password\">\n  <Select placeholder=\"请选择频道\" style={{ width: 200 }}>\n    <Option value=\"jack\">Jack</Option>\n    <Option value=\"lucy\">Lucy</Option>\n    <Option value=\"Yiminghe\">yiminghe</Option>\n  </Select>\n</Form.Item>\n```\n\n+ 日期选择基本结构\n\n```jsx\nimport { Card, Breadcrumb, Form, Button, Radio, Select, DatePicker } from \'antd\'\nconst { RangePicker } = DatePicker\n\n<Form.Item label=\"日期\" name=\"password\">\n  <RangePicker />\n</Form.Item>\n```\n\n### 日期中文处理\n\n> https://ant-design.gitee.io/components/date-picker-cn/\n\n在index.js中\n\n```jsx\nimport React from \'react\'\nimport ReactDOM from \'react-dom\'\n// 在 index.js 中导入 antd 的样式文件\nimport \'antd/dist/antd.css\'\n\nimport \'./index.css\'\nimport { ConfigProvider } from \'antd\'\nimport \'moment/locale/zh-cn\'\nimport locale from \'antd/lib/locale/zh_CN\'\n\nimport App from \'./App\'\n\nReactDOM.render(\n  <ConfigProvider locale={locale}>\n    <App />\n  </ConfigProvider>,\n  document.getElementById(\'root\')\n)\n\n```\n\n### 频道数据管理\n\n+ 封装接口\n\n```jsx\nimport request from \'utils/request\'\n\n/*\n  获取所有的频道\n*/\nexport const getChannels = () => {\n  return request.get(\'/channels\')\n}\n\n```\n\n+ 发送请求获取数据\n\n```jsx\nimport { getChannels } from \'api/channel\'\n\nstate = {\n  channels: [],\n}\nasync getChannelList() {\n  const res = await getChannels()\n  this.setState({\n    channels: res.data.channels,\n  })\n}\n\ncomponentDidMount() {\n  this.getChannelList()\n}\n```\n\n+ 渲染频道数据\n\n```jsx\n<Select placeholder=\"请选择频道\" style={{ width: 200 }}>\n  {this.state.channels.map((item) => (\n    <Option value={item.id} key={item.id}>\n      {item.name}\n    </Option>\n  ))}\n</Select>\n```\n\n### 表格基本结构\n\n+ 基本结构\n\n```jsx\nimport {\n  Card,\n  Breadcrumb,\n  Form,\n  Button,\n  Radio,\n  Select,\n  DatePicker,\n  Table,\n  Tag,\n  Space,\n} from \'antd\'\n\nrender() {\n  const columns = [\n    {\n      title: \'Name\',\n      dataIndex: \'name\',\n      key: \'name\',\n      render: (text) => <a>{text}</a>,\n    },\n    {\n      title: \'Age\',\n      dataIndex: \'age\',\n      key: \'age\',\n    },\n    {\n      title: \'Address\',\n      dataIndex: \'address\',\n      key: \'address\',\n    },\n    {\n      title: \'Tags\',\n      key: \'tags\',\n      dataIndex: \'tags\',\n      render: (tags) => (\n        <>\n          {tags.map((tag) => {\n            let color = tag.length > 5 ? \'geekblue\' : \'green\'\n            if (tag === \'loser\') {\n              color = \'volcano\'\n            }\n            return (\n              <Tag color={color} key={tag}>\n                {tag.toUpperCase()}\n              </Tag>\n            )\n          })}\n        </>\n      ),\n    },\n    {\n      title: \'Action\',\n      key: \'action\',\n      render: (text, record) => (\n        <Space size=\"middle\">\n          <a>Invite {record.name}</a>\n          <a>Delete</a>\n        </Space>\n      ),\n    },\n  ]\n\n  const data = [\n    {\n      key: \'1\',\n      name: \'John Brown\',\n      age: 32,\n      address: \'New York No. 1 Lake Park\',\n      tags: [\'nice\', \'developer\'],\n    },\n    {\n      key: \'2\',\n      name: \'Jim Green\',\n      age: 42,\n      address: \'London No. 1 Lake Park\',\n      tags: [\'loser\'],\n    },\n    {\n      key: \'3\',\n      name: \'Joe Black\',\n      age: 32,\n      address: \'Sidney No. 1 Lake Park\',\n      tags: [\'cool\', \'teacher\'],\n    },\n  ]\n\n  return (\n    <div className=\"articleList\">\n      <Card title={`根据筛选条件共查询到${0}条数据`}>\n        <Table dataSource={data} columns={columns} />\n      </Card>\n    </div>\n  )\n}\n```\n\n### 获取文章列表数据\n\n+ 封装接口\n\n```jsx\nimport request from \'utils/request\'\n\n/**\n * 获取文章列表\n * @param {*} params\n * @returns\n */\nexport const getArticles = (params) => {\n  return request({\n    url: \'/mp/articles\',\n    method: \'get\',\n    params,\n  })\n}\n\n```\n\n+ 发送请求获取文章列表数据\n\n```jsx\n  state = {\n    channels: [],\n    articles: [],\n    total: 0,\n  }\n  async getChannelList() {\n    const res = await getChannels()\n    this.setState({\n      channels: res.data.channels,\n    })\n  }\n\n  async getArticleList() {\n    const res = await getArticles()\n    this.setState({\n      articles: res.data.results,\n      total: res.data.total_count,\n    })\n  }\n\n  componentDidMount() {\n    this.getChannelList()\n    this.getArticleList()\n  }\n\n```\n\n### 渲染表格数据\n\n+ 修改columns\n\n```jsx\nconst columns = [\n  {\n    title: \'封面\',\n    dataIndex: \'name\',\n  },\n  {\n    title: \'标题\',\n    dataIndex: \'title\',\n  },\n  {\n    title: \'状态\',\n    dataIndex: \'status\',\n  },\n  {\n    title: \'发布时间\',\n    dataIndex: \'pubdate\',\n  },\n  {\n    title: \'阅读数\',\n    dataIndex: \'read_count\',\n  },\n  {\n    title: \'评论数\',\n    dataIndex: \'comment_count\',\n  },\n  {\n    title: \'点赞数\',\n    dataIndex: \'like_count\',\n  },\n  {\n    title: \'操作\',\n  },\n]\n```\n\n+ 封面处理\n\n```jsx\n{\n  title: \'封面\',\n  dataIndex: \'cover\',\n  render(data) {\n    const { images, type } = data\n    if (type === 0) {\n      return (\n        <Image width={200} preview={false} height={150} src={defaultImg} />\n      )\n    }\n    return (\n      <Image width={200} height={150} src={images[0]} fallback={defaultImg} />\n    )\n  },\n},\n```\n\n+ 状态处理\n\n```jsx\n// 通过对象来优化if/switch\n// 使用方式：articleStatus[0] => { text: \'草稿\', color: \'\' }\nconst articleStatus = {\n  0: { text: \'草稿\', color: \'gold\' },\n  1: { text: \'待审核\', color: \'lime\' },\n  2: { text: \'审核通过\', color: \'green\' },\n  3: { text: \'审核失败\', color: \'red\' },\n}\n\n{\n  title: \'状态\',\n  dataIndex: \'status\',\n  render: (data) => {\n    const tagObj = articleStatus[data]\n    return <Tag color={tagObj.color}>{tagObj.text}</Tag>\n  },\n},\n```\n\n+ 操作功能\n\n```jsx\n{\n    title: \'操作\',\n    render() {\n      return (\n        <Space>\n          <Button\n            type=\"primary\"\n            shape=\"circle\"\n            icon={<EditOutlined />}\n          ></Button>\n          <Button\n            type=\"primary\"\n            shape=\"circle\"\n            danger\n            icon={<DeleteOutlined />}\n          ></Button>\n        </Space>\n      )\n    },\n},\n```\n\n### key属性处理\n\n```jsx\n<Card title={`根据筛选条件共查询到${this.state.total}条数据`}>\n  <Table\n    rowKey=\"id\"\n    dataSource={this.state.articles}\n    columns={columns}\n  />\n</Card>\n```\n\n### 分页功能\n\n+ 使用分页组件\n\n```jsx\n<Card title={`根据筛选条件共查询到${this.state.total_count}条数据`}>\n  <Table\n    rowKey=\"id\"\n    dataSource={results}\n    columns={columns}\n    pagination={{\n      position: [\'bottomCenter\'],\n      current: page,\n      pageSize: per_page,\n      total: total_count,\n      // 每页大小 或者 页码 改变时，触发的事件\n      onChange: this.changePage,\n    }}\n  />\n</Card>\n```\n\n+ 提供changePage事件\n\n```jsx\nchangePage = async (page, pageSize) => {\n  console.log(page)\n  const res = await getArticles({\n    page,\n    per_page: this.state.articles.per_page,\n  })\n  this.setState({\n    articles: res.data,\n  })\n}\n```\n\n### 获取表单的值进行筛选\n\n+ 给表单注册事件\n\n```jsx\n<Form initialValues={{ status: -1 }} onFinish={this.onFinish}>\n```\n\n+ 给表单元素提供name属性\n\n```jsx\n<Form.Item label=\"状态\" name=\"status\">\n  <Radio.Group>\n    <Radio value={-1}>全部</Radio>\n    <Radio value={0}>草稿</Radio>\n    <Radio value={1}>待审核</Radio>\n    <Radio value={2}>审核通过</Radio>\n    <Radio value={3}>审核失败</Radio>\n  </Radio.Group>\n</Form.Item>\n\n<Form.Item label=\"频道\" name=\"channel_id\">\n  <Select placeholder=\"请选择频道\" style={{ width: 200 }}>\n    {this.state.channels.map((item) => (\n      <Option value={item.id} key={item.id}>\n        {item.name}\n      </Option>\n    ))}\n  </Select>\n</Form.Item>\n\n<Form.Item label=\"日期\" name=\"date\">\n  <RangePicker />\n</Form.Item>\n```\n\n+ 发送请求，获取数据\n\n```jsx\nonFinish = async (values) => {\n  console.log(values)\n  // 发送请求，获取数据\n  const params = {}\n  // 处理状态\n  if (values.status !== -1) {\n    params.status = values.status\n  }\n  // 处理频道\n  if (values.channel_id) {\n    params.channel_id = values.channel_id\n  }\n  // 处理日期\n  if (values.date) {\n    params.begin_pubdate = values.date[0].format(\'YYYY-MM-DD\')\n    params.end_pubdate = values.date[1].format(\'YYYY-MM-DD\')\n  }\n  params.page = 1\n  const res = await getArticles(params)\n  console.log(res.data)\n  this.setState({\n    articles: res.data,\n  })\n}\n```\n\n### 时间的优化\n\n```jsx\n// 处理日期\nif (values.date) {\n  params.begin_pubdate = values.date[0]\n    .startOf(\'day\')\n    .format(\'YYYY-MM-DD HH:mm:ss\')\n  params.end_pubdate = values.date[1]\n    .endOf(\'day\')\n    .format(\'YYYY-MM-DD HH:mm:ss\')\n}\n```\n\n### 修改分页bug\n\n```jsx\nchangePage = async (page, pageSize) => {\n  const res = await getArticles({\n    ...this.params,\n    page,\n    per_page: this.state.articles.per_page,\n  })\n  this.setState({\n    articles: res.data,\n  })\n}\nonFinish = async (values) => {\n  console.log(values)\n  // 发送请求，获取数据\n  const params = {}\n  // 处理状态\n  if (values.status !== -1) {\n    params.status = values.status\n  }\n  // 处理频道\n  if (values.channel_id) {\n    params.channel_id = values.channel_id\n  }\n  // 处理日期\n  if (values.date) {\n    params.begin_pubdate = values.date[0]\n      .startOf(\'day\')\n      .format(\'YYYY-MM-DD HH:mm:ss\')\n    params.end_pubdate = values.date[1]\n      .endOf(\'day\')\n      .format(\'YYYY-MM-DD HH:mm:ss\')\n  }\n  params.page = 1\n  this.params = params\n  const res = await getArticles(params)\n  console.log(res.data)\n  this.setState({\n    articles: res.data,\n  })\n}\n```\n\n### 删除功能\n\n+ 注册点击事件\n\n```jsx\n<Button\n  type=\"primary\"\n  shape=\"circle\"\n  danger\n  icon={<DeleteOutlined />}\n  onClick={() => this.handleDelete(data.id)}\n></Button>\n```\n\n+ 准备弹窗\n\n```jsx\nhandleDelete = (id) => {\n  confirm({\n    title: \'温馨提示？\',\n    icon: <ExclamationCircleOutlined />,\n    content: \'你确定要删除文章吗\',\n    onOk() {\n      // 发送请求进行删除\n    },\n  })\n}\n```\n\n+ 封装接口进行删除\n\n```jsx\n/**\n * 删除文章\n * @param {*} id\n * @returns\n */\nexport const delArticle = (id) => {\n  return request({\n    url: `/mp/articles/${id}`,\n    method: \'delete\',\n  })\n}\n\n```\n\n+ 删除功能完成\n\n```js\nhandleDelete = (id) => {\n  confirm({\n    title: \'温馨提示？\',\n    icon: <ExclamationCircleOutlined />,\n    content: \'你确定要删除文章吗\',\n    onOk: async () => {\n      // 发送请求进行删除\n      await delArticle(id)\n      this.getArticleList(this.params)\n    },\n  })\n}\n```\n\n## 发布文章\n\n### 基本结构准备\n\n+ 面包屑\n\n```jsx\nimport React, { Component } from \'react\'\nimport { Card, Breadcrumb } from \'antd\'\nimport { Link } from \'react-router-dom\'\nexport default class ArticleList extends Component {\n  render() {\n    return (\n      <div className=\"ArticleList\">\n        <Card\n          title={\n            <Breadcrumb separator=\">\">\n              <Breadcrumb.Item>\n                <Link to=\"/home\">首页</Link>\n              </Breadcrumb.Item>\n              <Breadcrumb.Item>发布文章</Breadcrumb.Item>\n            </Breadcrumb>\n          }\n        ></Card>\n      </div>\n    )\n  }\n}\n```\n\n+ 表单\n\n```jsx\nimport { Card, Breadcrumb, Form, Input, Radio, Space, Button } from \'antd\'\n\n<Form labelCol={{ span: 4 }} initialValues={{ type: 0 }}>\n  <Form.Item label=\"标题\" name=\"title\">\n    <Input placeholder=\"请输入文章标题\" style={{ width: 400 }} />\n  </Form.Item>\n  <Form.Item label=\"频道\" name=\"channel_id\">\n    频道组件\n  </Form.Item>\n  <Form.Item label=\"封面\">\n    <Form.Item name=\"type\">\n      <Radio.Group onChange={this.changeImageType}>\n        <Radio value={0}>无图</Radio>\n        <Radio value={1}>单图</Radio>\n        <Radio value={3}>三图</Radio>\n        {/* <Radio value={-1}>自动</Radio> */}\n      </Radio.Group>\n    </Form.Item>\n    图片上传组件\n  </Form.Item>\n  <Form.Item label=\"内容\" name=\"content\">\n    文章内容\n  </Form.Item>\n  <Form.Item wrapperCol={{ offset: 4 }}>\n    <Space>\n      <Button size=\"large\" type=\"primary\" htmlType=\"submit\">\n        发布文章\n      </Button>\n      <Button size=\"large\">存入草稿</Button>\n    </Space>\n  </Form.Item>\n</Form>\n```\n\n+ 给表单注册事件\n\n```jsx\n<Form\n  labelCol={{ span: 4 }}\n  initialValues={{ type: 0 }}\n  onFinish={this.onFinish}\n>\n\n\nonFinish = (values) => {\n  console.log(values)\n}\n```\n\n### 频道组件封装\n\n+ 基础封装\n\n```jsx\nimport { Component } from \'react\'\nimport { Select } from \'antd\'\nimport { getChannels } from \'api/channel\'\n\nconst { Option } = Select\n\nclass Channel extends Component {\n  state = {\n    channels: [],\n  }\n\n  componentDidMount() {\n    this.getChannles()\n  }\n\n  // 获取频道列表数据的方法\n  async getChannles() {\n    const res = await getChannels()\n    this.setState({\n      channels: res.data.channels,\n    })\n  }\n\n  render() {\n    const { channels } = this.state\n\n    return (\n      <Select placeholder=\"请选择文章频道\">\n        {channels.map((item) => (\n          <Option key={item.id} value={item.id}>\n            {item.name}\n          </Option>\n        ))}\n      </Select>\n    )\n  }\n}\n\nexport default Channel\n\n```\n\n+ 使用频道组件\n\n```jsx\nimport Channel from \'components/Channel\'\n\n<Form.Item label=\"频道\" name=\"channel_id\">\n  <Channel></Channel>\n</Form.Item>\n```\n\n+ 让频道组件受控\n\n> 参考文档：https://ant-design.gitee.io/components/form-cn/#components-form-demo-customized-form-controls\n\n```jsx\nrender() {\n  const { channels } = this.state\n  const { value, onChange } = this.props\n  return (\n    <Select\n      placeholder=\"请选择文章频道\"\n      style={{ width: 200 }}\n      value={value}\n      onChange={onChange}\n    >\n      {channels.map((item) => (\n        <Option key={item.id} value={item.id}>\n          {item.name}\n        </Option>\n      ))}\n    </Select>\n  )\n}\n```\n\n### 文章内容处理\n\n+ 使用react-quill富文本编辑器 	https://github.com/zenoamaro/react-quill\n\n```jsx\nimport ReactQuill from \'react-quill\';\nimport \'react-quill/dist/quill.snow.css\';\n\n<Form.Item label=\"内容\" name=\"content\">\n  <ReactQuill\n    theme=\"snow\"\n    placeholder=\"请输入文章内容...\"\n  ></ReactQuill>\n</Form.Item>\n```\n\n+ 注意：**必须提供默认值，不然会报错**\n+ 提供样式\n\n```scss\n.publish {\n  :global {\n    .ql-editor {\n      min-height: 300px;\n    }\n  }\n}\n\n```\n\n### 图片上传组件\n\n+ 基本结构\n\n```jsx\nimport {\n  Card,\n  Breadcrumb,\n  Form,\n  Input,\n  Radio,\n  Space,\n  Button,\n  Upload,\n} from \'antd\'\nimport { PlusOutlined } from \'@ant-design/icons\'\n\n<Upload listType=\"picture-card\">\n  <PlusOutlined></PlusOutlined>\n</Upload>\n```\n\n+ 设置图片默认显示\n\n```jsx\n<Upload\n  listType=\"picture-card\"\n  name=\"image\"\n  fileList={this.state.fileList}\n>\n  <PlusOutlined></PlusOutlined>\n</Upload>\n\n\nstate = {\n  // 存放上传的文件列表\n  fileList: [\n    {\n      url: \'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png\',\n    },\n    {\n      url: \'https://zos.alipayobjects.com/rmsportal/jkjgkEfvpUPVyRjUImniVslZfWPnJuuZ.png\',\n    },\n  ],\n}\n\n```\n\n+ 图片上传功能， 需要提供name和action参数\n\n```jsx\n<Upload\n  listType=\"picture-card\"\n  name=\"image\"\n  action={`${baseURL}upload`}\n  onChange={this.uploadImages}\n  fileList={this.state.fileList}\n>\n  <PlusOutlined></PlusOutlined>\n</Upload>\n```\n\n+ 获取上传成功的图片地址\n\n```jsx\nuploadImages = ({ file, fileList }) => {\n  this.setState({\n    fileList,\n  })\n}\n```\n\n### 控制图片的上传数量\n\n+ 控制type的切换\n\n```jsx\nstate = {\n  // 存放上传的文件列表\n  fileList: [],\n  type: 0,\n}\n\n<Radio.Group onChange={this.changeImageType}>\n  <Radio value={0}>无图</Radio>\n  <Radio value={1}>单图</Radio>\n  <Radio value={3}>三图</Radio>\n</Radio.Group>\n\n\nchangeImageType = (e) => {\n  this.setState({\n    type: e.target.value,\n  })\n}\n```\n\n+ 根据type控制图片的显示\n\n```jsx\n{this.state.type !== 0 && (\n  <Upload\n    listType=\"picture-card\"\n    name=\"image\"\n    action={`${baseURL}upload`}\n    onChange={this.uploadImages}\n    fileList={this.state.fileList}\n  >\n    <PlusOutlined></PlusOutlined>\n  </Upload>\n)}\n```\n\n+ 控制图片的上传数据\n\n```jsx\n{this.state.type !== 0 && (\n  <Upload\n    listType=\"picture-card\"\n    name=\"image\"\n    action={`${baseURL}upload`}\n    onChange={this.uploadImages}\n    fileList={this.state.fileList}\n  >\n    {this.state.fileList.length < this.state.type && (\n      <PlusOutlined></PlusOutlined>\n    )}\n  </Upload>\n)}\n```\n\n### 图片预览功能\n\n### 图片格式校验\n\n### 表单校验功能\n\n+ 表单基本校验\n\n```jsx\n<Form.Item\n  label=\"标题\"\n  name=\"title\"\n  rules={[{ required: true, message: \'请输入文章标题\' }]}\n>\n  <Input placeholder=\"请输入文章标题\" style={{ width: 400 }} />\n</Form.Item>\n<Form.Item\n  label=\"频道\"\n  name=\"channel_id\"\n  rules={[{ required: true, message: \'请选择文章频道\' }]}\n>\n  <Channel></Channel>\n</Form.Item>\n<Form.Item label=\"封面\">\n  <Form.Item name=\"type\">\n    <Radio.Group onChange={this.changeImageType}>\n      <Radio value={1}>单图</Radio>\n      <Radio value={3}>三图</Radio>\n      <Radio value={0}>无图</Radio>\n      {/* <Radio value={-1}>自动</Radio> */}\n    </Radio.Group>\n  </Form.Item>\n  <div className=\"upload-list\">\n    {this.state.type !== 0 && (\n      <Upload\n        listType=\"picture-card\"\n        name=\"image\"\n        action={`${baseURL}upload`}\n        onChange={this.uploadImages}\n        fileList={this.state.fileList}\n      >\n        {this.state.fileList.length < this.state.type && (\n          <PlusOutlined></PlusOutlined>\n        )}\n      </Upload>\n    )}\n  </div>\n</Form.Item>\n<Form.Item\n  label=\"内容\"\n  name=\"content\"\n  rules={[{ required: true, message: \'请输入文章内容\' }]}\n>\n  <ReactQuill\n    theme=\"snow\"\n    placeholder=\"请输入文章内容...\"\n  ></ReactQuill>\n</Form.Item>\n```\n\n+ 图片长度的校验\n\n```jsx\nonFinish = async (values) => {\n  // 图片校验\n  if (this.state.type !== this.state.fileList.length) {\n    return message.warn(\'上传的图片数量不对\')\n  }\n}\n```\n\n### 发送请求-添加文章\n\n+ 封装接口\n\n```jsx\n/**\n * 发送请求添加文章\n * @param {*} data\n * @returns\n */\nexport const addArticle = (data) => {\n  return request({\n    url: \'/mp/articles\',\n    method: \'post\',\n    data,\n  })\n}\n\n```\n\n+ 发送请求-处理数据并且添加文章\n\n```jsx\nonFinish = async (values) => {\n  console.log(values)\n  // 处理数据，添加文章\n  const images = this.state.fileList.map((item) => {\n    if (item.url) {\n      return item.url\n    }\n    return item.response.data.url\n  })\n  const res = await addArticle({\n    ...values,\n    cover: {\n      type: values.type,\n      images,\n    },\n  })\n  message.success(\'添加文章成功\')\n  this.props.history.push(\'/home/list\')\n}\n```\n\n### 存入草稿功能\n\n+ 修改接口\n\n```jsx\n/**\n * 发送请求添加文章\n * @param {*} data\n * @returns\n */\nexport const addArticle = (data, draft = false) => {\n  return request({\n    url: \'/mp/articles?draft=\' + draft,\n    method: \'post\',\n    data,\n  })\n}\n```\n\n+ 注册点击事件\n\n```jsx\n<Button size=\"large\" onClick={this.addDraft}>\n  存入草稿\n</Button>\n```\n\n+ 提供事件\n\n```jsx\n  onFinish = async (values) => {\n    this.save(values, false)\n  }\n  save = async (values, draft) => {\n    // 图片校验\n    if (this.state.type !== this.state.fileList.length) {\n      return message.warn(\'上传的图片数量不对\')\n    }\n    // 处理数据，添加文章\n    const images = this.state.fileList.map((item) => {\n      if (item.url) {\n        return item.url\n      }\n      return item.response.data.url\n    })\n    await addArticle(\n      {\n        ...values,\n        cover: {\n          type: values.type,\n          images,\n        },\n      },\n      draft\n    )\n    message.success(\'添加文章成功\')\n    this.props.history.push(\'/home/list\')\n  }\n  addDraft = async () => {\n    // 获取表单的数据\n    const values = await this.formRef.current.validateFields()\n    this.save(values, true)\n  }\n```\n\n## 修改功能\n\n### 文字处理\n\n+ 提供状态\n\n```jsx\nstate = {\n  // 存放上传的文件列表\n  fileList: [],\n  type: 1,\n  isEdit: !!this.props.match.params.id,\n}\n```\n\n+ 控制渲染\n\n```jsx\n{this.state.isEdit ? \'修改文章\' : \'发布文章\'}\n```\n\n### 数据回显\n\n+ 路由跳转\n\n```jsx\n<Route\n  path=\"/home/publish\"\n  key=\"add\"\n  component={ArticlePublish}\n  exact\n></Route>\n<Route\n  key=\"edit\"\n  path=\"/home/publish/:id\"\n  component={ArticlePublish}\n></Route>\n```\n\n+ 注册点击事件\n\n```jsx\n<Button\n  type=\"primary\"\n  shape=\"circle\"\n  icon={<EditOutlined />}\n  onClick={() =>\n    this.props.history.push(`/home/publish/${data.id}`)\n  }\n></Button>\n```\n\n+ 封装接口，获取文章数据\n\n```jsx\n/**\n * 根据id获取文章详情\n * @param {*} id\n * @returns\n */\nexport const getArticle = (id) => {\n  return request({\n    url: `/mp/articles/${id}`,\n    method: \'get\',\n  })\n}\n```\n\n+ 数据回显\n\n```jsx\nasync componentDidMount() {\n  // 如果有id，发送请求获取详情\n  const id = this.props.match.params.id\n  if (id) {\n    const res = await getArticle(id)\n    console.log(res)\n    const type = res.data.cover.type\n    const images = res.data.cover.images.map((url) => ({ url }))\n    const values = {\n      ...res.data,\n      type,\n    }\n    this.formRef.current.setFieldsValue(values)\n    this.setState({\n      type,\n      fileList: images,\n    })\n  }\n}\n```\n\n### 修改功能完成\n\n+ 封装接口\n\n```jsx\n/**\n * 发送请求修改文章\n * @param {*} data\n * @returns\n */\nexport const editArticle = (data, draft = false) => {\n  return request({\n    url: `/mp/articles/${data.id}?draft=${draft}`,\n    method: \'put\',\n    data,\n  })\n}\n```\n\n+ 判断\n\n```jsx\nsave = async (values, draft) => {\n  // 图片校验\n  if (this.state.type !== this.state.fileList.length) {\n    return message.warn(\'上传的图片数量不对\')\n  }\n  // 处理数据，添加文章\n  const images = this.state.fileList.map((item) => {\n    if (item.url) {\n      return item.url\n    }\n    return item.response.data.url\n  })\n  if (this.state.isEdit) {\n    await editArticle(\n      {\n        ...values,\n        cover: {\n          type: values.type,\n          images,\n        },\n        id: this.props.match.params.id,\n      },\n      draft\n    )\n    message.success(\'添加文章成功\')\n  } else {\n    await addArticle(\n      {\n        ...values,\n        cover: {\n          type: values.type,\n          images,\n        },\n      },\n      draft\n    )\n    message.success(\'添加文章成功\')\n  }\n  this.props.history.push(\'/home/list\')\n}\n```', NULL, 1, NULL, NULL, '2024-03-18 00:32:51', '2024-03-18 13:24:59', 10, 10);
INSERT INTO `articles` VALUES (4, 'Dart 基础教程', 22, '[40, 58, 59, 61]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/a7eeff0c-7bcc-4cea-9408-39e78279d4c3.jpg', 'Dart 基础教程', '<details>\n<summary>思维导图</summary>\n![](https://gitee.com/qarabala/flutter/raw/master/images/flutter_l.png)\n</details>\n\n[Dart 学习笔记](https://www.jianshu.com/p/44c023ee17dd?u_atoken=9ed3063f-3669-446b-a616-aec46f3132cc&u_asession=01m11u6wokGILVKPBk5g8mRAunswZ74953ggsCdHbrDGLOqZa0M9XXeTNyYzHGpt0sX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_hMLt5q_2qXWHIdZ6D9Y44LDnIvqHhvwKBSiCA9W2pPWBkFo3NEHBv0PZUm6pbxQU&u_asig=052J1jEuZGEWMfO-oHpuKvz7RmU6LXUJBemxQ7iB1O29ctrNFiyTZf6L7JLBhTCrmtPmYhfdPTT7BiHsqROhzrAtpFMvRvyj8A6mJfo-7JbPsGCqgGhHG17E2MumiZ1N5PgyXX8kr6TnZmzqBVifuRSU3u5p3gMwUH_ko8RcoxLyP9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzS44erVyQ7HA8Uri8SxJjwLhenZh4rnYyO47gfIChP3rT6aHbewJv6RwWiEQAUeSSO3h9VXwMyh6PgyDIVSG1W-IlwC5JzWYXKfwUR1h4nUup64Oai2nkZGCpZA6yIz-Qhow20tO8krOtcetN6S1ZXIzCGsn_8VIyZgVZEnmbiXLmWspDxyAEEo4kbsryBKb9Q&u_aref=IbwSjN6mUJsKQdFPytKuQZRLVdo%3D)\n\n> 要学 Flutter 的话我们必须首先得会 Dart [官网](https://dart.dev/)\n\n- [Flutter 英文官网](https://flutter.dev/)\n- [Flutter 中文网](https://flutter.cn/)\n- [android-studio 下载中心](http://www.android-studio.org/)\n- [Dart 包管理器](https://pub.flutter-io.cn/)\n- [Dart & Flutter 视频教程](https://www.bilibili.com/video/BV1S4411E7LY/?p=1&vd_source=b6954ec6b5b2da8b9792c5069dfb4de6)\n- [IT 营实战教程](https://www.itying.com/)\n\n## 基础知识\n\n## 环境搭建及开发工具\n\n### 环境搭建\n\n!> 要在我们本地开发 Dart 程序的话首先需要安装 Dart Sdk\n\n官方文档：https://dart.dev/get-dart\n\n- windows(推荐) http://www.gekorm.com/dart-windows/\n- mac\n\n```shell\n如果mac电脑没有安装brew这个工具首先第一步需要安装它：  https://brew.sh/\nbrew tap dart-lang/dart\nbrew install dart\n```\n\n### 开发工具\n\nDart 的开发工具有很多： IntelliJ IDEA 、 WebStorm、 Atom、Vscode 等。\n\n**Vscode 中配置 Dart**\n\n1. 找到 vscode 插件安装 dart\n2. 找到 vscode 插件安装 code runner. `Code Runner` 可以运行我们的文件\n\n## 入门教程\n\n### 入口方法\n\n```dart\n/*\n 入口方法的两种定义方式\n*/\n\nmain(){\n  print(\'你好dart\');\n}\n\n/// 这也是一个注释\n\n// void表示main方法没有返回值\nvoid main(){\n print(\'你好dart\');\n}\n```\n\n### 变量\n\n- dart 是一个强大的脚本类语言，可以不预先定义变量类型 ，自动会类型推倒\n- dart 中定义变量可以通过 var 关键字可以通过类型来申明变量\n\n```dart\n如：\n  var str=\'this is var\';\n  String str=\'this is var\';\n  int str=123;\n\n注意： var 后就不要写类型 ，  写了类型 不要var   两者都写   var  a int  = 5;  报错\n\nvoid main(){\n\n    // var str=\'你好dart\';\n    // var myNum=1234;\n    // print(str);\n    // print(myNum);\n\n\n    //字符串\n    // String str=\'你好dart\';\n    // print(str);\n\n\n    //数字类型\n    // int myNum=12354;\n    // print(myNum);\n\n    //dart里面有类型校验\n\n    // var str=\'\';\n    // str=1234;\n    // print(str);\n\n\n    String str=\"2131242\";\n    print(str);\n\n    int myNum=1243214;\n    print(myNum);\n}\n```\n\n### 命名规则\n\n1. 变量名称必须由数字、字母、下划线和美元符($)组成。\n2. 注意：标识符开头不能是数字\n3. 标识符不能是保留字和关键字。\n4. 变量的名字是区分大小写的如: age 和 Age 是不同的变量。在实际的运用中,也建议,不要用一个单词大小写区分两个变量。\n5. 标识符(变量名称)一定要见名思意 ：变量名称建议用名词，方法名称建议用动词\n\n```dart\nvoid main(){\n\n    var str1=\'2134214\';\n\n    //var 2str=\'xxx\';   //错误\n    // var if=\'124214\';  //错误\n\n\n    //变量的名字是区分大小写的\n    var age=20;\n    var Age=30;\n\n    print(age);\n    print(Age);\n\n    var price=12;\n    var name=124;\n\n}\n```\n\n### 常量\n\nDart 常量： final 和 const 修饰符\n\n- const 值不变 一开始就得赋值\n- final 可以开始不赋值 只能赋一次 ; 而 final 不仅有 const 的编译时常量的特性，最重要的它是运行时常量，并且 final 是惰性初始化，即在运行时第一次使用前才初始化\n- 永远不改量的量，请使用 final 或 const 修饰它，而不是使用 var 或其他变量类型。\n\n```dart\nvoid main(){\n\n/\\*\nvar str=\'this is a str\';\n\nstr=\'你好 str\';\n\nprint(str);\n\nint myNum=1234;\n\nmyNum=4567;\n\nprint(myNum);\n\\*/\n\n//const 常量\n\n// const PI=3.14159;\n\n// PI=123.1243; //错误的写法 常量不可以修改\n\n// print(PI);\n\n// final 常量\n\n    // final PI=3.14159;\n    // PI=124214.214124;   //错误写法\n    // print(PI);\n\n\n\n    final a=new DateTime.now();\n    print(a);   //2022-07-07 14:27:23.856542\n\n\n    //const a=new DateTime.now();   //报错了\n\n    //区别：final 可以开始不赋值 只能赋一次 ; 而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化\n\n\n    final b;\n    b =10;\n    print(b); //10\n\n}\n```\n\n### 数据类型\n\n**常用数据类型**\n\n- Numbers（数值）:`int` `double`\n- Strings（字符串）: `String`\n- Booleans(布尔): `bool`\n- List（数组）: 在 Dart 中，数组是列表对象，所以大多数人只是称它们为列表\n- Maps（字典）\n\n通常来说，Map 是一个键值对相关的对象。 键和值可以是任何类型的对象。每个 键 只出现一次， 而一个值则可以出现多次\n\n#### 字符串类型\n\n```dart\nvoid main(){\n\n  //1、字符串定义的几种方式\n  // var str1=\'this is str1\';\n  // var str2=\"this is str2\";\n\n  // print(str1);\n  // print(str2);\n\n\n\n  // String str1=\'this is str1\';\n  // String str2=\"this is str2\";\n  // print(str1);\n  // print(str2);\n\n\n\n  // String str1=\'\'\'this is str1\n  // this is str1\n  // this is str1\n  // \'\'\';\n  //  print(str1);\n\n\n\n  //   String str1=\"\"\"\n  //   this is str1\n  //   this is str1\n  //   this is str1\n  //   \"\"\";\n  //  print(str1);\n\n\n\n  //2、字符串的拼接\n\n  String str1=\'你好\';\n  String str2=\'Dart\';\n  // print(\"$str1 $str2\");\n\n\n  print(str1 + str2);\n  print(str1 +\" \"+ str2);\n\n}\n```\n\n#### 数值类型\n\n```dart\n/*\nDart数据类型：数值类型\n    int\n    double\n*/\n\nvoid main(){\n\n  // 1、int   必须是整型\n\n    int a=123;\n    a=45;\n    print(a);\n\n\n  // 2、double  既可以是整型 也可是浮点型\n\n    double b=23.5;\n    b=24;\n    print(b);\n\n  // 3、运算符\n\n    // + - * / %\n\n    var c=a+b;\n    print(c);\n}\n```\n\n#### 布尔类型\n\n```dart\n/*\nDart数据类型：布尔类型\nbool 值true/false\n*/\n\nvoid main(){\n\n  // 1、bool\n\n        // bool flag1=true;\n        // print(flag1);\n\n        // bool flag2=false;\n        // print(flag2);\n\n\n  // 2、条件判断语句\n\n\n      // var flag=true;\n      // if(flag){\n      //   print(\'真\');\n      // }else{\n      //   print(\'假\');\n      // }\n\n\n      // var a=123;\n      // var b=\'123\';\n      // if(a==b){\n      //   print(\'a=b\');\n      // }else{\n      //    print(\'a!=b\');\n      // }\n\n\n      var a=123;\n      var b=123;\n      if(a==b){\n        print(\'a=b\');\n      }else{\n         print(\'a!=b\');\n      }\n\n}\n```\n\n#### List（数组/集合）\n\n```dart\n\nvoid main() {\n  //1、第一种定义List的方式\n\n  // var l1=[\"张三\",20,true];\n  // print(l1);  //[张三, 20, true]\n  // print(l1.length);  //3\n  // print(l1[0]); //张三\n  // print(l1[1]); //20\n\n  //2、第二种定义List的方式 指定类型\n\n  // var l2=<String>[\"张三\",\"李四\"];\n  // print(l2);\n\n  // var l3 = <int>[12, 30];\n  // print(l3);\n\n  //3、第三种定义List的方式  增加数据 ,通过[]创建的集合它的容量可以变化\n\n  // var l4 = [];\n  // print(l4);\n  // print(l4.length);\n\n  // l4.add(\"张三\");\n  // l4.add(\"李四\");\n  // l4.add(20);\n  // print(l4);\n  // print(l4.length);\n\n  // var l5 = [\"张三\", 20, true];\n  // l5.add(\"李四\");\n  // l5.add(\"zhaosi\");\n  // print(l5);\n\n\n  //4、第四种定义List的方式\n\n    //  var l6=new List();  //在新版本的dart里面没法使用这个方法了\n\n    // var l6=List.filled(2, \"\");  //创建一个固定长度的集合\n    // print(l6);\n    // print(l6[0]);\n\n    // l6[0]=\"张三\";   //修改集合的内容\n    // l6[1]=\"李四\";\n    // print(l6);  //[张三, 李四]\n    // l6.add(\"王五\");  //错误写法  通过List.filled创建的集合长度是固定  没法增加数据\n\n\n    //通过List.filled创建的集合长度是固定\n    // var l6=List.filled(2, \"\");\n    // print(l6.length);\n    // l6.length=0;  //修改集合的长度   报错\n\n\n    // var l7=<String>[\"张三\",\"李四\"];\n    // print(l7.length);  //2\n    // l7.length=0;  //可以改变的\n    // print(l7);  //[]\n\n\n    var l8=List<String>.filled(2, \"\");\n    l8[0]=\"string\";\n    // l8[0]=222;\n    print(l8);\n}\n```\n\n#### Maps（字典）\n\n```dart\n\nvoid main(){\n\n  //第一种定义 Maps的方式\n\n    // var person={\n    //   \"name\":\"张三\",\n    //   \"age\":20,\n    //   \"work\":[\"程序员\",\"送外卖\"]\n    // };\n\n    // print(person);\n    // print(person[\"name\"]);\n    // print(person[\"age\"]);\n    // print(person[\"work\"]);\n\n   //第二种定义 Maps的方式\n\n    var p=new Map();\n    p[\"name\"]=\"李四\";\n    p[\"age\"]=22;\n    p[\"work\"]=[\"程序员\",\"送外卖\"];\n    print(p);\n    print(p[\"age\"]);\n}\n```\n\n#### 类型判断\n\nis 关键词来判断类型\n\n```dart\n\nvoid main(){\n\n  // var str=\'1234\';\n  // if(str is String){\n  //   print(\'是string类型\');\n  // }else if(str is int){\n  //    print(\'int\');\n  // }else{\n  //    print(\'其他类型\');\n  // }\n\n\n  var str=123;\n  if(str is String){\n    print(\'是string类型\');\n  }else if(str is int){\n     print(\'int\');\n  }else{\n     print(\'其他类型\');\n  }\n}\n```\n\n### 运算符\n\n#### 算术运算符\n\n```dart\nvoid main(){\n\n  int a=13;\n  int b=5;\n\n  print(a+b);   //加\n  print(a-b);   //减\n  print(a*b);   //乘\n  print(a/b);   //除\n  print(a%b);   //其余\n  print(a~/b);  //取整\n\n  var c=a*b;\n  print(\'--------\');\n  print(c);\n\n}\n```\n\n#### 关系运算符\n\n```dart\nvoid main(){\n  //  ==    ！=   >    <    >=    <=\n\n  int a=5;\n  int b=3;\n\n  print(a==b);   //判断是否相等\n  print(a!=b);   //判断是否不等\n  print(a>b);   //判断是否大于\n  print(a<b);   //判断是否小于\n  print(a>=b);   //判断是否大于等于\n  print(a<=b);   //判断是否小于等于\n\n\n  if(a>b){\n    print(\'a大于b\');\n  }else{\n    print(\'a小于b\');\n  }\n\n\n}\n```\n\n#### 逻辑运算符\n\n```dart\nvoid main(){\n\n  /* ! 取反 */\n\n  // bool flag=false;\n  // print(!flag);   //取反\n\n\n /* &&并且:全部为true的话值为true 否则值为false */\n\n  // bool a=true;\n  // bool b=true;\n  // print(a && b);\n\n\n /* ||或者：全为false的话值为false 否则值为true */\n\n  // bool a=false;\n  // bool b=false;\n  // print(a || b);\n\n\n\n//如果一个人的年龄是20 并且 sex是女的话我们打印这个人\n\n  // int age=20;\n  // String sex=\"女\";\n  // if(age==20 && sex==\"女\"){\n  //   print(\"$age --- $sex\");\n  // }else{\n  //   print(\"不打印\");\n  // }\n\n\n\n//如果一个人的年龄是20 或者 sex是女的话我们打印这个人\n\n  int age=23;\n  String sex=\"女\";\n  if(age==20 || sex==\"女\"){\n    print(\"$age --- $sex\");\n  }else{\n    print(\"不打印\");\n  }\n\n}\n```\n\n#### 赋值运算符\n\n```dart\nvoid main(){\n\n//  1、基础赋值运算符   =   ??=\n\n        // int a=10;\n        // int b=3;\n        // print(a);\n        // int c=a+b;   //从右向左\n\n\n    // b??=23;  表示如果b为空的话把 23赋值给b\n\n        // int b=6;\n        // b??=23;\n        // print(b);\n\n        // int b;\n        // b??=23;\n        // print(b);\n\n\n//2、  复合赋值运算符   +=  -=  *=   /=   %=  ~/=\n\n    // var a=12;\n    // a=a+10;\n    // print(a);\n\n    // var a=13;\n    // a+=10;   //表示a=a+10\n    // print(a);\n\n\n   var a=4;\n   a*=3;  //a=a*3;\n   print(a);\n}\n```\n\n#### 条件表达式\n\n```dart\nvoid main(){\n\n  //1、if  else   switch case\n\n\n    // bool flag=true;\n    // if(flag){\n    //   print(\'true\');\n    // }else{\n    //   print(\'false\');\n    // }\n\n\n  //判断一个人的成绩 如果大于60 显示及格   如果大于 70显示良好  如果大于90显示优秀\n\n  // var score=41;\n  // if(score>90){\n  //   print(\'优秀\');\n  // }else if(score>70){\n  //    print(\'良好\');\n  // }else if(score>=60){\n  //   print(\'及格\');\n  // }else{\n  //   print(\'不及格\');\n  // }\n\n\n  // var sex=\"女\";\n  // switch(sex){\n  //   case \"男\":\n  //     print(\'性别是男\');\n  //     break;\n  //   case \"女\":\n  //     print(\'性别是女\');\n  //     print(\'性别是女\');\n  //     break;\n  //   default:\n  //     print(\'传入参数错误\');\n  //     break;\n  // }\n\n\n  //2、三目运算符\n\n  // var falg=true;\n  // var c;\n  // if(falg){\n  //     c=\'我是true\';\n  // }else{\n  //   c=\"我是false\";\n  // }\n  // print(c);\n\n\n\n  bool flag = false;\n  String c = flag ? \'我是true\':\'我是false\';\n  print(c);\n\n\n  // 3  ??运算符\n\n  // var a;\n  // var b= a ?? 10;\n  // print(b);   10\n\n\n  var a=22;\n  var b= a ?? 10;\n  print(b);\n}\n```\n\n#### 类型转换\n\n```dart\nvoid main(){\n\n    //1、Number与String类型之间的转换\n\n      // Number类型转换成String类型 toString()\n      // String类型转成Number类型  int.parse()\n\n\n      // String str=\'123\';\n      // var myNum=int.parse(str);\n      // print(myNum is int);\n\n\n      // String str=\'123.1\';\n      // var myNum=double.parse(str);\n      // print(myNum is double);\n\n\n      //  String price=\'12\';\n      // var myNum=double.parse(price);\n      // print(myNum);\n      // print(myNum is double);\n\n\n      //报错\n      // String price=\'\';\n      // var myNum=double.parse(price);\n      // print(myNum);\n      // print(myNum is double);\n\n\n\n    // try  ... catch\n    //  String price=\'\';\n    //   try{\n    //     var myNum=double.parse(price);\n    //     print(myNum);\n    //   }catch(err){\n    //        print(0);\n    //   }\n\n    // var myNum=12;\n    // var str=myNum.toString();\n    // print(str is String);\n\n // 2、其他类型转换成Booleans类型\n\n        // isEmpty:判断字符串是否为空\n\n\n        // var str=\'\';\n        // if(str.isEmpty){\n        //   print(\'str空\');\n        // }else{\n        //   print(\'str不为空\');\n        // }\n\n\n        // var myNum=123;\n        // if(myNum==0){\n        //    print(\'0\');\n        // }else{\n        //   print(\'非0\');\n        // }\n\n\n        // var myNum;\n        // if(myNum==0){\n        //    print(\'0\');\n        // }else{\n        //   print(\'非0\');\n        // }\n\n\n\n        // var myNum;\n        // if(myNum==null){\n        //    print(\'空\');\n        // }else{\n        //   print(\'非空\');\n        // }\n\n\n\n        var myNum=0/0;\n        // print(myNum);\n        if(myNum.isNaN){\n          print(\'NaN\');\n        }\n}\n```\n\n### 循环语句\n\n#### 自增 自减\n\n在赋值运算里面 如果++ -- 写在前面 这时候先运算 再赋值，如果++ --写在后面 先赋值后运行运算\n\n```dart\nvoid main(){\n  /*\n     ++  --   表示自增 自减 1\n\n    var a=10;\n    var b=a--;\n\n    print(a);  //9\n    print(b);  //10\n\n  */\n\n\n    // var a=10;\n    // a++;   //a=a+1;\n    // print(a);\n\n\n\n    // var a=10;\n    // a--;    //a=a-1;\n    // print(a);\n\n\n\n    // var a=10;\n    // var b=a++;\n\n    // print(a);  //11\n    // print(b);  //10\n\n\n\n    // var a=10;\n    // var b=++a;\n\n    // print(a);  //11\n    // print(b);  //11\n\n\n\n\n    // var a=10;\n    // var b=--a;\n\n    // print(a);  //9\n    // print(b);  //9\n\n\n\n    // var a=10;\n    // var b=a--;\n\n    // print(a);  //9\n    // print(b);  //10\n\n\n    var a=10;\n    ++a;\n    print(a);\n}\n```\n\n#### for 基本语法\n\n```dart\n/*\n\n// for基本语法\n  for (int i = 1; i<=100; i++) {\n    print(i);\n  }\n\n  //第一步，声明变量int i = 1;\n  //第二步，判断i <=100\n  //第三步，print(i);\n  //第四步，i++\n  //第五步 从第二步再来，直到判断为false\n*/\n\nvoid main(){\n\n  // for(int i=1;i<=10;i++){\n  //     print(i);\n  // }\n\n\n  //1、打印0-50所有的偶数\n\n    // for(int i=0;i<=50;i++){\n    //     if(i%2==0){\n    //       print(i);\n    //     }\n    // }\n\n  //2、求 1+2+3+4 +...100的和\n\n    // var sum=0;\n    // for(var i=1;i<=100;i++){\n    //     sum+=i;\n    // }\n    // print(sum);\n\n    /*\n      sum=0+1;\n      sum=0+1+2;\n      sum=0+1+2+3+...+100;\n\n    */\n\n  // 3、计算5的阶乘   (1*2*3*4*5    n的阶乘1*2……*n)\n\n    // var sum=1;\n    // for(var i=1;i<=5;i++){\n    //     sum*=i;\n    // }\n    // print(sum);\n\n    /*\n    sum=1*1;\n\n    sum=1*1*2;\n\n    sum=1*1*3;\n\n    sum=1*1*3*4*5;\n    */\n\n  //4、打印List  [\'张三\',\'李四\',\'王五\'] 里面的内容\n\n\n    // List list=[\'张三\',\'李四\',\'王五\'];\n    // print(list[1]);\n    // for(var i=0;i<list.length;i++){\n    //   print(list[i]);\n    // }\n\n  //5、打印List\n\n    // List list=[{\n    //   \"title\":\"新闻111\"\n    // },\n    // {\n    //   \"title\":\"新闻222\"\n    // },\n    // {\n    //   \"title\":\"新闻333\"\n    // }];\n\n    // print(list[1]);\n\n    // for(var i=0;i<list.length;i++){\n    //   print(list[i][\'title\']);\n    // }\n\n\n  //4、定义一个二维数组 打印里面的内容\n\n        List list=[\n          {\n              \"cate\":\'国内\',\n              \"news\":[\n                {\"title\":\"国内新闻1\"},\n                {\"title\":\"国内新闻2\"},\n                {\"title\":\"国内新闻3\"}\n              ]\n          },\n          {\n              \"cate\":\'国际\',\n              \"news\":[\n                {\"title\":\"国际新闻1\"},\n                {\"title\":\"国际新闻2\"},\n                {\"title\":\"国际新闻3\"}\n              ]\n          }\n        ];\n\n        /*\n        国内\n            国内新闻1\n            国内新闻2\n            国内新闻3\n        国际\n            国际新闻1\n            国际新闻2\n        */\n\n\n        for(var i=0;i<list.length;i++){\n            print(list[i][\"cate\"]);\n            print(\'-------------\');\n            for(var j=0;j<list[i][\"news\"].length;j++){\n                print(list[i][\"news\"][j][\"title\"]);\n            }\n        }\n\n}\n```\n\n#### while do...while\n\n```dart\n/*\n	语法格式:\n\n		while(表达式/循环条件){\n\n		}\n\n		do{\n			语句/循环体\n\n		}while(表达式/循环条件);\n\n注意： 1、最后的分号不要忘记\n      2、循环条件中使用的变量需要经过初始化\n      3、循环体中，应有结束循环的条件，否则会造成死循环。\n*/\n\n\nvoid main(){\n\n /*\n    int i=1;\n    while(i<=10){\n        print(i);\n    }\n    //死循环\n\n */\n\n\n    // int i=1;\n    // while(i<=10){\n    //     print(i);\n    //     i++;\n    // }\n\n\n//1、求1+2+3+4 ...+100的和\n\n\n    // int i=1;\n    // var sum=0;\n    // while(i<=100){\n    //    sum+=i;\n    //    i++;\n    // }\n    // print(sum);\n\n\n    // int i=1;\n    // var sum=0;\n    // do{\n    //    sum+=i;\n    //    i++;\n    // }while(i<=100);\n    // print(sum);\n\n  //while 和 do while的区别   第一次循环条件不成立的情况下\n    // int i=10;\n	  // while(i<2){\n	  // 	print(\'执行代码\');\n	  // }\n\n\n	  var j=10;\n	  do{\n	  	print(\'执行代码\');\n	  }while(j<2);\n\n}\n```\n\n#### break 和 continue\n\n**break 语句功能:**\n\n1. 在 switch 语句中使流程跳出 switch 结构。\n2. 在循环语句中使流程跳出当前循环,遇到 break 循环终止，后面代码也不会执行\n\n**强调:**\n\n1. 如果在循环中已经执行了 break 语句,就不会执行循环体中位于 break 后的语句。\n2. 在多层循环中,一个 break 语句只能向外跳出一层\n\nbreak 可以用在 switch case 中 也可以用在 for 循环和 while 循环中\n\n**continue 语句的功能:**\n\n-【注】只能在循环语句中使用,使本次循环结束，即跳过循环体重下面尚未执行的语句，接着进行下次的是否执行循环的判断。\n\n- continue 可以用在 for 循环以及 while 循环中，但是不建议用在 while 循环中，不小心容易死循环\n\n```dart\nmain() {\n    // for(var i=1;i<=10;i++){\n    //   print(i);\n    // }\n\n\n    //1、如果i等于4的话跳过\n\n    // for(var i=1;i<=10;i++){\n    //   if(i==4){\n    //     continue;  /*跳过当前循环体 然后循环还会继续执行*/\n    //   }\n    //   print(i);\n    // }\n\n\n\n    //2、如果 i等于4的话跳出循环\n\n    // for(var i=1;i<=10;i++){\n    //   if(i==4){\n    //     break;  /*跳出循环体*/\n    //   }\n    //   print(i);\n    // }\n\n\n    //3、break语句只能向外跳出一层\n\n\n    	//  for(var i=0;i<5;i++){\n			//   	print(\'外层---$i\');\n      //     for(var j=0;j<3;j++){\n      //       if(j==1){\n      //         break;\n      //       }\n      //       print(\'里层$j\');\n      //     }\n			//  }\n\n\n\n  //4、while循环 break跳出循环\n\n  var i=1;\n  while(i<=10){\n    if(i==4){\n      break;\n    }\n    print(i);\n    i++;\n  }\n\n\n  // var sex=\"男\";\n  // switch (sex) {\n  //   case \"男\":\n  //     print(\'男\');\n  //     break;\n  //   case \"女\":\n  //     print(\'男\');\n  //     break;\n  //   default:\n  // }\n\n}\n```\n\n### 数据类型扩展\n\n#### List 常用的属性和方法\n\n```dart\n/*\nList里面常用的属性和方法：\n\n    常用属性：\n        length          长度\n        reversed        翻转\n        isEmpty         是否为空\n        isNotEmpty      是否不为空\n    常用方法：\n        add         增加\n        addAll      拼接数组\n        indexOf     查找  传入具体值\n        remove      删除  传入具体值\n        removeAt    删除  传入索引值\n        fillRange   修改\n        insert(index,value);            指定位置插入\n        insertAll(index,list)           指定位置插入List\n        toList()    其他类型转换成List\n        join()      List转换成字符串\n        split()     字符串转化成List\n        forEach\n        map\n        where\n        any\n        every\n\n*/\n\n\nvoid main(){\n\n  // List myList=[\'香蕉\',\'苹果\',\'西瓜\'];\n  // print(myList[1]);\n\n\n  // var list=new List();  //新版本没法使用\n  // list.add(\'111\');\n  // list.add(\'222\');\n  // print(list);\n\n\n//List里面的属性：\n    // List myList=[\'香蕉\',\'苹果\',\'西瓜\'];\n    // print(myList.length);\n    // print(myList.isEmpty);\n    // print(myList.isNotEmpty);\n    // print(myList.reversed);  //对列表倒序排序\n    // var newMyList=myList.reversed.toList();\n    // print(newMyList);\n\n//List里面的方法：\n\n\n    // List myList=[\'香蕉\',\'苹果\',\'西瓜\'];\n    //myList.add(\'桃子\');   //增加数据  增加一个\n    // myList.addAll([\'桃子\',\'葡萄\']);  //拼接数组\n    // print(myList);\n    //print(myList.indexOf(\'苹x果\'));    //indexOf查找数据 查找不到返回-1  查找到返回索引值\n\n\n    // myList.remove(\'西瓜\');\n    // myList.removeAt(1);\n    // print(myList);\n\n\n\n    // List myList=[\'香蕉\',\'苹果\',\'西瓜\'];\n    // myList.fillRange(1, 2,\'aaa\');  //修改\n    // myList.fillRange(1, 3,\'aaa\');\n\n    // myList.insert(1,\'aaa\');      //插入  一个\n    // myList.insertAll(1, [\'aaa\',\'bbb\']);  //插入 多个\n    // print(myList);\n\n\n    // List myList=[\'香蕉\',\'苹果\',\'西瓜\'];\n    // var str=myList.join(\'-\');   //list转换成字符串\n    // print(str);\n    // print(str is String);  //true\n\n\n    var str=\'香蕉-苹果-西瓜\';\n    var list=str.split(\'-\');\n    print(list);\n    print(list is List);\n\n}\n```\n\n#### Set\n\n- 用它最主要的功能就是去除数组重复内容\n- Set 是没有顺序且不能重复的集合，所以不能通过索引去获取值\n\n```dart\nvoid main(){\n  // var s=new Set();\n  // s.add(\'香蕉\');\n  // s.add(\'苹果\');\n  // s.add(\'苹果\');\n  // print(s);   //{香蕉, 苹果}\n  // print(s.toList());\n\n\n  List myList=[\'香蕉\',\'苹果\',\'西瓜\',\'香蕉\',\'苹果\',\'香蕉\',\'苹果\'];\n  var s=new Set();\n  s.addAll(myList);\n  print(s);\n  print(s.toList());\n\n}\n```\n\n#### Map\n\n```dart\n/*\n  映射(Maps)是无序的键值对：\n\n    常用属性：\n        keys            获取所有的key值\n        values          获取所有的value值\n        isEmpty         是否为空\n        isNotEmpty      是否不为空\n    常用方法:\n        remove(key)     删除指定key的数据\n        addAll({...})   合并映射  给映射内增加属性\n        containsValue   查看映射内的值  返回true/false\n        forEach\n        map\n        where\n        any\n        every\n*/\n\nvoid main() {\n  // 指定类型\n  // Map person={\n  //   \"name\":\"张三\",\n  //   \"age\":20\n  // };\n\n  // var m=new Map();\n  // m[\"name\"]=\"李四\";\n  // print(person);\n  // print(m);\n\n//常用属性：\n\n  // Map person={\n  //   \"name\":\"张三\",\n  //   \"age\":20,\n  //   \"sex\":\"男\"\n  // };\n\n  // print(person.keys.toList());\n  // print(person.values.toList());\n  // print(person.isEmpty);\n  // print(person.isNotEmpty);\n\n//常用方法：\n  Map person = {\"name\": \"张三\", \"age\": 20, \"sex\": \"男\"};\n\n  // person.addAll({\n  //   \"work\":[\'敲代码\',\'送外卖\'],\n  //   \"height\":160\n  // });\n  // print(person);\n\n  // person.remove(\"sex\");\n  // print(person);\n\n  print(person.containsValue(\'张三\'));\n}\n```\n\n#### List,Set,Map 常用的方法\n\n```dart\n/*\n        forEach\n        map\n        where\n        any\n        every\n*/\nvoid main(){\n\n\n      //  List myList=[\'香蕉\',\'苹果\',\'西瓜\'];\n      // for(var i=0;i<myList.length;i++){\n      //   print(myList[i]);\n      // }\n\n\n      // for(var item in myList){\n      //   print(item);\n      // }\n\n\n      // myList.forEach((value){\n      //     print(\"$value\");\n      // });\n\n\n      // List myList=[1,3,4];\n      // List newList=new List();\n      // for(var i=0;i<myList.length;i++){\n      //   newList.add(myList[i]*2);\n      // }\n      // print(newList);\n\n\n      // List myList=[1,3,4];\n      // var newList=myList.map((value){\n      //     return value*2;\n      // });\n      // print(newList.toList());\n\n\n      // List myList=[1,3,4,5,7,8,9];\n      // var newList=myList.where((value){\n      //     return value>5;\n      // });\n      // print(newList.toList());\n\n\n\n      // List myList=[1,3,4,5,7,8,9];\n      // var f=myList.any((value){   //只要集合里面有满足条件的就返回true\n      //     return value>5;\n      // });\n      // print(f);\n\n\n\n      // List myList=[1,3,4,5,7,8,9];\n      // var f=myList.every((value){   //每一个都满足条件返回true  否则返回false\n      //     return value>5;\n      // });\n      // print(f);\n\n      // set\n\n      // var s=new Set();\n\n      // s.addAll([1,222,333]);\n\n      // s.forEach((value)=>print(value));\n\n      //map\n\n       Map person={\n          \"name\":\"张三\",\n          \"age\":20\n        };\n\n        person.forEach((key,value){\n            print(\"$key---$value\");\n        });\n}\n```\n\n## 高级内容\n\n### 函数\n\n#### 方法的定义 变量 方法的作用域\n\n```dart\n/*\n  内置方法/函数：\n\n      print();\n\n  自定义方法：\n      自定义方法的基本格式：\n\n      返回类型  方法名称（参数1，参数2,...）{\n        方法体\n        return 返回值;\n      }\n*/\n\nvoid printInfo(){\n  print(\'我是一个自定义方法\');\n}\n\nint getNum(){\n  var myNum=123;\n  return myNum;\n}\n\nString printUserInfo(){\n  return \'this is str\';\n}\n\n\nList getList(){\n  return [\'111\',\'2222\',\'333\'];\n}\n\nvoid main(){\n\n  // print(\'调用系统内置的方法\');\n\n  // printInfo();\n  // var n=getNum();\n  // print(n);\n\n\n  // print(printUserInfo());\n\n\n  // print(getList());\n  // print(getList());\n\n\n//演示方法的作用域\n  void xxx(){\n      aaa(){\n\n          print(getList());\n          print(\'aaa\');\n      }\n      aaa();\n  }\n\n  // aaa();  错误写法\n  xxx();  //调用方法\n}\n```\n\n#### 方法传参 、默认参数、可选参数、命名参数 、方法作为参数\n\n```dart\n//调用方法传参\n\nmain() {\n//1、定义一个方法 求1到这个数的所有数的和      60    1+2+3+。。。+60\n  /*\n    int sumNum(int n){\n      var sum=0;\n      for(var i=1;i<=n;i++)\n      {\n        sum+=i;\n      }\n      return sum;\n    }\n\n    var n1=sumNum(5);\n    print(n1);\n    var n2=sumNum(100);\n    print(n2);\n\n */\n\n//2、定义一个方法然后打印用户信息\n\n  // String printUserInfo(String username, int age) {\n  //   //行参\n  //   return \"姓名:$username---年龄:$age\";\n  // }\n  // print(printUserInfo(\'张三\', 20)); //实参\n\n\n//3、定义一个带可选参数的方法 ，最新的dart定义可选参数需要指定类型默认值\n\n  // String printUserInfo(String username,[int age=0]){  //行参\n  //   if(age!=0){\n  //     return \"姓名:$username---年龄:$age\";\n  //   }\n  //   return \"姓名:$username---年龄保密\";\n  // }\n  // print(printUserInfo(\'张三\',21)); //实参\n  // print(printUserInfo(\'张三\'));\n\n//4、定义一个带默认参数的方法\n  // String printUserInfo(String username,[String sex=\'男\',int age=0]){  //行参\n  //   if(age!=0){\n  //     return \"姓名:$username---性别:$sex--年龄:$age\";\n  //   }\n  //   return \"姓名:$username---性别:$sex--年龄保密\";\n  // }\n  // print(printUserInfo(\'张三\'));\n  // print(printUserInfo(\'小李\',\'女\'));\n  // print(printUserInfo(\'小李\',\'女\',30));\n\n//5、定义一个命名参数的方法，最新的dart定义命名参数需要指定类型默认值\n\n  // String printUserInfo(String username, {int age = 0, String sex = \'男\'}) {//行参\n  //   if (age != 0) {\n  //     return \"姓名:$username---性别:$sex--年龄:$age\";\n  //   }\n  //   return \"姓名:$username---性别:$sex--年龄保密\";\n  // }\n  // print(printUserInfo(\'张三\', age: 20, sex: \'未知\'));\n\n\n//6、实现一个 把方法当做参数的方法\n\n  // var fn=(){\n  //   print(\'我是一个匿名方法\');\n  // };\n  // fn();\n\n\n  //fn1方法\n  fn1() {\n    print(\'fn1\');\n  }\n  //fn2方法\n  fn2(fn) {\n    fn();\n  }\n  //调用fn2这个方法 把fn1这个方法当做参数传入\n  fn2(fn1);\n}\n```\n\n#### 箭头函数 函数的相互调用\n\n```dart\nvoid main() {\n/*需求：使用forEach打印下面List里面的数据*/\n\n  // List list=[\'苹果\',\'香蕉\',\'西瓜\'];\n  // list.forEach((value){\n  //   print(value);\n  // });\n  // list.forEach((value)=>print(value));\n\n  //注意和方法的区别: 箭头函数内只能写一条语句，并且语句后面没有分号(;)\n  // list.forEach((value)=>{\n  //   print(value)\n  // });\n\n/*需求：修改下面List里面的数据，让数组中大于2的值乘以2*/\n\n  // List list=[4,1,2,3,4];\n  // var newList=list.map((value){\n  //     if(value>2){\n  //       return value*2;\n  //     }\n  //     return value;\n  // });\n  // print(newList.toList());\n  //  var newList=list.map((value)=>value>2?value*2:value);\n  //  print(newList.toList());\n\n\n/*\n需求：    1、定义一个方法isEvenNumber来判断一个数是否是偶数\n         2、定义一个方法打印1-n以内的所有偶数\n*/\n\n// 1、定义一个方法isEvenNumber来判断一个数是否是偶数\n  bool isEvenNumber(int n) {\n    if (n % 2 == 0) {\n      return true;\n    }\n    return false;\n  }\n//  2、定义一个方法打印1-n以内的所有偶数\n  printNum(int n) {\n    for (var i = 1; i <= n; i++) {\n      if (isEvenNumber(i)) {\n        print(i);\n      }\n    }\n  }\n  printNum(10);\n}\n```\n\n#### 匿名方法 自执行方法 方法的递归\n\n```dart\nint getNum(int n) {\n  return n;\n}\n\nvoid main() {\n  // print(getNum(12));\n\n  //匿名方法\n  // var printNum=(){\n  //   print(123);\n  // };\n  // printNum();\n\n  // var printNum=(int n){\n  //   print(n+2);\n  // };\n  // printNum(12);\n\n//自执行方法\n\n  // ((int n){\n  //   print(n);\n  //   print(\'我是自执行方法\');\n  // })(12);\n\n//方法的递归\n  // var sum = 1;\n  // fn(int n) {\n  //   sum *= n;\n  //   if (n == 1) {\n  //     return;\n  //   }\n  //   fn(n - 1);\n  // }\n  // fn(5);\n  // print(sum);\n\n//通过方法的递归 求1-100的和\n\n  var sum=0;\n  fn(int n){\n      sum+=n;\n      if(n==0){\n        return;\n      }\n      fn(n-1);\n  }\n\n  fn(100);\n  print(sum);\n}\n```\n\n#### 闭包\n\n```dart\n/*\n闭包：\n\n    1、全局变量特点:    全局变量常驻内存、全局变量污染全局\n    2、局部变量的特点：  不常驻内存会被垃圾机制回收、不会污染全局\n\n\n  /*  想实现的功能：\n\n        1.常驻内存\n        2.不污染全局\n\n          产生了闭包,闭包可以解决这个问题.....\n\n          闭包: 函数嵌套函数, 内部函数会调用外部函数的变量或参数, 变量或参数不会被系统回收(不会释放内存)\n\n	        闭包的写法： 函数嵌套函数，并return 里面的函数，这样就形成了闭包。\n\n    */\n*/\n\n/*全局变量*/\nvar a = 123;\n\nvoid main() {\n  // print(a);\n\n  // fn(){\n  //   a++;\n  //   print(a);\n  // }\n  // fn();\n  // fn();\n  // fn();\n\n//局部变量\n  // printInfo() {\n  //   var myNum = 123;\n  //   myNum++;\n  //   print(myNum);\n  // }\n\n  // printInfo();\n  // printInfo();\n  // printInfo();\n\n//闭包\n\n  fn() {\n    var a = 123; /*不会污染全局   常驻内存*/\n    return () {\n      a++;\n      print(a);\n    };\n  }\n\n  var b = fn();\n  b();\n  b();\n  b();\n}\n```\n\n### 类\n\n面向对象编程(OOP)的三个基本特征是：封装、继承、多态\n\n- 封装：封装是对象和类概念的主要特性。封装，把客观事物封装成抽象的类，并且把自己的部分属性和方法提供给其他对象调用, 而一部分属性和方法则隐藏。\n- 继承：面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。\n- 多态：允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。\n\nDart 所有的东西都是对象，所有的对象都继承自 Object 类。\n\nDart 是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是 Object 的子类\n\n一个类通常由属性和方法组成。\n\n#### 创建类，使用类\n\n```dart\n/*\n\nDart是一门使用类和单继承的面向对象语言，所有的对象都是类的实例，并且所有的类都是Object的子类\n\n*/\n\nclass Person{\n  String name=\"张三\";\n  int age=23;\n  void getInfo(){\n      // print(\"$name----$age\");\n      print(\"${this.name}----${this.age}\");\n  }\n  void setInfo(int age){\n    this.age=age;\n  }\n\n}\nvoid main(){\n\n  //实例化\n\n  // var p1=new Person();\n  // print(p1.name);\n  // p1.getInfo();\n\n  Person p1=new Person();\n  // print(p1.name);\n  p1.setInfo(28);\n  p1.getInfo();\n}\n```\n\n#### 自定义类的默认构造函数\n\n```dart\n\n// class Person{\n//   String name=\'张三\';\n//   int age=20;\n//   //默认构造函数\n//   Person(){\n//     print(\'这是构造函数里面的内容  这个方法在实例化的时候触发\');\n//   }\n//   void printInfo(){\n//     print(\"${this.name}----${this.age}\");\n//   }\n// }\n\n\n//最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late\n// class Person{\n//   late String name;\n//   late int age;\n//   //默认构造函数\n//   Person(String name,int age){\n//       this.name=name;\n//       this.age=age;\n//   }\n//   void printInfo(){\n//     print(\"${this.name}----${this.age}\");\n//   }\n// }\n\n//最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late\nclass Person{\n  late String name;\n  late int age;\n  //默认构造函数的简写\n  Person(this.name,this.age);\n  void printInfo(){\n    print(\"${this.name}----${this.age}\");\n  }\n}\n\n\nvoid main(){\n\n  Person p1=new Person(\'张三\',20);\n  p1.printInfo();\n\n\n  Person p2=new Person(\'李四\',25);\n  p2.printInfo();\n\n}\n```\n\n#### 自定义类的命名构造函数\n\n```dart\n\n/*\ndart里面构造函数可以写多个\n\n注意：最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late\n*/\nclass Person {\n  late String name;\n  late int age;\n  //默认构造函数的简写\n  Person(this.name, this.age);\n  Person.now() {\n    print(\'我是命名构造函数\');\n  }\n  Person.setInfo(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n  void printInfo() {\n    print(\"${this.name}----${this.age}\");\n  }\n}\n\nvoid main() {\n  // var d=new DateTime.now();   //实例化DateTime调用它的命名构造函数\n  // print(d);\n\n  //Person p1=new Person(\'张三\', 20);   //默认实例化类的时候调用的是 默认构造函数\n\n  //Person p1=new Person.now();   //命名构造函数\n\n  Person p1 = new Person.setInfo(\'李四\', 30);\n  p1.printInfo();\n}\n```\n\n#### 把类单独抽离成一个模块\n\n```dart\nimport \'lib/Person.dart\';\n\nvoid main(){\n\n  Person p1=new Person.setInfo(\'李四1\',30);\n  p1.printInfo();\n\n}\n```\n\n#### 私有方法和私有属性\n\n```dart\n/*\nDart和其他面向对象语言不一样，Data中没有 public  private protected这些访问修饰符合\n\n但是我们可以使用_把一个属性或者方法定义成私有。\n\n*/\n\nimport \'lib/Animal.dart\';\n\nvoid main(){\n\n Animal a=new Animal(\'小狗\', 3);\n\n print(a.getName());\n\n a.execRun();   //间接的调用私有方法\n}\n```\n\n#### getter 和 setter 修饰符的用法\n\n```dart\n// class Rect{\n//   int height;\n//   int width;\n//   getArea(){\n//     return this.height*this.width;\n//   }\n// }\n\n\n// class Rect{\n//   num height;\n//   num width;\n//   Rect(this.height,this.width);\n//   area(){\n//     return this.height*this.width;\n//   }\n// }\n\n// void main(){\n//   Rect r=new Rect(10,4);\n//   print(\"面积:${r.area()}\");\n// }\n\n\n// class Rect{\n//   num height;\n//   num width;\n//   Rect(this.height,this.width);\n//   get area{\n//     return this.height*this.width;\n//   }\n// }\n\n// void main(){\n//   Rect r=new Rect(10,2);\n//   print(\"面积:${r.area}\");      //注意调用直接通过访问属性的方式访问area\n// }\n\n\nclass Rect{\n  late num height;\n  late num width;\n  Rect(this.height,this.width);\n  get area{\n    return this.height*this.width;\n  }\n  set areaHeight(value){\n    this.height=value;\n  }\n}\n\nvoid main(){\n  Rect r=new Rect(10,4);\n  // print(\"面积:${r.area()}\");\n  r.areaHeight=6;\n  print(r.area);\n}\n```\n\n#### 类中的初始化列表\n\n```dart\n// Dart中我们也可以在构造函数体运行之前初始化实例变量\n\nclass Rect{\n  int height;\n  int width;\n  Rect():height=2,width=10{\n    print(\"${this.height}---${this.width}\");\n  }\n  getArea(){\n    return this.height*this.width;\n  }\n}\n\nvoid main(){\n  Rect r=new Rect();\n  print(r.getArea());\n\n}\n```\n\n#### 类中的静态成员 静态方法\n\n```dart\n/*\nDart中的静态成员:\n\n  1、使用static 关键字来实现类级别的变量和函数\n\n  2、静态方法不能访问非静态成员，非静态方法可以访问静态成员\n\n*/\n\n// class Person {\n//   static String name = \'张三\';\n//   static void show() {\n//     print(name);\n//   }\n// }\n\n// main(){\n//   print(Person.name);\n//   Person.show();\n// }\n\n\nclass Person {\n  static String name = \'张三\';\n  int age=20;\n  static void show() {\n    print(name);\n  }\n  void printInfo(){  /*非静态方法可以访问静态成员以及非静态成员*/\n      // print(name);  //访问静态属性\n      // print(this.age);  //访问非静态属性\n      show();   //调用静态方法\n  }\n  static void printUserInfo(){//静态方法\n        print(name);   //静态属性\n        show();        //静态方法\n        //print(this.age);     //静态方法没法访问非静态的属性\n        // this.printInfo();   //静态方法没法访问非静态的方法\n        // printInfo();\n  }\n\n}\n\nmain(){\n  // print(Person.name);\n  // Person.show();\n\n  // Person p=new Person();\n  // p.printInfo();\n\n  Person.printUserInfo();\n}\n```\n\n#### Dart 中的对象操作符\n\n```dart\n/*\nDart中的对象操作符:\n\n    ?     条件运算符 （了解）   https://dart.dev/tools/diagnostic-messages#invalid_null_aware_operator\n    as    类型转换\n    is    类型判断\n    ..    级联操作 （连缀）  (记住)\n*/\n\nclass Person {\n  String name;\n  num age;\n  Person(this.name, this.age);\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n}\n\nmain() {\n  // Person p;\n  // p?.printInfo();   //已被最新的dart废弃 了解\n\n  //  Person p=new Person(\'张三\', 20);\n  //  p?.printInfo();   //已被最新的dart废弃 了解\n\n\n\n  Person p=new Person(\'张三\', 20);\n  if(p is Person){\n      p.name=\"李四\";\n  }\n  p.printInfo();\n  print(p is Object);\n\n\n\n  // var p1;\n  // p1=\'\';\n  // p1=new Person(\'张三1\', 20);\n  // p1.printInfo();\n  // (p1 as Person).printInfo();\n\n\n\n\n  //  Person p1=new Person(\'张三1\', 20);\n  //  p1.printInfo();\n  //  p1.name=\'张三222\';\n  //  p1.age=40;\n  //  p1.printInfo();\n\n\n\n\n  Person p1 = new Person(\'张三1\', 20);\n  p1.printInfo();\n  p1\n    ..name = \"李四\"\n    ..age = 30\n    ..printInfo();\n}\n```\n\n#### 类的继承-简单继承\n\n```dart\n/*\n\n面向对象的三大特性：封装 、继承、多态\n\nDart中的类的继承：\n    1、子类使用extends关键词来继承父类\n    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n    3、子类能复写父类的方法 getter和setter\n\n*/\n\nclass Person {\n  String name=\'张三\';\n  num age=20;\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n}\nclass Web extends Person{\n}\n\nmain(){\n  Web w=new Web();\n  print(w.name);\n  w.printInfo();\n}\n```\n\n#### 类的继承 super 关键词的使用 实例化自类给父类构造函数传参\n\n```dart\n/*\n面向对象的三大特性：封装 、继承、多态\n\nDart中的类的继承：\n    1、子类使用extends关键词来继承父类\n    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n    3、子类能复写父类的方法 getter和setter\n\n*/\n\nclass Person {\n  late String name;\n  late num age;\n  Person(this.name,this.age);\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n}\nclass Web extends Person{\n  Web(String name, num age) : super(name, age){\n  }\n}\n\nmain(){\n\n  // Person p=new Person(\'李四\',20);\n  // p.printInfo();\n\n  // Person p1=new Person(\'张三\',20);\n  // p1.printInfo();\n\n  Web w=new Web(\'张三\', 12);\n  w.printInfo();\n}\n```\n\n#### 类的继承 super 关键词的使用 实例化自类给父类构造函数传参\n\n```dart\n/*\n\n面向对象的三大特性：封装 、继承、多态\n\n\nDart中的类的继承：\n    1、子类使用extends关键词来继承父类\n    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n    3、子类能复写父类的方法 getter和setter\n\n   注意:最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late\n*/\n\nclass Person {\n  String name;\n  num age;\n  Person(this.name,this.age);\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n}\n\nclass Web extends Person{\n  late String sex;\n  Web(String name, num age,String sex) : super(name, age){\n    this.sex=sex;\n  }\n  run(){\n   print(\"${this.name}---${this.age}--${this.sex}\");\n  }\n}\n\nmain(){\n  // Person p=new Person(\'李四\',20);\n  // p.printInfo();\n\n  // Person p1=new Person(\'张三\',20);\n  // p1.printInfo();\n\n\n  Web w=new Web(\'张三\', 12,\"男\");\n  w.printInfo();\n  w.run();\n}\n```\n\n#### 类的继承 实例化自类给命名构造函数传参\n\n```dart\n/*\n面向对象的三大特性：封装 、继承、多态\n\n\nDart中的类的继承：\n    1、子类使用extends关键词来继承父类\n    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n    3、子类能复写父类的方法 getter和setter\n\n注意:最新版本的dart中需要初始化不可为null的实例字段，如果不初始化的话需要在属性前面加上late\n*/\n\nclass Person {\n  String name;\n  num age;\n  Person(this.name, this.age);\n  Person.xxx(this.name, this.age);\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n}\n\nclass Web extends Person {\n  late String sex;\n  Web(String name, num age, String sex) : super.xxx(name, age) {\n    this.sex = sex;\n  }\n  run() {\n    print(\"${this.name}---${this.age}--${this.sex}\");\n  }\n}\n\nmain() {\n  // Person p=new Person(\'李四\',20);\n  // p.printInfo();\n\n  // Person p1=new Person(\'张三\',20);\n  // p1.printInfo();\n\n  Web w = new Web(\'张三\', 12, \"男\");\n  w.printInfo();\n  w.run();\n}\n```\n\n#### 类的继承 覆写父类的方法\n\n```dart\n/*\n\n面向对象的三大特性：封装 、继承、多态\n\n\nDart中的类的继承：\n    1、子类使用extends关键词来继承父类\n    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n    3、子类能复写父类的方法 getter和setter\n\n*/\n\nclass Person {\n  String name;\n  num age;\n  Person(this.name,this.age);\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n  work(){\n    print(\"${this.name}在工作...\");\n  }\n}\n\nclass Web extends Person{\n  Web(String name, num age) : super(name, age);\n  run(){\n    print(\'run\');\n  }\n  //覆写父类的方法\n  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override\n  void printInfo(){\n     print(\"姓名：${this.name}---年龄：${this.age}\");\n  }\n  @override\n  work(){\n    print(\"${this.name}的工作是写代码\");\n  }\n}\n\nmain(){\n  Web w=new Web(\'李四\',20);\n  w.printInfo();\n  w.work();\n}\n```\n\n#### 自类里面调用父类的方法\n\n```dart\n/*\n面向对象的三大特性：封装 、继承、多态\n\n\nDart中的类的继承：\n    1、子类使用extends关键词来继承父类\n    2、子类会继承父类里面可见的属性和方法 但是不会继承构造函数\n    3、子类能复写父类的方法 getter和setter\n\n*/\n\nclass Person {\n  String name;\n  num age;\n  Person(this.name,this.age);\n  void printInfo() {\n    print(\"${this.name}---${this.age}\");\n  }\n  work(){\n    print(\"${this.name}在工作...\");\n  }\n}\n\nclass Web extends Person{\n  Web(String name, num age) : super(name, age);\n  run(){\n    print(\'run\');\n    super.work();  //子类调用父类的方法\n  }\n  //覆写父类的方法\n  @override       //可以写也可以不写  建议在覆写父类方法的时候加上 @override\n  void printInfo(){\n     print(\"姓名：${this.name}---年龄：${this.age}\");\n  }\n}\n\n\nmain(){\n  Web w=new Web(\'李四\',20);\n  // w.printInfo();\n  w.run();\n}\n```\n\n#### Dart 中的抽象类\n\nDart 中抽象类: Dart 抽象类主要用于定义标准，子类可以继承抽象类，也可以实现抽象类接口。\n\n1. 抽象类通过 abstract 关键字来定义\n2. Dart 中的抽象方法不能用 abstract 声明，Dart 中没有方法体的方法我们称为抽象方法。\n3. 如果子类继承抽象类必须得实现里面的抽象方法\n4. 如果把抽象类当做接口实现的话必须得实现抽象类里面定义的所有属性和方法。\n5. 抽象类不能被实例化，只有继承它的子类可以\n\nextends 抽象类 和 implements 的区别：\n\n1. 如果要复用抽象类里面的方法，并且要用抽象方法约束自类的话我们就用 extends 继承抽象类\n2. 如果只是把抽象类当做标准的话我们就用 implements 实现抽象类\n\n```dart\n/*\n\n案例：定义一个Animal 类要求它的子类必须包含eat方法\n\n*/\n\nabstract class Animal{\n  eat();   //抽象方法\n  run();  //抽象方法\n  printInfo(){\n    print(\'我是一个抽象类里面的普通方法\');\n  }\n}\n\nclass Dog extends Animal{\n  @override\n  eat() {\n     print(\'小狗在吃骨头\');\n  }\n\n  @override\n  run() {\n    // TODO: implement run\n    print(\'小狗在跑\');\n  }\n}\nclass Cat extends Animal{\n  @override\n  eat() {\n    // TODO: implement eat\n    print(\'小猫在吃老鼠\');\n  }\n\n  @override\n  run() {\n    // TODO: implement run\n    print(\'小猫在跑\');\n  }\n\n}\n\nmain(){\n\n  Dog d=new Dog();\n  d.eat();\n  d.printInfo();\n\n  Cat c=new Cat();\n  c.eat();\n  c.printInfo();\n\n\n  // Animal a=new Animal();   //抽象类没法直接被实例化\n\n}\n```\n\n#### Dart 中多态\n\n```dart\n/*\nDatr中的多态：\n    允许将子类类型的指针赋值给父类类型的指针, 同一个函数调用会有不同的执行效果 。\n\n    子类的实例赋值给父类的引用。\n\n    多态就是父类定义一个方法不去实现，让继承他的子类去实现，每个子类有不同的表现。\n\n*/\n\n\nabstract class Animal{\n  eat();   //抽象方法\n}\n\nclass Dog extends Animal{\n  @override\n  eat() {\n     print(\'小狗在吃骨头\');\n  }\n  run(){\n    print(\'run\');\n  }\n}\nclass Cat extends Animal{\n  @override\n  eat() {\n    print(\'小猫在吃老鼠\');\n  }\n  run(){\n    print(\'run\');\n  }\n}\n\nmain(){\n\n  // Dog d=new Dog();\n  // d.eat();\n  // d.run();\n\n\n  // Cat c=new Cat();\n  // c.eat();\n\n\n\n\n  Animal d=new Dog();\n  d.eat();\n\n\n\n  Animal c=new Cat();\n  c.eat();\n\n}\n```\n\n#### 接口\n\n和 Java 一样，dart 也有接口，但是和 Java 还是有区别的。\n\n- 首先，dart 的接口没有 interface 关键字定义接口，而是普通类或抽象类都可以作为接口被实现。\n- 同样使用 implements 关键字进行实现。\n- 但是 dart 的接口有点奇怪，如果实现的类是普通类，会将普通类和抽象中的属性的方法全部需要覆写一遍。\n- 而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像 Java 接口那样的方式，一般会使用抽象类。\n- 建议使用抽象类定义接口。\n\n```dart\n/*\n定义一个DB库 支持 mysql  mssql  mongodb\n\nmysql  mssql  mongodb三个类里面都有同样的方法\n\n*/\n\n\nabstract class Db{   //当做接口   接口：就是约定 、规范\n    late String uri;      //数据库的链接地址\n    add(String data);\n    save();\n    delete();\n}\n\nclass Mysql implements Db{\n\n  @override\n  String uri;\n\n  Mysql(this.uri);\n\n  @override\n  add(data) {\n    // TODO: implement add\n    print(\'这是mysql的add方法\'+data);\n  }\n\n  @override\n  delete() {\n    // TODO: implement delete\n    return null;\n  }\n\n  @override\n  save() {\n    // TODO: implement save\n    return null;\n  }\n  remove(){\n\n  }\n\n\n}\n\nclass MsSql implements Db{\n  @override\n  late String uri;\n  @override\n  add(String data) {\n    print(\'这是mssql的add方法\'+data);\n  }\n\n  @override\n  delete() {\n    // TODO: implement delete\n    return null;\n  }\n\n  @override\n  save() {\n    // TODO: implement save\n    return null;\n  }\n\n\n}\n\nmain() {\n\n  Mysql mysql=new Mysql(\'xxxxxx\');\n\n  mysql.add(\'1243214\');\n}\n```\n\n#### 接口文件分离\n\n```dart\n// import \'lib/Mysql.dart\';\nimport \'lib/MsSql.dart\';\n\nmain() {\n\n  // Mysql mysql=new Mysql(\'xxxxxx\');\n\n  // mysql.add(\'1243214\');\n\n  MsSql mssql=new MsSql();\n  mssql.uri=\'127.0.0.1\';\n  mssql.add(\'增加的数据\');\n}\n```\n\n#### Dart 中`implements`实现多个接口\n\n```dart\n/*\nDart中一个类实现多个接口：\n*/\n\nabstract class A{\n  late String name;\n  printA();\n}\n\nabstract class B{\n  printB();\n}\n\nclass C implements A,B{\n  @override\n  late String name;\n  @override\n  printA() {\n    print(\'printA\');\n  }\n  @override\n  printB() {\n    // TODO: implement printB\n    return null;\n  }\n\n\n}\n\n\nvoid main(){\n  C c=new C();\n  c.printA();\n}\n```\n\n#### Dart 中的 mixins\n\n```dart\n/*\nmixins的中文意思是混入，就是在类中混入其他功能。\n\n在Dart中可以使用mixins实现类似多继承的功能\n\n\n因为mixins使用的条件，随着Dart版本一直在变，这里讲的是Dart2.x中使用mixins的条件：\n\n  1、作为mixins的类只能继承自Object，不能继承其他类\n  2、作为mixins的类不能有构造函数\n  3、一个类可以mixins多个mixins类\n  4、mixins绝不是继承，也不是接口，而是一种全新的特性\n*/\n\nclass A {\n  String info=\"this is A\";\n  void printA(){\n    print(\"A\");\n  }\n}\n\nclass B {\n  void printB(){\n    print(\"B\");\n  }\n}\n\nclass C with A,B{\n\n}\n\nvoid main(){\n\n  var c=new C();\n  c.printA();\n  c.printB();\n  print(c.info);\n}\n```\n\n```dart\nclass Person{\n  String name;\n  num age;\n  Person(this.name,this.age);\n  printInfo(){\n    print(\'${this.name}----${this.age}\');\n  }\n  void run(){\n    print(\"Person Run\");\n  }\n}\n\nclass A {\n  String info=\"this is A\";\n  void printA(){\n    print(\"A\");\n  }\n  void run(){\n    print(\"A Run\");\n  }\n}\n\nclass B {\n  void printB(){\n    print(\"B\");\n  }\n  void run(){\n    print(\"B Run\");\n  }\n}\n\nclass C extends Person with B,A{\n  C(String name, num age) : super(name, age);\n}\n\nvoid main(){\n  var c=new C(\'张三\',20);\n  c.printInfo();\n  // c.printB();\n  // print(c.info);\n  c.run();\n}\n```\n\n#### Dart 中的 `mixins` 的类型\n\n```dart\n/*\nmixins的实例类型是什么？\n很简单，mixins的类型就是其超类的子类型。\n*/\n\n\nclass A {\n  String info=\"this is A\";\n  void printA(){\n    print(\"A\");\n  }\n}\n\nclass B {\n  void printB(){\n    print(\"B\");\n  }\n}\n\nclass C with A,B{\n\n}\n\nvoid main(){\n   var c=new C();\n\n  print(c is C);    //true\n  print(c is A);    //true\n  print(c is B);   //true\n\n\n  // var a=new A();\n  // print(a is Object);\n}\n```\n\n### 泛型\n\n#### 泛型方法\n\n```dart\n/*\n\n通俗理解：泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持(类型校验)\n*/\n\n\n//只能返回string类型的数据\n\n  // String getData(String value){\n  //     return value;\n  // }\n\n\n//同时支持返回 string类型 和int类型  （代码冗余）\n\n\n  // String getData1(String value){\n  //     return value;\n  // }\n\n  // int getData2(int value){\n  //     return value;\n  // }\n\n\n\n//同时返回 string类型 和number类型       不指定类型可以解决这个问题\n\n\n  // getData(value){\n  //     return value;\n  // }\n\n\n//不指定类型放弃了类型检查。我们现在想实现的是传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型\n\n  // T getData<T>(T value){\n  //     return value;\n  // }\n\n  getData<T>(T value){\n      return value;\n  }\n\nvoid main(){\n\n    // print(getData(21));\n\n    // print(getData(\'xxx\'));\n\n    // getData<String>(\'你好\');\n\n    print(getData<int>(12));\n\n}\n```\n\n#### 泛型类\n\n```dart\n//集合List 泛型类的用法\n\n//案例：把下面类转换成泛型类，要求MyList里面可以增加int类型的数据，也可以增加String类型的数据。但是每次调用增加的类型要统一\n\n/*\nclass MyList {\n  List list = <int>[];\n  void add(int value) {\n    this.list.add(value);\n  }\n  List getList() {\n    return list;\n  }\n}\n\nMyList l = new MyList();\nl.add(1);\nl.add(12);\nl.add(5);\nprint(l.getList());\n\n*/\n\nclass MyList<T> {\n  List list = <T>[];\n  void add(T value) {\n    this.list.add(value);\n  }\n\n  List getList() {\n    return list;\n  }\n}\n\nmain() {\n  // MyList l1=new MyList();\n  // l1.add(\"张三\");\n  // l1.add(12);\n  // l1.add(true);\n  // print(l1.getList());\n\n  // MyList l2 = new MyList<String>();\n  // l2.add(\"张三1\");\n  // // l2.add(11);  //错误的写法\n  // print(l2.getList());\n\n  // MyList l3 = new MyList<int>();\n  // l3.add(11);\n  // l3.add(12);\n  // l3.add(\"aaaa\");\n  // print(l3.getList());\n\n  // List list = List.filled(2, \"\");\n  // list[0] = \"张三\";\n  // list[1] = \"李四\";\n  // print(list);\n\n  // List list = new List.filled(2, \"\");\n  // list[0] = \"张三1\";\n  // list[1] = \"李四\";\n  // print(list);\n\n  // List list = new List<String>.filled(2, \"\");\n  // list[0] = \"张三1\";\n  // list[1] = \"李四\";\n  // print(list);\n\n  List list2 = new List<int>.filled(2, 0);\n  list2[0] = 12;\n  list2[1] = 13;\n  print(list2);\n}\n```\n\n#### 泛型接口\n\n```dart\n/*\nDart中的泛型接口:\n\n    实现数据缓存的功能：有文件缓存、和内存缓存。内存缓存和文件缓存按照接口约束实现。\n\n    1、定义一个泛型接口 约束实现它的子类必须有getByKey(key) 和 setByKey(key,value)\n\n    2、要求setByKey的时候的value的类型和实例化子类的时候指定的类型一致\n\n\n*/\n\n// abstract class ObjectCache {\n//   getByKey(String key);\n//   void setByKey(String key, Object value);\n// }\n\n// abstract class StringCache {\n//   getByKey(String key);\n//   void setByKey(String key, String value);\n// }\n\n// abstract class Cache<T> {\n//   getByKey(String key);\n//   void setByKey(String key, T value);\n// }\n\nabstract class Cache<T> {\n  getByKey(String key);\n  void setByKey(String key, T value);\n}\n\nclass FileCache<T> implements Cache<T> {\n  @override\n  getByKey(String key) {\n    return null;\n  }\n  @override\n  void setByKey(String key, T value) {\n    print(\"我是文件缓存 把key=${key}  value=${value}的数据写入到了文件中\");\n  }\n}\n\nclass MemoryCache<T> implements Cache<T> {\n  @override\n  getByKey(String key) {\n    return null;\n  }\n  @override\n  void setByKey(String key, T value) {\n    print(\"我是内存缓存 把key=${key}  value=${value} -写入到了内存中\");\n  }\n}\n\nvoid main() {\n  // MemoryCache m=new MemoryCache<String>();\n  //  m.setByKey(\'index\', \'首页数据\');\n\n  MemoryCache m = new MemoryCache<Map>();\n  m.setByKey(\'index\', {\"name\": \"张三\", \"age\": 20});\n}\n```\n\n### Dart 中的库\n\n- 前面介绍 Dart 基础知识的时候基本上都是在一个文件里面编写 Dart 代码的，但实际开发中不可能这么写，模块化很重要，所以这就需要使用到库的概念。\n- 在 Dart 中，库的使用时通过 import 关键字引入的。\n- library 指令可以创建一个库，每个 Dart 文件都是一个库，即使没有使用 library 指令来指定。\n\nDart 中的库主要有三种：\n\n1. 我们自定义的库\n   `import \'lib/xxx.dart\';`\n2. 系统内置库\n\n```dart\n  import \'dart:math\';\n  import \'dart:io\';\n  import \'dart:convert\';\n```\n\n3. Pub 包管理系统中的库\n\n```dart\n  https://pub.dev/packages\n        https://pub.flutter-io.cn/packages\n        https://pub.dartlang.org/flutter/\n    1. 需要在自己想项目根目录新建一个pubspec.yaml\n    2. 在pubspec.yaml文件 然后配置名称 、描述、依赖等信息\n    3. 然后运行 pub get 获取包下载到本地\n    4. 项目中引入库 import \'package:http/http.dart\' as http; 看文档使用\n```\n\n#### Dart 中导入自己本地库\n\n```dart\nimport \'lib/Animal.dart\';\nmain(){\n  var a=new Animal(\'小黑狗\', 20);\n  print(a.getName());\n}\n```\n\n#### 导入系统内置库 math 库\n\n```dart\n// import \'dart:io\';\nimport \"dart:math\";\nmain(){\n\n    print(min(12,23));\n\n    print(max(12,25));\n\n}\n```\n\n#### 导入系统内置库实现请求数据 httpClient\n\n```dart\nimport \'dart:io\';\nimport \'dart:convert\';\n\n\nvoid main() async{\n  var result = await getDataFromZhihuAPI();\n  print(result);\n}\n\n\n//api接口： http://news-at.zhihu.com/api/3/stories/latest\ngetDataFromZhihuAPI() async{\n  //1、创建HttpClient对象\n  var httpClient = new HttpClient();\n  //2、创建Uri对象\n  var uri = new Uri.http(\'news-at.zhihu.com\',\'/api/3/stories/latest\');\n  //3、发起请求，等待请求\n  var request = await httpClient.getUrl(uri);\n  //4、关闭请求，等待响应\n  var response = await request.close();\n  //5、解码响应的内容\n  return await response.transform(utf8.decoder).join();\n}\n```\n\n#### 关于 Async Await\n\n```dart\n/*\nasync和await\n  这两个关键字的使用只需要记住两点：\n    只有async方法才能使用await关键字调用方法\n    如果调用别的async方法必须使用await关键字\n\n\nasync是让方法变成异步。\nawait是等待异步方法执行完成。\n\n\n*/\n\nvoid main() async{\n  var result = await testAsync();\n  print(result);\n\n}\n\n//异步方法\ntestAsync() async{\n  return \'Hello async\';\n}\n```\n\n#### Dart 导入 Pub 包管理系统中的库\n\n```dart\n/*\npub包管理系统:\n\n\n1、从下面网址找到要用的库\n        https://pub.dev/packages\n        https://pub.flutter-io.cn/packages\n        https://pub.dartlang.org/flutter/\n\n2、创建一个pubspec.yaml文件，内容如下\n\n    name: xxx\n    description: A new flutter module project.\n    dependencies:\n        http: ^0.12.0+2\n        date_format: ^1.0.6\n\n3、配置dependencies\n\n4、运行pub get 获取远程库\n\n5、看文档引入库使用\n*/\nimport \'dart:convert\' as convert;\nimport \'package:http/http.dart\' as http;\nimport \'package:date_format/date_format.dart\';\n\nmain() async {\n  var url =\n      \"http://www.phonegap100.com/appapi.php?a=getPortalList&catid=20&page=1\";\n\n  // Await the http get response, then decode the json-formatted responce.\n  var response = await http.get(url);\n  if (response.statusCode == 200) {\n    var jsonResponse = convert.jsonDecode(response.body);\n\n    print(jsonResponse);\n  } else {\n    print(\"Request failed with status: ${response.statusCode}.\");\n  }\n\n  print(formatDate(DateTime(1989, 2, 21), [yyyy, \'*\', mm, \'*\', dd]));\n}\n```\n\n#### Dart 库的重命名 Dart 冲突解决\n\n```dart\n/*\n1、冲突解决\n当引入两个库中有相同名称标识符的时候，如果是java通常我们通过写上完整的包名路径来指定使用的具体标识符，甚至不用import都可以，但是Dart里面是必须import的。\n当冲突的时候，可以使用as关键字来指定库的前缀。如下例子所示：\n\n    import \'package:lib1/lib1.dart\';\n    import \'package:lib2/lib2.dart\' as lib2;\n\n\n    Element element1 = new Element();           // Uses Element from lib1.\n    lib2.Element element2 = new lib2.Element(); // Uses Element from lib2.\n\n*/\n\nimport \'lib/Person1.dart\';\nimport \'lib/Person2.dart\' as lib;\n\nmain(List<String> args) {\n  Person p1=new Person(\'张三\', 20);\n  p1.printInfo();\n\n\n  lib.Person p2=new lib.Person(\'李四\', 20);\n  p2.printInfo();\n\n}\n```\n\n#### 部分导入\n\n```dart\n/*\n部分导入\n  如果只需要导入库的一部分，有两种模式：\n\n     模式一：只导入需要的部分，使用show关键字，如下例子所示：\n\n      import \'package:lib1/lib1.dart\' show foo;\n\n     模式二：隐藏不需要的部分，使用hide关键字，如下例子所示：\n\n      import \'package:lib2/lib2.dart\' hide foo;\n\n*/\n\n// import \'lib/myMath.dart\' show getAge;\n\n import \'lib/myMath.dart\' hide getName;\n\nvoid main(){\n//  getName();\n  getAge();\n}\n```\n\n#### 延迟加载\n\n```dart\n/*\n延迟加载\n\n    也称为懒加载，可以在需要的时候再进行加载。\n    懒加载的最大好处是可以减少APP的启动时间。\n\n    懒加载使用deferred as关键字来指定，如下例子所示：\n\n    import \'package:deferred/hello.dart\' deferred as hello;\n\n    当需要使用的时候，需要使用loadLibrary()方法来加载：\n\n    greet() async {\n      await hello.loadLibrary();\n      hello.printGreeting();\n    }\n*/\n```\n\n### Dart 新特性\n\n#### Null safety 以及可空类型 非空断言\n\n```dart\n/*\n  Null safety翻译成中文的意思是空安全。\n\n  null safety 可以帮助开发者避免一些日常开发中很难被发现的错误，并且额外的好处是可以改善性能。\n\n  Flutter2.2.0（2021年5月19日发布） 之后的版本都要求使用null safety。\n\n  ? 可空类型\n\n  ! 类型断言\n\n*/\n\nString? getData(apiUrl){\n  if(apiUrl!=null){\n    return \"this is server data\";\n  }\n  return null;\n}\n\n// void printLength(String? str){\n//   // print(str!.length);\n//   if (str!=null){\n//     print(str.length);\n//   }\n// }\n\nvoid printLength(String? str){\n  try {\n    print(str!.length);\n  } catch (e) {\n     print(\"str is null\");\n  }\n}\n\nvoid main(args) {\n\n//1、 ? 可空类型\n\n\n  // int a=123;\n  // print(a);\n\n  // String username=\"张三\";\n  // print(username);\n\n  // List<String> l1=[\"张三\",\"李四\",\"王五\"];\n  // print(l1);\n\n\n  // int a=123;  //非空的int类型\n  // a=null;  //A value of type \'Null\' can\'t be assigned to a variable of type \'int\'\n\n\n  // String username=\"张三\";  //非空的String类型\n  // username=null;   //A value of type \'Null\' can\'t be assigned to a variable of type \'String\'.\n\n\n  // String? username=\"张三\";   // String?  表示username是一个可空类型\n  // username=null;\n  // print(username);\n\n\n  // int? a=123;  //  int? 表示a是一个可空类型\n  // a=null;\n  // print(a);\n\n\n  // List<String> l1=[\"张三\",\"李四\",\"王五\"];\n  // l1=null;  //A value of type \'Null\' can\'t be assigned to a variable of type \'List<String>\'.\n\n\n  // List<String>? l1=[\"张三\",\"李四\",\"王五\"];\n  // l1=null;\n  // print(l1);\n\n\n  //调用方法\n  // print(getData(\"http://www.itying.com\"));\n\n  // print(getData(null));\n\n\n// ! 类型断言\n\n  // String? str=\"this is str\";\n\n  // str=null;\n\n  // print(str!.length);\n\n   //类型断言: 如果str不等于null 会打印str的长度，如果等于null会抛出异常\n\n  //  printLength(\"str\");\n\n   printLength(null);\n}\n```\n\n#### late 关键词\n\n```dart\n/*\nNull safety翻译成中文的意思是空安全。\n\nlate 关键字主要用于延迟初始化。\n\n*/\nclass Person {\n  late String name;\n  late int age;\n  void setName(String name, int age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  String getName() {\n    return \"${this.name}---${this.age}\";\n  }\n}\n\nvoid main(args) {\n  Person p = new Person();\n  p.setName(\"张三\", 20);\n  print(p.getName());\n}\n```\n\n#### late 接口\n\n```dart\n/*\n和Java一样，dart也有接口，但是和Java还是有区别的。\n\n  首先，dart的接口没有interface关键字定义接口，而是普通类或抽象类都可以作为接口被实现。\n\n  同样使用implements关键字进行实现。\n\n  但是dart的接口有点奇怪，如果实现的类是普通类，会将普通类和抽象中的属性的方法全部需要覆写一遍。\n\n  而因为抽象类可以定义抽象方法，普通类不可以，所以一般如果要实现像Java接口那样的方式，一般会使用抽象类。\n\n  建议使用抽象类定义接口。\n\n*/\n\n/*\n定义一个DB库 支持 mysql  mssql  mongodb\n\nmysql  mssql  mongodb三个类里面都有同样的方法\n\n*/\n\n\nabstract class Db{   //当做接口   接口：就是约定 、规范\n    late String uri; //数据库的链接地址\n    add(String data);\n    save();\n    delete();\n}\n\nclass Mysql implements Db{\n\n  @override\n  String uri;\n  Mysql(this.uri);\n\n  @override\n  add(data) {\n    // TODO: implement add\n    print(\'这是mysql的add方法\'+data);\n  }\n\n  @override\n  delete() {\n    // TODO: implement delete\n    return null;\n  }\n\n  @override\n  save() {\n    // TODO: implement save\n    return null;\n  }\n\n  remove(){\n\n  }\n}\n\nclass MsSql implements Db{\n  @override\n  late String uri;\n\n  @override\n  add(String data) {\n    print(\'这是mssql的add方法\'+data);\n  }\n\n  @override\n  delete() {\n    // TODO: implement delete\n    return null;\n  }\n\n  @override\n  save() {\n    // TODO: implement save\n    return null;\n  }\n}\n\nmain() {\n\n  Mysql mysql=new Mysql(\'xxxxxx\');\n  mysql.add(\'1243214\');\n}\n```\n\n#### required\n\n```dart\n/*\nNull safety翻译成中文的意思是空安全。\n\nrequired翻译成中文的意思是需要、依赖\n\nrequired关键词:\n\n    最开始 @required 是注解\n\n    现在它已经作为内置修饰符。\n\n    主要用于允许根据需要标记任何命名参数（函数或类），使得它们不为空。因为可选参数中必须有个 required 参数或者该参数有个默认值。\n\n*/\nString printUserInfo(String username, {int age=10, String sex=\"男\"}) {//行参\n  return \"姓名:$username---性别:$sex--年龄:$age\";\n}\n\nString printInfo(String username, {required int age, required String sex}) {//行参\n  return \"姓名:$username---性别:$sex--年龄:$age\";\n}\n\n\nvoid main(args) {\n    print(printUserInfo(\'张三\'));\n\n    print(printUserInfo(\'张三\',age: 20,sex: \"女\"));\n\n    //age 和 sex必须传入\n    print(printInfo(\'张三\',age: 22,sex: \"女\"));\n}\n```\n\n```dart\n//表示 name 和age 是必须传入的命名参数\nclass Person {\n  String name;\n  int age;\n  Person({required this.name,required this.age});  //表示 name 和age 必须传入\n\n  String getName() {\n    return \"${this.name}---${this.age}\";\n  }\n}\n\nvoid main(args) {\n   Person p=new Person(\n     name: \"张三\",\n     age: 20\n   );\n   print(p.getName());\n}\n```\n\n```dart\n// name 可以传入也可以不传入   age必须传入\nclass Person {\n  String? name;   //可空属性\n  int age;\n  Person({this.name,required this.age});  //表示 name 和age 必须传入\n\n  String getName() {\n    return \"${this.name}---${this.age}\";\n  }\n}\n\nvoid main(args) {\n   Person p=new Person(\n     name: \"张三\",\n     age: 20\n   );\n   print(p.getName());  //张三---20\n\n\n  Person p1=new Person(\n     age: 20\n   );\n   print(p1.getName());  //null---20\n}\n```\n\n### Dart 性能优化之常量、 identical 函数、常量构造函数详解\n\n#### 回顾 Dart 常量\n\n```dart\n/*\nDart 常量: final 和 const修饰符\n\n\n  const 声明的常量是在编译时确定的，永远不会改变\n\n  final 声明的常量允许声明后再赋值，赋值后不可改变，final 声明的变量是在运行时确定的;\n\n  final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化\n\n\n*/\n\nvoid main(){\n\n\n//const常量\n\n//const PI=3.14;\n// PI=3.14159;  //const定义的常量没法改变\n//print(PI);\n\n\n// final 常量\n\n// final PI=3.14;\n// print(PI);\n\n//final和const区别：final 可以开始不赋值 只能赋一次 ; 而final不仅有const的编译时常量的特性，最重要的它是运行时常量，并且final是惰性初始化，即在运行时第一次使用前才初始化\n\n\n final a;\n a=13;\n//  a=14;\n print(a);\n\n\nfinal d=new DateTime.now();\n\n}\n```\n\n#### Dart 中的 const identical 函数\n\n```dart\n/*\ndart:core 库中identical 函数的用法介绍如下。\n\n用法:\nbool identical(\n   Object? a,\n   Object? b\n)\n检查两个引用是否指向同一个对象。\n\nvar o = new Object();\n\n  var isIdentical = identical(o, new Object()); // false, different objects.\n  print(isIdentical);\n\n  isIdentical = identical(o, o); // true, same object\n  print(isIdentical);\n\n  isIdentical = identical(const Object(), const Object()); // true, const canonicalizes\n  print(isIdentical);\n\n  isIdentical = identical([1], [1]); // false\n  print(isIdentical);\n\n  isIdentical = identical(const [1], const [1]); // true\n  print(isIdentical);\n\n  isIdentical = identical(const [1], const [2]); // false\n  print(isIdentical);\n\n  isIdentical = identical(2, 1 + 1); // true, integers canonicalizes\n  print(isIdentical);\n*/\n\n\nvoid main(){\n\n  // var o1 = new Object();\n  // var o2 = new Object();\n\n  // print(identical(o1,o2));  //false  不共享存储空间\n\n  // print(identical(o1,o1));   //true 共享存储空间\n\n\n\n  // var o1 = Object();\n  // var o2 = Object();\n  // print(identical(o1,o2));  //false\n  // print(identical(o1,o1));  //true\n\n\n\n  //表示实例化常量构造函数\n  //o1 和 o2共享了存储空间\n  // var o1 = const Object();\n  // var o2 = const Object();\n  // print(identical(o1,o2));  //true 共享存储空间\n  // print(identical(o1,o1));  //true 共享存储空间\n\n\n  // print(identical([2],[2])); //false\n\n  // var a=[2];\n  // var b=[2];\n  // print(identical(a,b)); //false 不共享存储空间\n\n\n\n  // print(identical(const [2],const [2])); //true\n\n  const a=[2];\n  const b=[2];\n  print(identical(a,b)); //true 共享存储空间\n\n\n\n  const c=[2];\n  const d=[3];\n  print(identical(c,d)); //false  不共享存储空间\n\n\n}\n// 发现：const关键词在多个地方创建相同的对象的时候，内存中只保留了一个对象\n\n// 共享存储空间条件：1、常量   2、值相等\n```\n\n#### Dart 普通构造函数\n\n```dart\nclass Container{\n  int width;\n  int height;\n  Container({required this.width,required this.height});\n}\n\nvoid main(){\n  var c1=new Container(width: 100,height: 100);\n  var c2=new Container(width: 100,height: 100);\n  print( identical(c1, c2));  //false   c1和c2在内存中存储了2份\n}\n```\n\n#### Dart 常量构造函数\n\n```dart\n\n/*\n常量构造函数总结如下几点：\n\n  1、常量构造函数需以const关键字修饰\n  2、const构造函数必须用于成员变量都是final的类\n  3、如果实例化时不加const修饰符，即使调用的是常量构造函数，实例化的对象也不是常量实例\n  4、实例化常量构造函数的时候，多个地方创建这个对象，如果传入的值相同，只会保留一个对象。\n  5、Flutter中const 修饰不仅仅是节省组件构建时的内存开销，Flutter 在需要重新构建组件的时候，由于这个组件是不应该改变的，重新构建没有任何意义，因此 Flutter 不会重建构建 const 组件\n*/\n\n//常量构造函数\nclass Container{\n  final int width;\n  final int height;\n  const Container({required this.width,required this.height});\n}\n\nvoid main(){\n\n  var c1=Container(width: 100,height: 100);\n  var c2=Container(width: 100,height: 100);\n  print(identical(c1, c2)); //false\n\n\n  var c3=const Container(width: 100,height: 100);\n  var c4=const Container(width: 100,height: 100);\n  print(identical(c3, c4)); //true\n\n\n  var c5=const Container(width: 100,height: 110);\n  var c6=const Container(width: 120,height: 100);\n  print(identical(c5, c6)); //false\n\n}\n// 实例化常量构造函数的时候，多个地方创建这个对象，如果传入的值相同，只会保留一个对象。\n```\n\n\n', NULL, 1, NULL, NULL, '2024-03-18 18:07:01', '2024-03-18 18:10:51', 10, 10);
INSERT INTO `articles` VALUES (5, 'Electron开发文档', 21, '[58, 60]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/3075b737-b98e-4b78-83d6-c202b0ed7b02.png', 'Electron开发文档', '# Electron开发文档\n\n> Electron是一个使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序\n\n## 配置环境\n\n- 通过 `npx create-react-app react-electron-doc` 命令来初始化 `React` 项目\n\n- 初始化完在根目录下打开 `Terminal` 开始安装 `Electron`， 执行命令为： `npm i electron -D`\n\n- `electron` 安装完成接着安装 `electron-is-dev` 开发者工具来配置是否是开发环境\n\n- 根目录下创建一个 `main.js` 文件，配置 `electron` 环境，代码为如下：\n\n  ```js\n  const { app, BrowserWindow } = require(\'electron\')\n  const isDev = require(\'electron-is-dev\')\n  \n  app.on(\'ready\', () => {\n    const mainWindow = new BrowserWindow({\n      width: 1000,\n      height: 600,\n      webPreferences: {\n        nodeIntegration: true\n      }\n    })\n  \n    // 开启调试模式\n    mainWindow.webContents.openDevTools()\n  \n    const urlLocation = isDev ? \'http://localhost:3000\' : \'http://localhost:8080\'\n    mainWindow.loadURL(urlLocation)\n  })\n  ```\n\n- 根目录 `packages.json` 文件中配执行命令来启动项目：\n\n  ```json\n  {\n    \"dependencies\": {\n      \"bootstrap\": \"^5.2.0\",\n      \"react\": \"^18.2.0\",\n      \"react-dom\": \"^18.2.0\",\n      \"react-scripts\": \"5.0.1\",\n      \"web-vitals\": \"^2.1.4\"\n    },\n    \"main\": \"main.js\",\n    \"scripts\": {\n      \"start\": \"react-scripts start\",\n      \"ele\": \"electron .\",\n      \"dev\": \"concurrently \\\"wait-on http://localhost:3000 && electron .\\\" \\\"cross-env BROWSER=none npm start\\\"\"\n    },\n    \"devDependencies\": {\n      \"concurrently\": \"^7.3.0\",\n      \"electron\": \"^20.0.0\",\n      \"electron-is-dev\": \"^2.0.0\",\n      \"wait-on\": \"^6.0.1\"\n    }\n  }\n  ```\n\n这里需要安装几个依赖包来配置同时执行多个命令\n\n1. concurrently\n2. wait-on\n3. cross-env\n\n安装完成后配置 `*\"dev\"*: \"concurrently \\\"wait-on http://localhost:3000 && electron .\\\" \\\"cross-env BROWSER=none npm start\\\"\"` 即可，能实现多个命令执行操作\n\n这里配置 `BROWSER=none` 来解决`react`项目启动默认在浏览器中打开\n\n最后执行`yarn dev or npm run dev`命令启动项目即可 \n\n## 依赖安装\n\n- 安装 bootstrap  `npm i bootstrap -S` [官方文档](https://getbootstrap.com/)\n- 使用 `classnames` 第三方包来处理多个样式问题\n\n## Flatten State\n\n> flatten state目的是就是把数据扁平化，更加方便我们对数据的操作，flatten就是类似于使用HashMap的形式，在JavaScript中我们可以使用Object。\n\n- [如何更高效、方便的在React.js中操作State](https://juejin.cn/post/6844904036945100807)\n- [利用Flatten State更优雅的修改 React 的 State 结构数据(数组对象元素)](https://www.jianshu.com/p/b79527d692b1)\n\n**示例代码**\n```js\n// 未使用 Flatten State方案得需要遍历\n// const newFile = files.map(file => {\n//   if (file.id === id) {\n//     file.body = value\n//   }\n\n//   return file\n// })\n\n// 使用 Flatten State 通过索引直接获取数据并更新\nconst newFile = { ...files[id], body: value }\nsetFiles({ ...files, [id]: newFile })\n```\n\n\n## 通用唯一标识码UUID的介绍及使用\n\n- [uuid npm 链接](https://www.npmjs.com/package/uuid)\n- [前端生成唯一id UUID](https://blog.csdn.net/weixin_44242623/article/details/120362325)\n\n##  `require` 导入问题\n\ncreate-react-app 底层是通过webpack来生成的，webpack本身就是支持两种导入模式，一种ES6，另一种require 在脚手架中通过 require(\'fs\') 导入打印出来的是空的对象，原因就是 通过 require来导入首先通过 node_modules报里面找，如果找不到就返回空，解决方案是 window.require(\'fs\')，指定顶级对象来解决\n\n## FS 模块使用 Promise\n\n- [官方例子](https://nodejs.org/docs/latest-v17.x/api/fs.html#promises-api)\n\n```js\nimport { unlink } from \'fs/promises\';\n\ntry {\n  await unlink(\'/tmp/hello\');\n  console.log(\'successfully deleted /tmp/hello\');\n} catch (error) {\n  console.error(\'there was an error:\', error.message);\n}\n```\n\n## Electron store', NULL, 1, NULL, NULL, '2024-03-18 18:10:13', '2024-03-18 18:10:59', 10, 10);
INSERT INTO `articles` VALUES (6, 'rust 正在全面入侵前端', 11, '[58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/c42c8ce7-f2a7-429a-86e0-89ec2de62edb.png', 'Farm 是一个基于 Rust 实现的极速构建引擎，帮助您更快地构建 Web 程序 和 JavaScript 库。', '- [rust 正在全面入侵前端](https://mp.weixin.qq.com/s/i5uENCExm0vqh6oAWiGu4A)', NULL, 1, NULL, NULL, '2024-03-19 10:22:14', '2024-03-19 10:22:14', 10, 10);
INSERT INTO `articles` VALUES (7, '实战专栏', 12, '[58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/b0943edf-3e84-483a-abd1-e737d3d54bd3.jpg', '犬小哈的实战专栏', '- [犬小哈的实战专栏](https://www.quanxiaoha.com/column/)\n- [知识星球](https://wx.zsxq.com/dweb2/index/group/15528151814812)\n- [flowbite](https://flowbite.com/)\n- [Animate.css 官](https://animate.style/ )', NULL, 1, NULL, NULL, '2024-03-19 13:39:28', '2024-04-23 13:22:28', 10, 10);
INSERT INTO `articles` VALUES (8, 'IntelliJ - IntelliJ IDEA 2022.2 永久破解激活教程图解', 23, '[58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/bd5798fa-44c1-4038-b8bc-f4abca8a983a.jpg', 'IntelliJ - IntelliJ IDEA 2022.2 永久破解激活教程图解', '- [IntelliJ - IntelliJ IDEA 2022.2 永久破解激活教程图解](https://www.yoodb.com/deployment/intellij-idea/idea-202202.html)', NULL, 1, NULL, NULL, '2024-03-20 14:59:55', '2024-03-20 14:59:55', 16, 16);
INSERT INTO `articles` VALUES (9, 'Vue3.3 + Vite+ Element-Plus + TypeScript 从0到1搭建企业级后台管理系统（前后端开源）', 11, '[46, 55, 58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/603af46e-8f38-4975-be87-ed435fc0e1d7.png', 'Vue3.3 + Vite+ Element-Plus + TypeScript 从0到1搭建企业级后台管理系统（前后端开源）', '- [Vue3.3 + Vite+ Element-Plus + TypeScript 从0到1搭建企业级后台管理系统（前后端开源）](https://juejin.cn/post/7228990409909108793)\n- [Vite下一代的前端工具链](https://cn.vitejs.dev/)\n- [vue-element-admin(Vue3)](https://vue3.youlai.tech/#/api/apifox)\n- [vue-element-admin(Vue2)](https://panjiachen.gitee.io/vue-element-admin/#/dashboard)\n- [pinia-plugin-persistedstate 适用于 Pinia 的持久化存储插件](https://prazdevs.github.io/pinia-plugin-persistedstate/zh/)', NULL, 1, NULL, NULL, '2024-03-21 18:57:08', '2024-03-21 18:57:08', 10, 10);
INSERT INTO `articles` VALUES (10, 'Docker 安装 Jenkins（图文教程）', 12, '[58]', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/ae439227-c64b-4131-b29a-0e912b85cf67.jpeg', 'Jenkins 是一个开源的持续集成（Continuous Integration）工具，它的主要作用是帮助开发团队自动化构建、测试和部署软件项目', '## 1. 什么是 Jenkins ?\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471707103654)\n\n> Jenkins 是**一个开源的持续集成（Continuous Integration）工具，它的主要作用是帮助开发团队自动化构建、测试和部署软件项目**。通俗来说，Jenkins 可以在每次代码变更时，帮助我们自动进行一系列的操作，例如编译代码、运行测试、生成文档，甚至是将应用程序部署到服务器上。\n\n## 2. 为什么要使用 Jenkins 呢？\n\n- **自动化构建和测试：** Jenkins 可以监视版本控制系统（如 Git）中的代码变更，一旦有新的提交，就触发自动构建和测试流程。这有助于发现潜在的问题，确保代码的质量。\n- **持续集成：** Jenkins 支持持续集成，即频繁地将小的代码变更合并到主干，并通过自动构建和测试来验证这些变更。这有助于减少集成问题，提高团队的协作效率。\n- **自动化部署：** Jenkins 可以自动化部署应用程序到测试环境、预生产环境甚至生产环境。通过定义部署流程，可以减少人为错误，确保部署的一致性。\n- **插件生态系统：** Jenkins 拥有丰富的插件生态系统，支持各种开发工具、构建工具和部署目标。这意味着你可以很容易地将 Jenkins 集成到你的开发工作流中。\n- **可扩展性：** Jenkins 是开源的，并且具有强大的可扩展性。你可以根据团队的需求定制自己的构建和部署流程，满足特定项目的要求。\n\n## 3. 拉取镜像\n\n打开命令行工具 `PowerShell` , 执行搜索命令，如下:\n\n```\ndocker search jenkins\n```\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471134398158)\n\n注意，从搜索结果中，你会看到官方提供的 `jenkins` 镜像描述，提示我们该镜像已经过期，不再维护了。浏览器访问 [DockerHub](https://hub.docker.com/r/jenkins/jenkins) , 搜索关键字 *jenkins* , 找到目前正在维护的版本，如下图所示，提示我们通过如下命令，来下载最新的 `LTS` 长期支持版本：\n\n```\ndocker pull jenkins/jenkins:lts-jdk17\n```\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471142307926)\n\n镜像下载成功后，通过 `docker images` 命令来检查一下镜像是否下载成功：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471148754819)\n\n## 4. 运行容器\n\n接着，执行如下命令来运行 `jenkins` 容器：\n\n```\ndocker run -d -u root -p 8080:8080 -p 50000:50000 -v E:\\docker\\jenkins2\\jenkins_home:/var/jenkins_home --name jenkins2 jenkins/jenkins:lts-jdk17\n```\n\n> 解释一下每个参数的含义：\n>\n> - **docker run:** 运行 Docker 容器的命令。\n>\n> - **-d:** 在后台运行容器，即“detached”模式。\n>\n> - **-u root:** 以 root 用户身份运行容器。这通常用于确保容器内的进程具有足够的权限执行需要的操作。\n>\n> - **-p 8080:8080:** 将容器内部的 8080 端口映射到宿主机的 8080 端口。Jenkins 服务通常在 8080 端口上运行。\n>\n> - **-p 50000:50000:** 将容器内部的 50000 端口映射到宿主机的 50000 端口。这是 Jenkins 使用的用于构建和执行任务的端口。\n>\n> - **-v E:\\docker\\jenkins2\\jenkins_home:/var/jenkins_home:** 将宿主机上的目录（E:\\docker\\jenkins2\\jenkins_home）挂载到容器内的 /var/jenkins_home 目录。这样可以确保 Jenkins 数据和配置持久化，即使容器被删除，数据仍然保存在宿主机上。\n>\n> - **--name jenkins2:** 为容器指定一个名称，即 \"jenkins2\"。\n>\n>   > TIP : 因为我本地之前测试的时候，已经命名了一个容器名为 jenkins , 这里演示为了防止冲突，命名的 jenkins2 。\n>\n> - **jenkins/jenkins:lts-jdk17:** 指定要运行的 Docker 镜像的名称和版本。在这里，使用的是 Jenkins 的 LTS 版本，内部使用的 JDK 17。\n\n命令执行后，执行 `docker ps` 命令来查看正在运行的容器，确认一下容器是否运行成功：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471177995761)\n\n## 5. 访问 Jenkins\n\n然后，打开浏览器访问 [http://localhost:8080](http://localhost:8080/) , 首次访问可能速度较慢，请耐心等待一会，会出现如下页面：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471193501174)\n\n需要你提供**管理员密码** ， 密码可以通过如下命令，来查看 `jenkins2` 容器的启动日志：\n\n```\ndocker logs jenkins2\n```\n\n在日志中，可以看到该密码，如下图所示，将其复制粘贴到输入框中，点击*继续*按钮：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471188631014)\n\n## 6. 安装插件\n\n接着，进入到如下页面，点击左边的*安装推荐的插件* ：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471198343894)\n\n开始安装 `jenkins` 需要的常用插件，过程比较慢，等待其全部安装完毕：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471214984133)\n\n## 7. 配置管理员用户\n\n插件安装完毕后，开始配置管理员用户：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471650265585)\n\n> **注意**： 后续再次登录 `jenkins` 后台需要，务必记住登录用户名和密码。\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471654746992)\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471450544577)\n\n点击*开始使用 Jenkins* 按钮，进入到 `Jenkins` 后台首页，如下图所示，至此，`Jenkins` 就安装好啦，是不是很简单：\n\n![img](https://img.quanxiaoha.com/quanxiaoha/170471659718399)\n\n', NULL, 1, NULL, NULL, '2024-04-08 13:00:12', '2024-04-08 13:00:12', 10, 10);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '分类名称',
  `sort` int(11) NOT NULL DEFAULT 0 COMMENT '顺序',
  `status` tinyint(2) NOT NULL DEFAULT 1 COMMENT '分类状态 0:禁用，1:启用',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '修改人',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 24 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '分类表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (11, '前端', 1, 1, '2024-03-17 23:24:00', '2024-03-17 23:24:00', 10, 10);
INSERT INTO `category` VALUES (12, '后端', 2, 1, '2024-03-17 23:24:08', '2024-03-17 23:24:08', 10, 10);
INSERT INTO `category` VALUES (13, '数据库', 3, 1, '2024-03-17 23:24:19', '2024-03-17 23:24:19', 10, 10);
INSERT INTO `category` VALUES (14, 'Nodejs', 4, 1, '2024-03-17 23:25:51', '2024-03-17 23:25:51', 10, 10);
INSERT INTO `category` VALUES (15, 'Vuejs', 5, 1, '2024-03-17 23:25:58', '2024-03-21 00:25:47', 10, 10);
INSERT INTO `category` VALUES (16, 'Flutter', 6, 1, '2024-03-17 23:26:35', '2024-03-17 23:26:35', 10, 10);
INSERT INTO `category` VALUES (17, 'React', 7, 1, '2024-03-17 23:27:07', '2024-03-17 23:27:07', 10, 10);
INSERT INTO `category` VALUES (18, '健康', 8, 1, '2024-03-17 23:28:53', '2024-03-17 23:28:53', 10, 10);
INSERT INTO `category` VALUES (19, '经济学', 9, 1, '2024-03-17 23:29:05', '2024-03-17 23:29:05', 10, 10);
INSERT INTO `category` VALUES (20, '微信小程序', 10, 1, '2024-03-17 23:29:27', '2024-03-17 23:29:27', 10, 10);
INSERT INTO `category` VALUES (21, 'Electron', 11, 1, '2024-03-17 23:29:46', '2024-03-17 23:29:46', 10, 10);
INSERT INTO `category` VALUES (22, 'Dart', 12, 1, '2024-03-17 23:30:10', '2024-03-17 23:30:10', 10, 10);
INSERT INTO `category` VALUES (23, 'Java', 13, 1, '2024-03-17 23:31:07', '2024-03-17 23:31:07', 10, 10);

-- ----------------------------
-- Table structure for comments
-- ----------------------------
DROP TABLE IF EXISTS `comments`;
CREATE TABLE `comments`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `article_id` bigint(20) NOT NULL COMMENT '评论博文ID',
  `like_count` bigint(20) NOT NULL DEFAULT 0 COMMENT '点赞数',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '评论内容',
  `parent_id` bigint(20) NOT NULL COMMENT '父评论ID',
  `status` int(2) NULL DEFAULT 1 COMMENT '博文状态 0:禁用，1:启用',
  `create_time` datetime NULL DEFAULT NULL COMMENT '评论日期',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '发表用户ID',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '修改人',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `article_id`(`article_id`) USING BTREE,
  INDEX `parent_comment_id`(`parent_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博文评论表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of comments
-- ----------------------------

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '菜单id',
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '标题',
  `parent_id` bigint(20) NULL DEFAULT 0 COMMENT '父级菜单',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '显示顺序',
  `path` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '路径',
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '名称',
  `component` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '组件',
  `icon` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '图标',
  `menu_type` char(1) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '' COMMENT '菜单类型（M目录 C菜单 F按钮）',
  `perms` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '权限标识',
  `redirect` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '重定向',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '修改人',
  `status` tinyint(1) NULL DEFAULT 1 COMMENT '菜单状态（1正常 0停用）',
  `visible` char(1) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',
  `is_frame` int(11) NULL DEFAULT 1 COMMENT '是否为外链（0是 1否）',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `index_title`(`title`) USING BTREE COMMENT '标题唯一'
) ENGINE = InnoDB AUTO_INCREMENT = 63 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '菜单集合' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of menu
-- ----------------------------
INSERT INTO `menu` VALUES (5, '权限管理', 0, 1, '/permisttion', 'permission', '', 'table', 'M', 'permission', '/permisttion/admin/index', '2021-03-31 03:12:12', '2024-03-14 18:18:13', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (6, '博文管理', 0, 2, '/blog', 'article', '', 'excel', 'M', 'artile', '/blog/category/index', '2021-03-31 03:12:12', '2024-03-14 18:18:33', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (7, '博客设置', 0, 3, 'setting', 'setting', 'setting/index', 'swagger', 'C', 'setting:query', '/setting/index', '2021-03-31 03:12:12', '2024-03-15 11:18:05', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (8, '用户管理', 5, 1, 'admin', 'adminList', 'permission/admin/index', 'peoples', 'C', 'user:list', NULL, '2021-03-31 03:12:12', '2024-03-14 18:16:30', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (9, '角色管理', 5, 1, 'roles', 'role', 'permission/roles/index', 'layers', 'C', 'role:list', NULL, '2021-03-31 03:12:12', '2024-03-15 11:23:02', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (10, '菜单管理', 5, 1, 'menus', 'menu', 'permission/menus/index', 'form', 'C', 'menu:list', NULL, '2021-03-31 03:12:12', '2024-03-14 18:17:17', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (11, '分类管理', 6, 1, 'category', 'category', 'blog/category/index', 'book-reference', 'C', 'artilce:category:list', NULL, '2021-03-31 03:12:12', '2024-03-15 11:22:48', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (12, '标签管理', 6, 1, 'tags', 'tags', 'blog/tags/index', 'tag', 'C', 'artilce:tags:list', NULL, '2021-03-31 03:12:12', '2024-03-15 11:21:14', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (13, '文章管理', 6, 1, 'article', 'list', 'blog/article/index', 'compose', 'C', 'artilce:list', NULL, '2021-03-31 03:12:12', '2024-03-15 11:20:49', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (14, '评论管理', 6, 1, 'comments', 'comments', 'blog/comments/index', 'pdf', 'C', 'artilce:comments:list', NULL, '2021-03-31 03:12:12', '2024-03-14 13:30:33', 10, 10, 0, '0', 1);
INSERT INTO `menu` VALUES (15, '用户查询', 8, 1, '', '', '', NULL, 'F', 'permission:user:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (16, '用户新增', 8, 1, '', '', '', NULL, 'F', 'permission:user:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (17, '用户修改', 8, 1, '', '', '', NULL, 'F', 'permission:user:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (18, '用户删除', 8, 1, '', '', '', NULL, 'F', 'permission:user:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (19, '用户导出', 8, 1, '', '', '', NULL, 'F', 'permission:user:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (20, '用户导入', 8, 1, '', '', '', NULL, 'F', 'permission:user:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (21, '角色查询', 9, 1, '', '', '', NULL, 'F', 'permission:role:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (22, '角色新增', 9, 1, '', '', '', NULL, 'F', 'permission:role:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (23, '角色修改', 9, 1, '', '', '', NULL, 'F', 'permission:role:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (24, '角色删除', 9, 1, '', '', '', NULL, 'F', 'permission:role:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (25, '角色导出', 9, 1, '', '', '', NULL, 'F', 'permission:role:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (26, '角色导入', 9, 1, '', '', '', NULL, 'F', 'permission:role:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (27, '菜单查询', 10, 1, '', '', '', NULL, 'F', 'permission:menu:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (28, '菜单新增', 10, 1, '', '', '', NULL, 'F', 'permission:menu:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (29, '菜单修改', 10, 1, '', '', '', NULL, 'F', 'permission:menu:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (30, '菜单删除', 10, 1, '', '', '', NULL, 'F', 'permission:menu:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (31, '菜单导出', 10, 1, '', '', '', NULL, 'F', 'permission:menu:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (32, '菜单导入', 10, 1, '', '', '', NULL, 'F', 'permission:menu:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (33, '分类查询', 11, 1, '', '', '', NULL, 'F', 'permission:category:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (34, '分类新增', 11, 1, '', '', '', NULL, 'F', 'permission:category:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (35, '分类修改', 11, 1, '', '', '', NULL, 'F', 'permission:category:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (36, '分类删除', 11, 1, '', '', '', NULL, 'F', 'permission:category:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (37, '分类导出', 11, 1, '', '', '', NULL, 'F', 'permission:category:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (38, '分类导入', 11, 1, '', '', '', NULL, 'F', 'permission:category:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (45, '标签查询', 12, 2, '', '', '', NULL, 'F', 'permission:tags:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (46, '标签新增', 12, 2, '', '', '', NULL, 'F', 'permission:tags:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (47, '标签修改', 12, 2, '', '', '', NULL, 'F', 'permission:tags:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (48, '标签删除', 12, 2, '', '', '', NULL, 'F', 'permission:tags:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (49, '标签导出', 12, 2, '', '', '', NULL, 'F', 'permission:tags:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (50, '标签导入', 12, 2, '', '', '', NULL, 'F', 'permission:tags:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (51, '文章查询', 13, 2, '', '', '', NULL, 'F', 'permission:article:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (52, '文章新增', 13, 2, '', '', '', NULL, 'F', 'permission:article:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (53, '文章修改', 13, 2, '', '', '', NULL, 'F', 'permission:article:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (54, '文章删除', 13, 2, '', '', '', NULL, 'F', 'permission:article:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (55, '文章导出', 13, 2, '', '', '', NULL, 'F', 'permission:article:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (56, '文章导入', 13, 2, '', '', '', NULL, 'F', 'permission:article:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (57, '评论查询', 14, 2, '', '', '', NULL, 'F', 'permission:comments:query', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (58, '评论新增', 14, 2, '', '', '', NULL, 'F', 'permission:comments:add', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (59, '评论修改', 14, 2, '', '', '', NULL, 'F', 'permission:comments:update', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (60, '评论删除', 14, 2, '', '', '', NULL, 'F', 'permission:comments:delete', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (61, '评论导出', 14, 2, '', '', '', NULL, 'F', 'permission:comments:export', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);
INSERT INTO `menu` VALUES (62, '评论导入', 14, 2, '', '', '', NULL, 'F', 'permission:comments:import', NULL, '2021-03-31 03:12:12', '2021-03-31 03:12:12', 10, 10, 1, '0', 1);

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主键',
  `role_name` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名称',
  `role_en` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '权限字符',
  `menus` json NOT NULL COMMENT '菜单权限集合',
  `info` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `systemic` tinyint(2) NULL DEFAULT 0 COMMENT '是否为系统内置角色',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '最后修改时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人id',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '最后修改人id',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `unq_role_name`(`role_name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '角色表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of role
-- ----------------------------
INSERT INTO `role` VALUES (10, '超级管理员', 'superAdmin', '[5, 8, 15, 16, 17, 18, 19, 20, 9, 21, 22, 23, 24, 25, 26, 10, 27, 28, 29, 30, 31, 32, 6, 11, 33, 34, 35, 36, 37, 38, 12, 45, 46, 47, 48, 49, 50, 13, 51, 52, 53, 54, 55, 56, 14, 57, 58, 59, 60, 61, 62, 7]', '系统内置管理员，不可编辑删除', 1, '2024-03-12 17:22:53', '2024-03-12 20:30:32', 10, 10);
INSERT INTO `role` VALUES (11, '普通用户', 'visitor', '[7, 127, 128, 129, 130]', NULL, 1, '2024-03-12 18:14:54', '2024-03-12 19:57:26', 10, 10);
INSERT INTO `role` VALUES (14, '内容管理员', 'articleAdmin', '[6, 11, 33, 34, 35, 36, 37, 38, 12, 45, 46, 47, 48, 49, 50, 13, 51, 52, 53, 54, 55, 56, 14, 57, 58, 59, 60, 61, 62]', NULL, 1, '2024-03-12 18:23:20', '2024-03-12 18:23:20', 10, 10);

-- ----------------------------
-- Table structure for setting
-- ----------------------------
DROP TABLE IF EXISTS `setting`;
CREATE TABLE `setting`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `blog_name` varchar(45) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客名称',
  `author` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '作者名',
  `logo` varchar(150) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客 LOGO',
  `avatar` varchar(150) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '作者头像',
  `introduction` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '介绍语',
  `github_home_page` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'GitHub 主页访问地址',
  `gitee_home_page` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'Gitee  主页访问地址',
  `bilibili_home_page` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'B站 主页访问地址',
  `doc_library` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '文档库地址',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '最后修改时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人id',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '最后修改人id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客设置表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of setting
-- ----------------------------
INSERT INTO `setting` VALUES (1, '程序猿小萨', '程序猿小萨', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/e4b4faf7-b127-4041-83fd-3e0a28345586.png', 'https://qarabala-video-save.oss-cn-beijing.aliyuncs.com/a67c54cd-c156-4871-a8c1-05d5e1cb157b.png', '你的时间有限，不要浪费于重复别人的生活。不要让别人的观点淹没了你内心的声音。——史蒂夫·乔布斯', 'https://github.com/programmer-xiaosa', 'https://gitee.com/qarabala', 'https://space.bilibili.com/1562860055/favlist?fid=1592147955&ftype=create', 'https://qarabala.gitee.io/blog/', '2024-02-28 14:56:09', '2024-03-18 18:56:24', 10, 10);

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL COMMENT '标签名称',
  `sort` int(11) NOT NULL DEFAULT 0 COMMENT '顺序',
  `status` int(2) NULL DEFAULT 1 COMMENT '标签状态 0:禁用，1:启用',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `create_user` bigint(20) NULL DEFAULT NULL COMMENT '创建人',
  `update_user` bigint(20) NULL DEFAULT NULL COMMENT '修改人',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `idx_name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 62 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '标签表' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES (39, 'Postman', 1, 1, '2024-03-17 23:27:25', '2024-03-17 23:27:25', 10, 10);
INSERT INTO `tags` VALUES (40, 'Flutter', 2, 1, '2024-03-17 23:27:33', '2024-03-17 23:27:33', 10, 10);
INSERT INTO `tags` VALUES (41, 'MySql', 3, 1, '2024-03-17 23:27:39', '2024-03-17 23:27:39', 10, 10);
INSERT INTO `tags` VALUES (42, 'Nodejs', 4, 1, '2024-03-17 23:27:48', '2024-03-17 23:27:48', 10, 10);
INSERT INTO `tags` VALUES (44, 'React', 6, 1, '2024-03-17 23:28:03', '2024-03-17 23:28:03', 10, 10);
INSERT INTO `tags` VALUES (45, 'Vue2', 7, 1, '2024-03-17 23:28:11', '2024-03-17 23:28:11', 10, 10);
INSERT INTO `tags` VALUES (46, 'Vue3', 8, 1, '2024-03-17 23:28:19', '2024-03-17 23:28:19', 10, 10);
INSERT INTO `tags` VALUES (47, 'SpringBoot', 8, 1, '2024-03-17 23:31:38', '2024-03-17 23:33:32', 10, 10);
INSERT INTO `tags` VALUES (48, 'Redis', 9, 1, '2024-03-17 23:31:48', '2024-03-17 23:31:48', 10, 10);
INSERT INTO `tags` VALUES (49, 'MyBatis', 10, 1, '2024-03-17 23:32:18', '2024-03-17 23:32:18', 10, 10);
INSERT INTO `tags` VALUES (50, 'MyBatis-Plus', 11, 1, '2024-03-17 23:32:25', '2024-03-17 23:32:25', 10, 10);
INSERT INTO `tags` VALUES (51, 'Linux', 12, 1, '2024-03-17 23:32:41', '2024-03-17 23:32:41', 10, 10);
INSERT INTO `tags` VALUES (52, '实战', 13, 1, '2024-03-17 23:34:15', '2024-03-17 23:34:15', 10, 10);
INSERT INTO `tags` VALUES (53, 'API', 14, 1, '2024-03-17 23:34:30', '2024-03-17 23:34:30', 10, 10);
INSERT INTO `tags` VALUES (54, 'Vite', 15, 1, '2024-03-17 23:34:50', '2024-03-17 23:34:50', 10, 10);
INSERT INTO `tags` VALUES (55, 'TypeScript', 16, 1, '2024-03-17 23:35:29', '2024-03-17 23:35:29', 10, 10);
INSERT INTO `tags` VALUES (56, 'UniApp', 17, 1, '2024-03-17 23:36:50', '2024-03-17 23:36:50', 10, 10);
INSERT INTO `tags` VALUES (57, 'Sequelize', 18, 1, '2024-03-17 23:37:27', '2024-03-17 23:37:27', 10, 10);
INSERT INTO `tags` VALUES (58, '图文教程', 19, 1, '2024-03-17 23:46:19', '2024-03-17 23:46:19', 10, 10);
INSERT INTO `tags` VALUES (59, 'Dart', 20, 1, '2024-03-18 18:07:12', '2024-03-18 18:07:12', 10, 10);
INSERT INTO `tags` VALUES (60, 'Electron', 21, 1, '2024-03-18 18:10:23', '2024-03-18 18:10:23', 10, 10);
INSERT INTO `tags` VALUES (61, 'APP', 22, 1, '2024-03-18 18:10:30', '2024-03-18 18:10:30', 10, 10);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `openid` varchar(45) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '微信用户唯一标识',
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '姓名',
  `phone` varchar(11) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '手机号',
  `sex` varchar(2) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '性别',
  `id_number` varchar(18) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '身份证号',
  `avatar` varchar(500) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '头像',
  `create_time` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '用户信息' ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------

SET FOREIGN_KEY_CHECKS = 1;
